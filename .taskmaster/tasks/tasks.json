{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Repository Configuration",
        "description": "Initialize the Next.js project with TypeScript, Tailwind CSS, and configure the repository structure according to the PRD guidelines.",
        "details": "1. Create a new Next.js project with TypeScript support:\n```bash\nnpx create-next-app@latest peerchamp --typescript --tailwind --eslint\n```\n2. Set up the folder structure as specified in the PRD:\n   - components/\n   - pages/\n   - lib/\n   - hooks/\n   - types/\n   - styles/\n   - public/\n   - tests/\n3. Configure ESLint and Prettier for code quality\n4. Set up Jest and React Testing Library for unit testing\n5. Configure Cypress for end-to-end testing\n6. Set up GitHub Actions for CI/CD pipeline\n7. Configure Vercel deployment",
        "testStrategy": "Verify the project structure is correctly set up by running the development server and ensuring it starts without errors. Run linting checks to confirm ESLint configuration is working. Execute a sample test to verify the testing framework is properly configured.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js project with TypeScript and Tailwind CSS",
            "description": "Create a new Next.js project with TypeScript and Tailwind CSS support using the create-next-app command.",
            "dependencies": [],
            "details": "Run the following command in the terminal to create a new Next.js project with TypeScript, Tailwind CSS, and ESLint:\n\nnpx create-next-app@latest peerchamp --typescript --tailwind --eslint\n\nAfter initialization, navigate to the project directory:\n\ncd peerchamp\n\nVerify the project structure and ensure the basic Next.js application is running with:\n\nnpm run dev",
            "status": "done",
            "testStrategy": "Verify the project is correctly set up by ensuring the development server starts without errors and the default Next.js page loads in the browser."
          },
          {
            "id": 2,
            "title": "Set up project folder structure",
            "description": "Create the required folder structure according to the PRD guidelines to organize the codebase properly.",
            "dependencies": [],
            "details": "Create the following directory structure in the project root:\n\n- components/ (for reusable UI components)\n- pages/ (already created by Next.js)\n- lib/ (for utility functions and services)\n- hooks/ (for custom React hooks)\n- types/ (for TypeScript type definitions)\n- styles/ (for global styles and CSS modules)\n- public/ (already created by Next.js)\n- tests/ (for test files)\n\nAdd a .gitkeep file in each empty directory to ensure they're tracked by Git.",
            "status": "done",
            "testStrategy": "Verify all directories exist and follow the structure defined in the PRD."
          },
          {
            "id": 3,
            "title": "Configure ESLint and Prettier",
            "description": "Set up ESLint and Prettier for code quality and consistent formatting across the project.",
            "dependencies": [],
            "details": "1. Install Prettier and ESLint plugins:\n\nnpm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier\n\n2. Create a .prettierrc file in the root directory:\n\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\"\n}\n\n3. Update the .eslintrc.json file to include Prettier:\n\n{\n  \"extends\": [\n    \"next/core-web-vitals\",\n    \"prettier\"\n  ],\n  \"plugins\": [\"prettier\"],\n  \"rules\": {\n    \"prettier/prettier\": \"error\",\n    \"react/react-in-jsx-scope\": \"off\"\n  }\n}\n\n4. Add scripts to package.json:\n\n\"scripts\": {\n  // existing scripts\n  \"lint\": \"next lint\",\n  \"format\": \"prettier --write .\"\n}",
            "status": "done",
            "testStrategy": "Run 'npm run lint' and 'npm run format' to verify ESLint and Prettier configurations are working correctly."
          },
          {
            "id": 4,
            "title": "Set up Jest and React Testing Library",
            "description": "Configure Jest and React Testing Library for unit testing components and utilities.",
            "dependencies": [],
            "details": "1. Install Jest and React Testing Library:\n\nnpm install --save-dev jest @testing-library/react @testing-library/jest-dom @testing-library/user-event jest-environment-jsdom\n\n2. Create a jest.config.js file in the root directory:\n\nconst nextJest = require('next/jest')\n\nconst createJestConfig = nextJest({\n  dir: './'\n})\n\nconst customJestConfig = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  testEnvironment: 'jest-environment-jsdom',\n  moduleDirectories: ['node_modules', '<rootDir>/'],\n  testPathIgnorePatterns: ['<rootDir>/cypress/']\n}\n\nmodule.exports = createJestConfig(customJestConfig)\n\n3. Create a jest.setup.js file:\n\nimport '@testing-library/jest-dom'\n\n4. Add test script to package.json:\n\n\"scripts\": {\n  // existing scripts\n  \"test\": \"jest\",\n  \"test:watch\": \"jest --watch\"\n}\n\n5. Create a sample test file in tests/example.test.tsx to verify setup:\n\nimport { render, screen } from '@testing-library/react'\nimport Home from '../pages/index'\n\ndescribe('Home', () => {\n  it('renders a heading', () => {\n    render(<Home />)\n    const heading = screen.getByRole('heading', { level: 1 })\n    expect(heading).toBeInTheDocument()\n  })\n})",
            "status": "done",
            "testStrategy": "Run 'npm test' to verify Jest and React Testing Library are correctly configured and the sample test passes."
          },
          {
            "id": 5,
            "title": "Configure Cypress for end-to-end testing",
            "description": "Set up Cypress for end-to-end testing of the application.",
            "dependencies": [],
            "details": "1. Install Cypress:\n\nnpm install --save-dev cypress\n\n2. Add Cypress scripts to package.json:\n\n\"scripts\": {\n  // existing scripts\n  \"cypress\": \"cypress open\",\n  \"cypress:run\": \"cypress run\"\n}\n\n3. Initialize Cypress by running:\n\nnpx cypress open\n\n4. Create a basic test in cypress/e2e/home.cy.js:\n\ndescribe('Home Page', () => {\n  it('should navigate to the home page', () => {\n    cy.visit('http://localhost:3000')\n    cy.get('h1').should('exist')\n  })\n})\n\n5. Configure Cypress in cypress.config.js:\n\nconst { defineConfig } = require('cypress')\n\nmodule.exports = defineConfig({\n  e2e: {\n    baseUrl: 'http://localhost:3000',\n    setupNodeEvents(on, config) {},\n  },\n})",
            "status": "done",
            "testStrategy": "Run 'npm run cypress' to open the Cypress test runner and execute the sample test to verify the setup."
          },
          {
            "id": 6,
            "title": "Set up GitHub Actions for CI/CD",
            "description": "Configure GitHub Actions workflow for continuous integration and deployment.",
            "dependencies": [],
            "details": "1. Create a .github/workflows directory in the project root\n\n2. Create a ci.yml file in the workflows directory:\n\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run build\n      - run: npm test\n\n  e2e-tests:\n    runs-on: ubuntu-latest\n    needs: build-and-test\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n          cache: 'npm'\n      - run: npm ci\n      - name: Cypress run\n        uses: cypress-io/github-action@v5\n        with:\n          build: npm run build\n          start: npm start\n          wait-on: 'http://localhost:3000'",
            "status": "done",
            "testStrategy": "Verify the GitHub Actions workflow by pushing to the repository and checking that the CI workflow runs successfully."
          },
          {
            "id": 7,
            "title": "Configure Vercel deployment",
            "description": "Set up Vercel for automatic deployments of the Next.js application.",
            "dependencies": [],
            "details": "1. Install Vercel CLI:\n\nnpm install -g vercel\n\n2. Create a vercel.json configuration file in the project root:\n\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"package.json\",\n      \"use\": \"@vercel/next\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ],\n  \"env\": {\n    \"NEXT_PUBLIC_APP_URL\": \"@app_url\"\n  }\n}\n\n3. Link the project to Vercel:\n\nvercel login\nvercel link\n\n4. Set up environment variables in Vercel dashboard or using the CLI:\n\nvercel env add NEXT_PUBLIC_APP_URL\n\n5. Deploy the project:\n\nvercel --prod",
            "status": "done",
            "testStrategy": "Verify the deployment by checking that the application is accessible at the Vercel URL and functions correctly."
          },
          {
            "id": 8,
            "title": "Create environment configuration",
            "description": "Set up environment variables and configuration for different environments (development, testing, production).",
            "dependencies": [],
            "details": "1. Create a .env.local file for local development:\n\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n\n2. Create a .env.example file as a template:\n\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n\n3. Add .env.local to .gitignore to prevent committing sensitive information:\n\n# Add to .gitignore\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\n4. Create a config.ts file in the lib directory to centralize configuration:\n\n// lib/config.ts\nexport const config = {\n  appUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n  environment: process.env.NODE_ENV || 'development',\n  isProduction: process.env.NODE_ENV === 'production',\n  isDevelopment: process.env.NODE_ENV === 'development',\n  isTest: process.env.NODE_ENV === 'test',\n}",
            "status": "done",
            "testStrategy": "Verify environment variables are correctly loaded by creating a test that checks the config object contains the expected values."
          },
          {
            "id": 9,
            "title": "Document project setup and contribution guidelines",
            "description": "Create documentation for project setup, development workflow, and contribution guidelines.",
            "dependencies": [],
            "details": "1. Create a README.md file in the project root with the following sections:\n\n- Project overview\n- Prerequisites\n- Installation and setup\n- Development workflow\n- Testing\n- Deployment\n- Project structure\n- Contributing guidelines\n\n2. Create a CONTRIBUTING.md file with detailed contribution guidelines:\n\n- Code style and standards\n- Pull request process\n- Issue reporting\n- Branch naming conventions\n- Commit message format\n\n3. Create a docs/ directory for additional documentation:\n\n- docs/architecture.md - Overview of the application architecture\n- docs/testing.md - Detailed testing guidelines\n- docs/deployment.md - Deployment process documentation",
            "status": "done",
            "testStrategy": "Review documentation for completeness and accuracy. Verify that a new team member can follow the setup instructions successfully."
          }
        ]
      },
      {
        "id": 2,
        "title": "Supabase Integration and Database Schema Setup",
        "description": "Set up Supabase project and implement the database schema as defined in the PRD, including tables for companies, users, advocates, opportunities, and reference calls.",
        "details": "1. Create a new Supabase project\n2. Configure environment variables for Supabase connection\n3. Implement the database schema using SQL migrations:\n```sql\n-- Companies (Tenants)\nCREATE TABLE companies (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name TEXT NOT NULL,\n  domain TEXT UNIQUE,\n  subscription_tier TEXT DEFAULT 'professional',\n  settings JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Users (Sales Reps, Advocates, Admins)\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  email TEXT UNIQUE NOT NULL,\n  role TEXT NOT NULL, -- 'sales_rep', 'advocate', 'admin'\n  profile JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Advocates table\nCREATE TABLE advocates (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id),\n  company_id UUID REFERENCES companies(id),\n  name TEXT NOT NULL,\n  title TEXT,\n  company_name TEXT,\n  industry TEXT,\n  company_size TEXT,\n  use_cases TEXT[],\n  geographic_region TEXT,\n  expertise_areas TEXT[],\n  availability_score INTEGER DEFAULT 100,\n  total_calls_completed INTEGER DEFAULT 0,\n  last_call_date TIMESTAMP,\n  max_calls_per_month INTEGER DEFAULT 4,\n  status TEXT DEFAULT 'active',\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Opportunities table  \nCREATE TABLE opportunities (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_company TEXT NOT NULL,\n  prospect_industry TEXT,\n  prospect_size TEXT,\n  use_case TEXT,\n  deal_value DECIMAL,\n  stage TEXT,\n  urgency TEXT DEFAULT 'medium',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Reference Calls\nCREATE TABLE reference_calls (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  opportunity_id UUID REFERENCES opportunities(id),\n  advocate_id UUID REFERENCES advocates(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_email TEXT,\n  prospect_name TEXT,\n  scheduled_at TIMESTAMP,\n  status TEXT DEFAULT 'scheduled', -- 'scheduled', 'completed', 'cancelled'\n  meeting_link TEXT,\n  call_intelligence JSONB,\n  advocate_feedback JSONB,\n  reward_amount DECIMAL,\n  reward_type TEXT,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```\n4. Create TypeScript types for database entities\n5. Set up Supabase client in the application\n6. Configure Row Level Security (RLS) policies for multi-tenant isolation",
        "testStrategy": "Write SQL queries to test the schema integrity, relationships, and constraints. Create unit tests for the Supabase client configuration. Verify RLS policies by attempting cross-tenant data access.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and configure Supabase project",
            "description": "Set up a new Supabase project and configure the necessary environment variables for connecting to it from the application",
            "dependencies": [],
            "details": "1. Create a new Supabase project from the Supabase dashboard\n2. Note the project URL and anon key from the API settings\n3. Create a .env.local file in the project root\n4. Add the following environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   SUPABASE_SERVICE_ROLE_KEY=your-service-role-key\n   ```\n5. Add these variables to .gitignore to prevent committing secrets",
            "status": "done",
            "testStrategy": "Verify environment variables are correctly loaded in the application by creating a simple test that checks if the variables are defined"
          },
          {
            "id": 2,
            "title": "Create companies and users tables",
            "description": "Implement the database schema for the companies and users tables using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Companies (Tenants)\nCREATE TABLE companies (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name TEXT NOT NULL,\n  domain TEXT UNIQUE,\n  subscription_tier TEXT DEFAULT 'professional',\n  settings JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Users (Sales Reps, Advocates, Admins)\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  email TEXT UNIQUE NOT NULL,\n  role TEXT NOT NULL, -- 'sales_rep', 'advocate', 'admin'\n  profile JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Run SQL queries to verify table creation, check constraints, and test inserting sample data to ensure the schema works as expected"
          },
          {
            "id": 3,
            "title": "Create advocates table",
            "description": "Implement the database schema for the advocates table using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Advocates table\nCREATE TABLE advocates (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id),\n  company_id UUID REFERENCES companies(id),\n  name TEXT NOT NULL,\n  title TEXT,\n  company_name TEXT,\n  industry TEXT,\n  company_size TEXT,\n  use_cases TEXT[],\n  geographic_region TEXT,\n  expertise_areas TEXT[],\n  availability_score INTEGER DEFAULT 100,\n  total_calls_completed INTEGER DEFAULT 0,\n  last_call_date TIMESTAMP,\n  max_calls_per_month INTEGER DEFAULT 4,\n  status TEXT DEFAULT 'active',\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Verify the table creation with SQL queries, test foreign key constraints by attempting to insert records with invalid references"
          },
          {
            "id": 4,
            "title": "Create opportunities table",
            "description": "Implement the database schema for the opportunities table using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Opportunities table  \nCREATE TABLE opportunities (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_company TEXT NOT NULL,\n  prospect_industry TEXT,\n  prospect_size TEXT,\n  use_case TEXT,\n  deal_value DECIMAL,\n  stage TEXT,\n  urgency TEXT DEFAULT 'medium',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Test the table creation and constraints with SQL queries, verify foreign key relationships work correctly"
          },
          {
            "id": 5,
            "title": "Create reference_calls table",
            "description": "Implement the database schema for the reference_calls table using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Reference Calls\nCREATE TABLE reference_calls (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  opportunity_id UUID REFERENCES opportunities(id),\n  advocate_id UUID REFERENCES advocates(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_email TEXT,\n  prospect_name TEXT,\n  scheduled_at TIMESTAMP,\n  status TEXT DEFAULT 'scheduled', -- 'scheduled', 'completed', 'cancelled'\n  meeting_link TEXT,\n  call_intelligence JSONB,\n  advocate_feedback JSONB,\n  reward_amount DECIMAL,\n  reward_type TEXT,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Verify the table creation with SQL queries, test the foreign key constraints by attempting to insert records with invalid references to opportunities, advocates, and users"
          },
          {
            "id": 6,
            "title": "Set up Supabase client in the application",
            "description": "Configure the Supabase client for use throughout the application",
            "dependencies": [],
            "details": "1. Install the Supabase client library:\n```bash\nnpm install @supabase/supabase-js\n```\n2. Create a lib/supabase.ts file with the following content:\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n3. Create a utility function to get the service role client for admin operations:\n```typescript\n// Only use server-side\nexport const getServiceSupabase = () => {\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\n  return createClient(supabaseUrl, supabaseServiceKey);\n};\n```",
            "status": "done",
            "testStrategy": "Create a simple test that imports the Supabase client and verifies it's properly initialized. Test basic operations like querying a public table"
          },
          {
            "id": 7,
            "title": "Create TypeScript types for database entities",
            "description": "Define TypeScript interfaces for all database entities to ensure type safety throughout the application",
            "dependencies": [],
            "details": "Create a types/database.ts file with the following content:\n```typescript\nexport interface Company {\n  id: string;\n  name: string;\n  domain: string | null;\n  subscription_tier: string;\n  settings: Record<string, any>;\n  created_at: string;\n}\n\nexport interface User {\n  id: string;\n  company_id: string;\n  email: string;\n  role: 'sales_rep' | 'advocate' | 'admin';\n  profile: Record<string, any>;\n  created_at: string;\n}\n\nexport interface Advocate {\n  id: string;\n  user_id: string;\n  company_id: string;\n  name: string;\n  title: string | null;\n  company_name: string | null;\n  industry: string | null;\n  company_size: string | null;\n  use_cases: string[] | null;\n  geographic_region: string | null;\n  expertise_areas: string[] | null;\n  availability_score: number;\n  total_calls_completed: number;\n  last_call_date: string | null;\n  max_calls_per_month: number;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface Opportunity {\n  id: string;\n  company_id: string;\n  sales_rep_id: string;\n  prospect_company: string;\n  prospect_industry: string | null;\n  prospect_size: string | null;\n  use_case: string | null;\n  deal_value: number | null;\n  stage: string | null;\n  urgency: string;\n  created_at: string;\n}\n\nexport interface ReferenceCall {\n  id: string;\n  opportunity_id: string;\n  advocate_id: string;\n  sales_rep_id: string;\n  prospect_email: string | null;\n  prospect_name: string | null;\n  scheduled_at: string | null;\n  status: 'scheduled' | 'completed' | 'cancelled';\n  meeting_link: string | null;\n  call_intelligence: Record<string, any> | null;\n  advocate_feedback: Record<string, any> | null;\n  reward_amount: number | null;\n  reward_type: string | null;\n  created_at: string;\n}\n```",
            "status": "done",
            "testStrategy": "Verify type definitions by creating sample objects and checking for type errors. Ensure all database fields are properly represented in the TypeScript interfaces"
          },
          {
            "id": 8,
            "title": "Configure Row Level Security (RLS) policies",
            "description": "Implement Row Level Security policies in Supabase to ensure multi-tenant isolation and proper access control",
            "dependencies": [],
            "details": "Create a migration file with the following SQL to implement RLS policies:\n```sql\n-- Enable RLS on all tables\nALTER TABLE companies ENABLE ROW LEVEL SECURITY;\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\nALTER TABLE advocates ENABLE ROW LEVEL SECURITY;\nALTER TABLE opportunities ENABLE ROW LEVEL SECURITY;\nALTER TABLE reference_calls ENABLE ROW LEVEL SECURITY;\n\n-- Companies policies\nCREATE POLICY \"Users can view their own company\"\n  ON companies FOR SELECT\n  USING (id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Users policies\nCREATE POLICY \"Users can view users in their company\"\n  ON users FOR SELECT\n  USING (company_id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Advocates policies\nCREATE POLICY \"Users can view advocates in their company\"\n  ON advocates FOR SELECT\n  USING (company_id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Opportunities policies\nCREATE POLICY \"Users can view opportunities in their company\"\n  ON opportunities FOR SELECT\n  USING (company_id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Reference calls policies\nCREATE POLICY \"Users can view reference calls in their company\"\n  ON reference_calls FOR SELECT\n  USING (opportunity_id IN (\n    SELECT o.id FROM opportunities o\n    JOIN users u ON u.company_id = o.company_id\n    WHERE auth.uid() = u.id\n  ));\n```",
            "status": "done",
            "testStrategy": "Test RLS policies by creating multiple tenants and verifying that users from one tenant cannot access data from another tenant. Test with different user roles to ensure appropriate access levels"
          },
          {
            "id": 9,
            "title": "Create database access utility functions",
            "description": "Implement utility functions to simplify database operations and enforce type safety",
            "dependencies": [],
            "details": "Create a lib/db.ts file with the following content:\n```typescript\nimport { supabase } from './supabase';\nimport type { Company, User, Advocate, Opportunity, ReferenceCall } from '../types/database';\n\n// Companies\nexport const getCompany = async (id: string): Promise<Company | null> => {\n  const { data, error } = await supabase\n    .from('companies')\n    .select('*')\n    .eq('id', id)\n    .single();\n  \n  if (error) {\n    console.error('Error fetching company:', error);\n    return null;\n  }\n  \n  return data;\n};\n\n// Users\nexport const getUsersByCompany = async (companyId: string): Promise<User[]> => {\n  const { data, error } = await supabase\n    .from('users')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (error) {\n    console.error('Error fetching users:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n\n// Advocates\nexport const getAdvocatesByCompany = async (companyId: string): Promise<Advocate[]> => {\n  const { data, error } = await supabase\n    .from('advocates')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (error) {\n    console.error('Error fetching advocates:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n\n// Opportunities\nexport const getOpportunitiesByCompany = async (companyId: string): Promise<Opportunity[]> => {\n  const { data, error } = await supabase\n    .from('opportunities')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (error) {\n    console.error('Error fetching opportunities:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n\n// Reference Calls\nexport const getReferenceCallsByOpportunity = async (opportunityId: string): Promise<ReferenceCall[]> => {\n  const { data, error } = await supabase\n    .from('reference_calls')\n    .select('*')\n    .eq('opportunity_id', opportunityId);\n  \n  if (error) {\n    console.error('Error fetching reference calls:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n```",
            "status": "done",
            "testStrategy": "Create unit tests for each database utility function, mocking the Supabase client responses. Test error handling by simulating database errors"
          },
          {
            "id": 10,
            "title": "Create seed data script for development",
            "description": "Implement a script to populate the database with sample data for development and testing purposes",
            "dependencies": [],
            "details": "Create a scripts/seed.ts file with the following content:\n```typescript\nimport { getServiceSupabase } from '../lib/supabase';\n\nconst supabase = getServiceSupabase();\n\nasync function seedDatabase() {\n  console.log('Seeding database...');\n  \n  // Create sample company\n  const { data: company, error: companyError } = await supabase\n    .from('companies')\n    .insert({\n      name: 'Demo Company',\n      domain: 'democompany.com',\n      subscription_tier: 'professional'\n    })\n    .select()\n    .single();\n  \n  if (companyError) {\n    console.error('Error creating company:', companyError);\n    return;\n  }\n  \n  console.log('Created company:', company);\n  \n  // Create sample users\n  const { data: users, error: usersError } = await supabase\n    .from('users')\n    .insert([\n      {\n        company_id: company.id,\n        email: 'admin@democompany.com',\n        role: 'admin'\n      },\n      {\n        company_id: company.id,\n        email: 'sales@democompany.com',\n        role: 'sales_rep'\n      }\n    ])\n    .select();\n  \n  if (usersError) {\n    console.error('Error creating users:', usersError);\n    return;\n  }\n  \n  console.log('Created users:', users);\n  \n  // Create sample advocates\n  const { data: advocates, error: advocatesError } = await supabase\n    .from('advocates')\n    .insert([\n      {\n        company_id: company.id,\n        user_id: users[0].id,\n        name: 'John Advocate',\n        title: 'CTO',\n        company_name: 'Tech Solutions',\n        industry: 'Software',\n        company_size: '51-200',\n        use_cases: ['API Integration', 'Data Analysis'],\n        geographic_region: 'North America',\n        expertise_areas: ['Technical Implementation', 'Enterprise Architecture']\n      }\n    ])\n    .select();\n  \n  if (advocatesError) {\n    console.error('Error creating advocates:', advocatesError);\n    return;\n  }\n  \n  console.log('Created advocates:', advocates);\n  \n  // Create sample opportunities\n  const { data: opportunities, error: opportunitiesError } = await supabase\n    .from('opportunities')\n    .insert([\n      {\n        company_id: company.id,\n        sales_rep_id: users[1].id,\n        prospect_company: 'Acme Corp',\n        prospect_industry: 'Manufacturing',\n        prospect_size: '201-500',\n        use_case: 'Process Automation',\n        deal_value: 50000,\n        stage: 'Proposal'\n      }\n    ])\n    .select();\n  \n  if (opportunitiesError) {\n    console.error('Error creating opportunities:', opportunitiesError);\n    return;\n  }\n  \n  console.log('Created opportunities:', opportunities);\n  \n  // Create sample reference calls\n  const { data: calls, error: callsError } = await supabase\n    .from('reference_calls')\n    .insert([\n      {\n        opportunity_id: opportunities[0].id,\n        advocate_id: advocates[0].id,\n        sales_rep_id: users[1].id,\n        prospect_email: 'prospect@acmecorp.com',\n        prospect_name: 'Jane Prospect',\n        scheduled_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),\n        status: 'scheduled'\n      }\n    ])\n    .select();\n  \n  if (callsError) {\n    console.error('Error creating reference calls:', callsError);\n    return;\n  }\n  \n  console.log('Created reference calls:', calls);\n  console.log('Database seeding completed!');\n}\n\nseedDatabase();\n```\n\nAdd a script to package.json:\n```json\n\"scripts\": {\n  \"seed\": \"ts-node scripts/seed.ts\"\n}\n```",
            "status": "done",
            "testStrategy": "Run the seed script in a development environment and verify that all tables are populated with the expected data. Check for any constraint violations or errors during the seeding process"
          }
        ]
      },
      {
        "id": 3,
        "title": "Authentication and User Management System",
        "description": "Implement authentication using Supabase Auth with role-based access control for different user types (sales reps, advocates, admins) and company-based tenant isolation.",
        "details": "1. Configure Supabase Auth with email/password and SSO options\n2. Create authentication hooks and context:\n```typescript\n// hooks/useAuth.ts\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { User } from '@supabase/supabase-js'\n\ntype AuthContextType = {\n  user: User | null\n  loading: boolean\n  signIn: (email: string, password: string) => Promise<void>\n  signOut: () => Promise<void>\n  // Additional auth methods\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null)\n  const [loading, setLoading] = useState(true)\n  \n  // Auth implementation\n  \n  return (\n    <AuthContext.Provider value={{ user, loading, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n```\n3. Implement sign-up, sign-in, and sign-out flows\n4. Create protected route components\n5. Implement role-based access control middleware\n6. Set up user profile management\n7. Configure company/tenant isolation logic\n8. Implement SSO integration for enterprise customers",
        "testStrategy": "Create unit tests for authentication hooks and components. Test protected routes with different user roles. Verify tenant isolation by attempting to access data from different companies. Test SSO integration with mock identity providers.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Auth with Email/Password Authentication",
            "description": "Set up Supabase Auth with email/password authentication method and configure the necessary settings in the Supabase dashboard.",
            "dependencies": [],
            "details": "1. Configure Supabase project settings for Auth\n2. Enable email/password authentication in Supabase dashboard\n3. Set up email templates for verification and password reset\n4. Configure security settings (session duration, password policies)\n5. Create the supabaseClient.ts file to initialize the Supabase client:\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey)\n```",
            "status": "pending",
            "testStrategy": "Verify Supabase Auth configuration by testing sign-up and sign-in flows manually. Ensure email templates are properly configured by testing the verification and password reset flows."
          },
          {
            "id": 2,
            "title": "Implement SSO Integration for Enterprise Customers",
            "description": "Configure Supabase Auth to support Single Sign-On (SSO) options for enterprise customers using OAuth providers.",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Enable OAuth providers in Supabase dashboard (Google, Microsoft, etc.)\n2. Configure OAuth provider settings (client IDs, secrets, redirect URLs)\n3. Implement provider-specific authentication methods in the auth service\n4. Create utility functions for handling OAuth flows:\n```typescript\n// services/ssoService.ts\nexport const initiateOAuthFlow = async (provider: 'google' | 'microsoft') => {\n  return await supabase.auth.signInWithOAuth({\n    provider,\n    options: {\n      redirectTo: `${window.location.origin}/auth/callback`\n    }\n  })\n}\n\nexport const handleOAuthCallback = async () => {\n  const { data, error } = await supabase.auth.getSession()\n  return { session: data.session, error }\n}\n```",
            "status": "pending",
            "testStrategy": "Test SSO integration with each configured provider. Verify redirect flows and session creation. Test with both new and existing users to ensure proper account linking."
          },
          {
            "id": 3,
            "title": "Create Authentication Context and Hooks",
            "description": "Implement the React context and hooks for authentication to provide user state and authentication methods throughout the application.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "1. Complete the AuthContext implementation with user state management\n2. Implement authentication methods (signIn, signOut, etc.)\n3. Add session persistence and auto-refresh logic\n4. Handle auth state changes with Supabase listeners\n5. Complete the implementation of the useAuth hook:\n```typescript\n// hooks/useAuth.ts\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { User, Session } from '@supabase/supabase-js'\n\ntype AuthContextType = {\n  user: User | null\n  session: Session | null\n  loading: boolean\n  signIn: (email: string, password: string) => Promise<{ error: any }>\n  signOut: () => Promise<void>\n  signUp: (email: string, password: string) => Promise<{ error: any }>\n  resetPassword: (email: string) => Promise<{ error: any }>\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null)\n  const [session, setSession] = useState<Session | null>(null)\n  const [loading, setLoading] = useState(true)\n  \n  useEffect(() => {\n    // Get initial session\n    supabase.auth.getSession().then(({ data: { session } }) => {\n      setSession(session)\n      setUser(session?.user ?? null)\n      setLoading(false)\n    })\n\n    // Listen for auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (_event, session) => {\n        setSession(session)\n        setUser(session?.user ?? null)\n        setLoading(false)\n      }\n    )\n\n    return () => subscription.unsubscribe()\n  }, [])\n  \n  const signIn = async (email: string, password: string) => {\n    const { error } = await supabase.auth.signInWithPassword({ email, password })\n    return { error }\n  }\n\n  const signUp = async (email: string, password: string) => {\n    const { error } = await supabase.auth.signUp({ email, password })\n    return { error }\n  }\n\n  const signOut = async () => {\n    await supabase.auth.signOut()\n  }\n\n  const resetPassword = async (email: string) => {\n    const { error } = await supabase.auth.resetPasswordForEmail(email, {\n      redirectTo: `${window.location.origin}/reset-password`,\n    })\n    return { error }\n  }\n  \n  return (\n    <AuthContext.Provider value={{ \n      user, \n      session,\n      loading, \n      signIn, \n      signOut,\n      signUp,\n      resetPassword\n    }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n```",
            "status": "pending",
            "testStrategy": "Write unit tests for the auth hooks using React Testing Library. Test all authentication methods with mock responses from Supabase. Verify context state updates correctly on auth events."
          },
          {
            "id": 4,
            "title": "Implement Sign-Up, Sign-In, and Sign-Out Flows",
            "description": "Create the UI components and forms for user authentication flows including sign-up, sign-in, sign-out, and password reset.",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Create sign-in form component with email/password fields and validation\n2. Implement sign-up form with necessary user information fields\n3. Add password reset request and confirmation forms\n4. Create SSO login buttons for configured providers\n5. Implement form validation using a form library (e.g., Formik, React Hook Form)\n6. Add error handling and user feedback\n7. Example sign-in component:\n```typescript\n// components/auth/SignInForm.tsx\nimport { useState } from 'react'\nimport { useAuth } from '../../hooks/useAuth'\nimport { useForm } from 'react-hook-form'\n\ntype SignInFormData = {\n  email: string\n  password: string\n}\n\nexport const SignInForm = () => {\n  const { signIn } = useAuth()\n  const [authError, setAuthError] = useState<string | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  \n  const { register, handleSubmit, formState: { errors } } = useForm<SignInFormData>()\n  \n  const onSubmit = async (data: SignInFormData) => {\n    setIsLoading(true)\n    setAuthError(null)\n    \n    const { error } = await signIn(data.email, data.password)\n    \n    if (error) {\n      setAuthError(error.message)\n    }\n    \n    setIsLoading(false)\n  }\n  \n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          {...register('email', { required: 'Email is required' })}\n        />\n        {errors.email && <p>{errors.email.message}</p>}\n      </div>\n      \n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          {...register('password', { required: 'Password is required' })}\n        />\n        {errors.password && <p>{errors.password.message}</p>}\n      </div>\n      \n      {authError && <div className=\"error\">{authError}</div>}\n      \n      <button type=\"submit\" disabled={isLoading}>\n        {isLoading ? 'Signing in...' : 'Sign In'}\n      </button>\n    </form>\n  )\n}\n```",
            "status": "pending",
            "testStrategy": "Test form validation for all authentication forms. Verify error handling and user feedback for various error scenarios. Test form submission with mock auth service responses."
          },
          {
            "id": 5,
            "title": "Create Protected Route Components",
            "description": "Implement protected route components to restrict access to authenticated users and handle redirects for unauthenticated users.",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Create a ProtectedRoute component that wraps routes requiring authentication\n2. Implement loading states for auth state resolution\n3. Add redirect logic for unauthenticated users\n4. Handle route access based on authentication state\n```typescript\n// components/auth/ProtectedRoute.tsx\nimport { useRouter } from 'next/router'\nimport { useAuth } from '../../hooks/useAuth'\nimport { ReactNode, useEffect } from 'react'\n\ntype ProtectedRouteProps = {\n  children: ReactNode\n}\n\nexport const ProtectedRoute = ({ children }: ProtectedRouteProps) => {\n  const { user, loading } = useAuth()\n  const router = useRouter()\n  \n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/auth/signin?redirect=' + router.asPath)\n    }\n  }, [user, loading, router])\n  \n  if (loading) {\n    return <div>Loading...</div>\n  }\n  \n  return user ? <>{children}</> : null\n}\n```\n5. Create a higher-order component for Next.js pages:\n```typescript\n// hoc/withAuth.tsx\nimport { NextPage } from 'next'\nimport { ProtectedRoute } from '../components/auth/ProtectedRoute'\n\nexport const withAuth = (Component: NextPage) => {\n  const AuthenticatedComponent = (props: any) => {\n    return (\n      <ProtectedRoute>\n        <Component {...props} />\n      </ProtectedRoute>\n    )\n  }\n  \n  return AuthenticatedComponent\n}\n```",
            "status": "pending",
            "testStrategy": "Test protected routes with authenticated and unauthenticated user states. Verify redirects to login page with correct return URLs. Test loading states during authentication checks."
          },
          {
            "id": 6,
            "title": "Implement Role-Based Access Control",
            "description": "Create a role-based access control system to manage permissions for different user types (sales reps, advocates, admins).",
            "dependencies": [
              "3.3",
              "3.5"
            ],
            "details": "1. Define role types and permission structures\n2. Create database tables for roles and permissions\n3. Implement role assignment and verification logic\n4. Create a useRBAC hook for permission checking\n5. Implement role-based UI components\n```typescript\n// types/roles.ts\nexport type UserRole = 'admin' | 'sales_rep' | 'advocate'\n\nexport interface Permission {\n  action: string\n  resource: string\n}\n\nexport interface RolePermissions {\n  [role: string]: Permission[]\n}\n\n// hooks/useRBAC.ts\nimport { useAuth } from './useAuth'\nimport { useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { UserRole, Permission, RolePermissions } from '../types/roles'\n\nconst defaultPermissions: RolePermissions = {\n  admin: [\n    { action: '*', resource: '*' }\n  ],\n  sales_rep: [\n    { action: 'read', resource: 'advocates' },\n    { action: 'create', resource: 'calls' },\n    { action: '*', resource: 'opportunities' }\n  ],\n  advocate: [\n    { action: 'read', resource: 'calls' },\n    { action: 'update', resource: 'profile' },\n    { action: 'update', resource: 'availability' }\n  ]\n}\n\nexport const useRBAC = () => {\n  const { user } = useAuth()\n  const [userRole, setUserRole] = useState<UserRole | null>(null)\n  const [loading, setLoading] = useState(true)\n  \n  useEffect(() => {\n    const fetchUserRole = async () => {\n      if (!user) {\n        setUserRole(null)\n        setLoading(false)\n        return\n      }\n      \n      const { data, error } = await supabase\n        .from('user_roles')\n        .select('role')\n        .eq('user_id', user.id)\n        .single()\n      \n      if (error || !data) {\n        console.error('Error fetching user role:', error)\n        setUserRole(null)\n      } else {\n        setUserRole(data.role as UserRole)\n      }\n      \n      setLoading(false)\n    }\n    \n    fetchUserRole()\n  }, [user])\n  \n  const hasPermission = (action: string, resource: string): boolean => {\n    if (!userRole) return false\n    \n    const permissions = defaultPermissions[userRole] || []\n    \n    return permissions.some(permission => \n      (permission.action === '*' || permission.action === action) &&\n      (permission.resource === '*' || permission.resource === resource)\n    )\n  }\n  \n  return { userRole, loading, hasPermission }\n}\n\n// components/auth/PermissionGate.tsx\nimport { ReactNode } from 'react'\nimport { useRBAC } from '../../hooks/useRBAC'\n\ntype PermissionGateProps = {\n  action: string\n  resource: string\n  children: ReactNode\n  fallback?: ReactNode\n}\n\nexport const PermissionGate = ({\n  action,\n  resource,\n  children,\n  fallback = null\n}: PermissionGateProps) => {\n  const { hasPermission, loading } = useRBAC()\n  \n  if (loading) return null\n  \n  return hasPermission(action, resource) ? <>{children}</> : <>{fallback}</>\n}\n```",
            "status": "pending",
            "testStrategy": "Test permission checks for different user roles. Verify UI components correctly show/hide based on permissions. Test role assignment and changes. Create test cases for each defined role and permission combination."
          },
          {
            "id": 7,
            "title": "Set Up User Profile Management",
            "description": "Implement user profile management functionality to allow users to view and update their profile information.",
            "dependencies": [
              "3.3",
              "3.6"
            ],
            "details": "1. Create user profile database schema with necessary fields\n2. Implement profile data fetching and update services\n3. Create profile edit form components\n4. Add profile image upload functionality\n5. Implement profile settings page\n```typescript\n// types/user.ts\nexport interface UserProfile {\n  id: string\n  user_id: string\n  first_name: string\n  last_name: string\n  email: string\n  phone?: string\n  job_title?: string\n  company_id?: string\n  avatar_url?: string\n  created_at: string\n  updated_at: string\n}\n\n// services/userService.ts\nimport { supabase } from '../lib/supabaseClient'\nimport { UserProfile } from '../types/user'\n\nexport const getUserProfile = async (userId: string): Promise<UserProfile | null> => {\n  const { data, error } = await supabase\n    .from('profiles')\n    .select('*')\n    .eq('user_id', userId)\n    .single()\n  \n  if (error) {\n    console.error('Error fetching user profile:', error)\n    return null\n  }\n  \n  return data as UserProfile\n}\n\nexport const updateUserProfile = async (profile: Partial<UserProfile>): Promise<{ data: UserProfile | null, error: any }> => {\n  const { data, error } = await supabase\n    .from('profiles')\n    .update({\n      ...profile,\n      updated_at: new Date().toISOString()\n    })\n    .eq('user_id', profile.user_id)\n    .select()\n    .single()\n  \n  return { data: data as UserProfile, error }\n}\n\nexport const uploadProfileImage = async (userId: string, file: File): Promise<{ url: string | null, error: any }> => {\n  const fileExt = file.name.split('.').pop()\n  const fileName = `${userId}-${Math.random().toString(36).substring(2)}.${fileExt}`\n  const filePath = `avatars/${fileName}`\n  \n  const { error: uploadError } = await supabase.storage\n    .from('profiles')\n    .upload(filePath, file)\n  \n  if (uploadError) {\n    return { url: null, error: uploadError }\n  }\n  \n  const { data } = supabase.storage.from('profiles').getPublicUrl(filePath)\n  \n  // Update profile with new avatar URL\n  await updateUserProfile({\n    user_id: userId,\n    avatar_url: data.publicUrl\n  })\n  \n  return { url: data.publicUrl, error: null }\n}\n```",
            "status": "pending",
            "testStrategy": "Test profile data fetching and updates with mock data. Verify image upload functionality with test files. Test form validation and error handling for profile updates."
          },
          {
            "id": 8,
            "title": "Implement Company/Tenant Isolation Logic",
            "description": "Create a multi-tenant system that isolates data by company, ensuring users can only access data from their own company.",
            "dependencies": [
              "3.3",
              "3.6"
            ],
            "details": "1. Design database schema with company_id foreign keys\n2. Create Row Level Security (RLS) policies in Supabase\n3. Implement company context and hooks for accessing company data\n4. Create middleware for enforcing tenant isolation\n5. Add company management interfaces for admins\n```typescript\n// hooks/useCompany.ts\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { useAuth } from './useAuth'\n\ninterface Company {\n  id: string\n  name: string\n  domain: string\n  logo_url?: string\n  settings?: Record<string, any>\n}\n\ntype CompanyContextType = {\n  company: Company | null\n  loading: boolean\n  error: any\n}\n\nconst CompanyContext = createContext<CompanyContextType | undefined>(undefined)\n\nexport const CompanyProvider = ({ children }) => {\n  const { user } = useAuth()\n  const [company, setCompany] = useState<Company | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<any>(null)\n  \n  useEffect(() => {\n    const fetchCompany = async () => {\n      if (!user) {\n        setCompany(null)\n        setLoading(false)\n        return\n      }\n      \n      try {\n        // First get the user's company_id from their profile\n        const { data: profileData, error: profileError } = await supabase\n          .from('profiles')\n          .select('company_id')\n          .eq('user_id', user.id)\n          .single()\n        \n        if (profileError) throw profileError\n        \n        if (profileData?.company_id) {\n          // Then fetch the company details\n          const { data: companyData, error: companyError } = await supabase\n            .from('companies')\n            .select('*')\n            .eq('id', profileData.company_id)\n            .single()\n          \n          if (companyError) throw companyError\n          \n          setCompany(companyData as Company)\n        }\n      } catch (err) {\n        console.error('Error fetching company:', err)\n        setError(err)\n      } finally {\n        setLoading(false)\n      }\n    }\n    \n    fetchCompany()\n  }, [user])\n  \n  return (\n    <CompanyContext.Provider value={{ company, loading, error }}>\n      {children}\n    </CompanyContext.Provider>\n  )\n}\n\nexport const useCompany = () => {\n  const context = useContext(CompanyContext)\n  if (context === undefined) {\n    throw new Error('useCompany must be used within a CompanyProvider')\n  }\n  return context\n}\n\n// middleware/withTenantIsolation.ts\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport { supabase } from '../lib/supabaseClient'\n\nexport const withTenantIsolation = (handler: any) => {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    // Get the authorization header\n    const authHeader = req.headers.authorization\n    \n    if (!authHeader) {\n      return res.status(401).json({ error: 'Missing authorization header' })\n    }\n    \n    // Extract the token\n    const token = authHeader.split(' ')[1]\n    \n    // Verify the token and get the user\n    const { data: { user }, error } = await supabase.auth.getUser(token)\n    \n    if (error || !user) {\n      return res.status(401).json({ error: 'Invalid or expired token' })\n    }\n    \n    // Get the user's company_id\n    const { data: profile } = await supabase\n      .from('profiles')\n      .select('company_id')\n      .eq('user_id', user.id)\n      .single()\n    \n    if (!profile?.company_id) {\n      return res.status(403).json({ error: 'User not associated with a company' })\n    }\n    \n    // Add company_id to the request context\n    req.companyId = profile.company_id\n    req.userId = user.id\n    \n    // Call the original handler\n    return handler(req, res)\n  }\n}\n```\n6. Create SQL for Row Level Security policies in Supabase:\n```sql\n-- Enable RLS on tables\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE companies ENABLE ROW LEVEL SECURITY;\nALTER TABLE advocates ENABLE ROW LEVEL SECURITY;\n\n-- Create policies for profiles table\nCREATE POLICY \"Users can view their own profile\"\n  ON profiles FOR SELECT\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own profile\"\n  ON profiles FOR UPDATE\n  USING (auth.uid() = user_id);\n\n-- Create policies for company-based isolation\nCREATE POLICY \"Users can view data from their company\"\n  ON advocates FOR SELECT\n  USING (\n    company_id IN (\n      SELECT company_id FROM profiles\n      WHERE user_id = auth.uid()\n    )\n  );\n\nCREATE POLICY \"Users can insert data for their company\"\n  ON advocates FOR INSERT\n  WITH CHECK (\n    company_id IN (\n      SELECT company_id FROM profiles\n      WHERE user_id = auth.uid()\n    )\n  );\n\nCREATE POLICY \"Users can update data for their company\"\n  ON advocates FOR UPDATE\n  USING (\n    company_id IN (\n      SELECT company_id FROM profiles\n      WHERE user_id = auth.uid()\n    )\n  );\n```",
            "status": "pending",
            "testStrategy": "Test tenant isolation by attempting to access data from different companies. Verify RLS policies work correctly with different user roles. Test company context with mock data for different scenarios."
          }
        ]
      },
      {
        "id": 4,
        "title": "Core UI Components and Layout System",
        "description": "Develop the core UI components and layout system that will be used throughout the application, ensuring mobile responsiveness and a consistent design language.",
        "details": "1. Create a design system with Tailwind CSS:\n```typescript\n// tailwind.config.js\nmodule.exports = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#f0f9ff',\n          // ... other shades\n          900: '#0c4a6e',\n        },\n        // Other color definitions\n      },\n      // Other theme extensions\n    },\n  },\n  plugins: [require('@tailwindcss/forms')],\n}\n```\n2. Implement layout components:\n   - MainLayout (with navigation, header, footer)\n   - DashboardLayout\n   - AuthLayout\n3. Create reusable UI components:\n   - Button (primary, secondary, tertiary variants)\n   - Input fields and form elements\n   - Card components\n   - Modal/dialog components\n   - Table components\n   - Navigation components\n   - Alert/notification components\n4. Implement responsive design patterns\n5. Create loading and error state components\n6. Implement dark/light mode support",
        "testStrategy": "Create Storybook stories for each component to visually test appearance and behavior. Write unit tests for component functionality. Test responsive behavior using viewport simulation. Verify accessibility compliance using automated tools.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Tailwind CSS Design System",
            "description": "Set up and configure Tailwind CSS with custom theme extensions for colors, typography, spacing, and other design tokens to establish a consistent design language.",
            "dependencies": [],
            "details": "1. Install Tailwind CSS and required dependencies\n2. Create tailwind.config.js with proper content paths\n3. Define custom color palette including primary, secondary, success, warning, error colors with appropriate shade variations\n4. Configure typography scales and font families\n5. Set up spacing and breakpoint systems\n6. Add required plugins like @tailwindcss/forms\n7. Create a theme.ts file to export type-safe theme constants",
            "status": "done",
            "testStrategy": "Verify custom classes are generated correctly by creating a simple test component that uses various theme values. Check compiled CSS output for expected values."
          },
          {
            "id": 2,
            "title": "Create Button Component System",
            "description": "Implement a comprehensive button component with variants (primary, secondary, tertiary), sizes, states (default, hover, focus, disabled), and loading state.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create components/ui/Button.tsx with appropriate props interface\n2. Implement size variants (sm, md, lg)\n3. Create style variants using Tailwind classes (primary, secondary, tertiary)\n4. Add support for icon-only and icon+text buttons\n5. Implement loading state with spinner\n6. Add disabled state styling\n7. Ensure proper focus states for accessibility\n8. Add proper aria attributes for accessibility",
            "status": "done",
            "testStrategy": "Create Storybook stories for each button variant and state. Write unit tests to verify prop handling and class application. Test keyboard accessibility."
          },
          {
            "id": 3,
            "title": "Implement Form Input Components",
            "description": "Create a set of form input components including text inputs, textareas, select dropdowns, checkboxes, radio buttons, and toggle switches with validation states.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create base Input component with validation states\n2. Implement TextArea component\n3. Create Select dropdown with options support\n4. Build Checkbox and Radio components\n5. Implement Toggle/Switch component\n6. Add support for labels, help text, and error messages\n7. Ensure all components handle disabled states\n8. Add proper aria attributes for accessibility\n<info added on 2025-09-10T01:31:29.523Z>\n**Implementation Plan:**\n1. Create comprehensive form input components following the existing design system patterns\n2. Components to implement:\n   - Input (text, email, password, number, etc.)\n   - Textarea\n   - Select dropdown\n   - Checkbox\n   - Radio button\n   - Toggle switch\n3. All components will include:\n   - Validation states (error, success, warning)\n   - Proper TypeScript interfaces\n   - Accessibility features\n   - Consistent styling with existing Button component\n   - Support for labels, help text, and error messages\n   - Dark mode support\n\n**Current Analysis:**\n- Tailwind CSS design system is properly configured with custom color palette\n- Button component uses class-variance-authority for variant management\n- Icons are available and well-structured\n- Utils include proper className merging with cn() function\n- @tailwindcss/forms plugin is configured for form styling\n\nStarting with Input component as the foundation for other form elements.\n</info added on 2025-09-10T01:31:29.523Z>\n<info added on 2025-09-10T01:34:42.945Z>\n**Implementation Complete!**\n\nSuccessfully implemented all form input components with comprehensive features:\n\n**Components Created:**\n1. **Input** - Text inputs with validation states, icons, and accessibility\n2. **Textarea** - Multi-line text input with character counting\n3. **Select** - Dropdown with search functionality and grouped options\n4. **Checkbox** - Checkbox with indeterminate state support\n5. **Radio** - Radio buttons with proper grouping\n6. **Toggle** - Switch/toggle component with smooth animations\n\n**Key Features Implemented:**\n- ✅ Validation states (error, success, warning) with visual indicators\n- ✅ Consistent styling using class-variance-authority\n- ✅ Full accessibility support (ARIA attributes, keyboard navigation)\n- ✅ Dark mode support throughout all components\n- ✅ TypeScript interfaces with proper type safety\n- ✅ Support for labels, help text, and error messages\n- ✅ Icon integration (left/right icons, validation icons)\n- ✅ Size variants (sm, md, lg) for all components\n- ✅ Disabled states and proper focus management\n- ✅ Character counting for textarea\n- ✅ Search functionality for select dropdown\n- ✅ Indeterminate state for checkboxes\n- ✅ Proper form integration and controlled/uncontrolled modes\n\n**Additional Work:**\n- ✅ Updated UI components index with all exports\n- ✅ Created comprehensive FormComponentsDemo showcasing all components\n- ✅ Integrated demo into existing ComponentsDemo\n- ✅ All components pass linting with no errors\n- ✅ Consistent with existing Button component patterns\n\n**Files Created/Modified:**\n- `/src/components/ui/Input.tsx` - Text input component\n- `/src/components/ui/Textarea.tsx` - Textarea component  \n- `/src/components/ui/Select.tsx` - Select dropdown component\n- `/src/components/ui/Checkbox.tsx` - Checkbox component\n- `/src/components/ui/Radio.tsx` - Radio button component\n- `/src/components/ui/Toggle.tsx` - Toggle/switch component\n- `/src/components/ui/index.ts` - Updated exports\n- `/src/components/FormComponentsDemo.tsx` - Comprehensive demo\n- `/src/components/ComponentsDemo.tsx` - Updated to include form demo\n</info added on 2025-09-10T01:34:42.945Z>\n<info added on 2025-09-10T01:44:34.426Z>\n**Testing Complete - All Components Working!**\n\n**Build Status:** ✅ Successful\n- All form components compile without errors\n- TypeScript types are properly configured\n- Prettier formatting applied\n- Next.js build passes successfully\n\n**Components Tested:**\n- ✅ Input component with validation states\n- ✅ Textarea component with character counting\n- ✅ Select component with search functionality\n- ✅ Checkbox component with indeterminate support\n- ✅ Radio component with proper grouping\n- ✅ Toggle component with smooth animations\n\n**Key Fixes Applied:**\n- Added 'use client' directives to all interactive components\n- Fixed TypeScript interface conflicts\n- Resolved Prettier formatting issues\n- Added missing MailIcon and LockIcon to icon library\n- Fixed ToggleProps onChange type compatibility\n\n**Demo Integration:**\n- FormComponentsDemo component created and integrated\n- ComponentsDemo updated to showcase form components\n- All components accessible via /components route\n\n**Ready for Production:** All form input components are fully functional and ready for use in the application.\n</info added on 2025-09-10T01:44:34.426Z>",
            "status": "done",
            "testStrategy": "Create Storybook stories for each input type and state. Test form validation integration. Verify keyboard navigation and screen reader accessibility."
          },
          {
            "id": 4,
            "title": "Build Card and Container Components",
            "description": "Create flexible card and container components with various style options for content grouping and layout organization.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create a base Card component with header, body, and footer sections\n2. Implement style variants (default, outlined, elevated)\n3. Add support for interactive cards (clickable, hoverable)\n4. Create specialized card types (stat cards, profile cards)\n5. Implement Container component for page section wrapping\n6. Add responsive padding and margin utilities",
            "status": "done",
            "testStrategy": "Create Storybook stories for different card configurations. Test responsive behavior at various breakpoints. Verify proper nesting of content."
          },
          {
            "id": 5,
            "title": "Develop Modal and Dialog Components",
            "description": "Create modal and dialog components for displaying content that requires user attention or interaction, with various sizes and configurations.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Implement Modal component with backdrop\n2. Create size variants (sm, md, lg, full)\n3. Add support for header, body, and footer sections\n4. Implement focus trapping for accessibility\n5. Add keyboard support (Escape to close)\n6. Create specialized dialog types (confirmation, alert)\n7. Implement animations for opening/closing\n8. Ensure proper stacking when multiple modals are open",
            "status": "pending",
            "testStrategy": "Test modal opening/closing with various triggers. Verify focus management and keyboard accessibility. Test screen reader announcements. Ensure body scroll locking works correctly."
          },
          {
            "id": 6,
            "title": "Create Table Components",
            "description": "Build a comprehensive table system with sorting, pagination, and responsive behavior for displaying structured data.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Create base Table component with header and body\n2. Implement column configuration system\n3. Add support for row selection\n4. Create sortable columns with indicators\n5. Implement pagination controls\n6. Add empty state handling\n7. Create mobile-responsive table alternatives (cards, lists)\n8. Add support for custom cell renderers",
            "status": "pending",
            "testStrategy": "Test table rendering with various data sets. Verify sorting functionality. Test pagination with different page sizes. Ensure responsive behavior works at mobile breakpoints."
          },
          {
            "id": 7,
            "title": "Implement Navigation Components",
            "description": "Create navigation components including navbar, sidebar, tabs, breadcrumbs, and pagination for application navigation.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Create Navbar component with responsive mobile menu\n2. Implement Sidebar with collapsible sections\n3. Build Tab component with horizontal and vertical variants\n4. Create Breadcrumb component\n5. Implement Pagination component\n6. Add active state styling for all navigation elements\n7. Ensure keyboard navigation support\n8. Create dropdown menu component for nested navigation",
            "status": "pending",
            "testStrategy": "Test navigation state management. Verify responsive behavior of navbar and sidebar. Test keyboard navigation through all components. Ensure proper ARIA roles and attributes."
          },
          {
            "id": 8,
            "title": "Build Alert and Notification Components",
            "description": "Create alert and notification components for displaying system messages, errors, warnings, and success states.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create Alert component with variants (info, success, warning, error)\n2. Implement dismissible alerts with animation\n3. Build Toast notification system\n4. Create inline notification component\n5. Add support for icons in alerts\n6. Implement auto-dismissing functionality for toasts\n7. Create toast container for managing multiple notifications\n8. Add support for actions within alerts\n<info added on 2025-09-10T02:04:29.050Z>\nSuccessfully implemented comprehensive alert and notification system:\n\n**Components Created:**\n1. **Alert Component** - Flexible alert with variants (default, info, success, warning, error), dismissible functionality, icons, actions, and multiple sizes\n2. **Toast Component** - Temporary notifications with auto-dismiss, manual dismissal, positioning, and animation support\n3. **ToastContainer Component** - Manages multiple toasts with positioning, stacking, and lifecycle management\n4. **InlineNotification Component** - Compact contextual notifications for forms and content areas\n5. **useToast Hook** - Custom hook for managing toast state with convenience functions\n\n**Key Features Implemented:**\n- ✅ All alert variants with proper styling and icons\n- ✅ Dismissible alerts with smooth animations\n- ✅ Toast notification system with auto-dismiss functionality\n- ✅ Toast container with positioning (top/bottom, left/center/right)\n- ✅ Inline notifications for contextual messaging\n- ✅ Icon support with default icons for each variant\n- ✅ Action buttons in alerts and toasts\n- ✅ Comprehensive demo showcasing all components\n- ✅ TypeScript support with proper typing\n- ✅ Accessibility features (ARIA labels, roles, live regions)\n- ✅ Dark mode support\n- ✅ Responsive design\n\n**Technical Implementation:**\n- Used class-variance-authority for consistent variant management\n- Implemented proper TypeScript interfaces and type safety\n- Added XIcon alias for CloseIcon to resolve import issues\n- Created comprehensive demo with real-world usage examples\n- Integrated with existing UI component system\n- All components compile successfully and pass build validation\n</info added on 2025-09-10T02:04:29.050Z>",
            "status": "done",
            "testStrategy": "Test alert rendering with different variants. Verify toast notification system with multiple simultaneous notifications. Test auto-dismiss functionality and manual dismissal."
          },
          {
            "id": 9,
            "title": "Implement Loading and Error State Components",
            "description": "Create components for handling loading states, empty states, and error states throughout the application.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create Spinner component with size variants\n2. Implement Skeleton loading components for various content types\n3. Build LoadingOverlay for blocking interactions\n4. Create EmptyState component with illustration support\n5. Implement ErrorState component for displaying errors\n6. Add retry functionality to error states\n7. Create inline loading indicators for buttons and forms\n<info added on 2025-09-10T03:10:40.963Z>\nImplementation completed with the following components:\n\n1. Spinner Component (Spinner.tsx)\n   - Size variants: xs, sm, md, lg, xl\n   - Color variants: default, secondary, success, warning, error, white, gray\n   - Accessibility support with aria-labels\n   - Smooth CSS animations\n\n2. Skeleton Loading Components (Skeleton.tsx)\n   - Base Skeleton component with variants\n   - Specialized components: SkeletonText, SkeletonAvatar, SkeletonButton, SkeletonCard, SkeletonTable, SkeletonList\n   - Configurable lines, sizes, and layouts\n   - Pulse animation for loading states\n\n3. Loading Overlay Components (LoadingOverlay.tsx)\n   - Variants: default, transparent, blur, solid\n   - FullScreenLoadingOverlay for full-page loading\n   - ContainerLoadingOverlay for relative positioned containers\n   - Dismissible functionality with onDismiss callback\n   - Customizable spinner size and variant\n\n4. Empty State Component (EmptyState.tsx)\n   - Size variants: sm, md, lg\n   - Built-in illustrations for common scenarios\n   - Action and secondary action buttons\n   - Custom illustration support\n   - Responsive design\n\n5. Error State Components (ErrorState.tsx)\n   - Main ErrorState with retry functionality\n   - InlineErrorState for forms and smaller areas\n   - FullScreenErrorState for application-level errors\n   - Error details with expand/collapse\n   - Dismissible functionality\n   - Error code display\n\n6. Interactive Loading Components\n   - LoadingButton with built-in loading state and spinner\n   - LoadingInput with loading spinner (left/right positioning)\n\n7. Demo Component (LoadingErrorDemo.tsx)\n   - Comprehensive showcase of all components\n   - Interactive examples with state management\n   - Usage patterns and best practices\n\nAll components feature TypeScript support, CVA styling, accessibility compliance, dark mode support, responsive design, and proper integration with existing UI components.\n</info added on 2025-09-10T03:10:40.963Z>",
            "status": "done",
            "testStrategy": "Test loading state transitions. Verify skeleton loading appearance. Test error state recovery flows. Ensure loading states are accessible to screen readers."
          },
          {
            "id": 10,
            "title": "Create MainLayout Component",
            "description": "Implement the main application layout with header, navigation, content area, and footer, supporting responsive behavior.",
            "dependencies": [
              "4.1",
              "4.7"
            ],
            "details": "1. Create components/layouts/MainLayout.tsx\n2. Implement responsive header with navigation\n3. Add sidebar navigation with collapsible functionality\n4. Create main content area with proper padding\n5. Implement footer with configurable content\n6. Add responsive breakpoints for mobile/tablet/desktop\n7. Implement navigation state management (open/closed sidebar)\n8. Create smooth transitions for layout changes",
            "status": "pending",
            "testStrategy": "Test layout rendering at various screen sizes. Verify sidebar collapse/expand functionality. Test navigation state persistence. Ensure content area properly adapts to navigation states."
          },
          {
            "id": 11,
            "title": "Implement DashboardLayout Component",
            "description": "Create a specialized layout for dashboard pages with support for header, sidebar, and configurable content areas.",
            "dependencies": [
              "4.1",
              "4.10"
            ],
            "details": "1. Create components/layouts/DashboardLayout.tsx extending MainLayout\n2. Implement dashboard header with actions area\n3. Add support for dashboard sidebar with filters\n4. Create grid layout for dashboard widgets\n5. Implement responsive behavior for dashboard components\n6. Add support for fullscreen dashboard mode\n7. Create dashboard widget container component",
            "status": "pending",
            "testStrategy": "Test dashboard layout with various widget configurations. Verify responsive behavior of widget grid. Test filter sidebar functionality. Ensure proper spacing and alignment of dashboard elements."
          },
          {
            "id": 12,
            "title": "Build AuthLayout Component",
            "description": "Create a layout for authentication pages with centered content, branding, and responsive behavior.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create components/layouts/AuthLayout.tsx\n2. Implement centered card container for auth forms\n3. Add branding area with logo\n4. Create background styling options\n5. Implement responsive behavior for mobile devices\n6. Add support for additional information sections\n7. Create navigation for auth flows (login, register, forgot password)",
            "status": "pending",
            "testStrategy": "Test auth layout rendering at various screen sizes. Verify proper centering and spacing of auth forms. Test navigation between different auth pages."
          },
          {
            "id": 13,
            "title": "Implement Responsive Design Utilities",
            "description": "Create utility components and hooks for managing responsive behavior across the application.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create useMediaQuery hook for responsive logic\n2. Implement ResponsiveContainer component\n3. Create responsive visibility utilities (HideOnMobile, ShowOnDesktop)\n4. Add responsive spacing utilities\n5. Implement responsive typography scaling\n6. Create responsive grid system utilities\n7. Add documentation for responsive design patterns",
            "status": "pending",
            "testStrategy": "Test media query hook with various breakpoints. Verify responsive container behavior. Test visibility utilities at different screen sizes."
          },
          {
            "id": 14,
            "title": "Implement Dark/Light Mode Support",
            "description": "Add support for dark and light mode themes with user preference detection and manual toggle.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Configure Tailwind for dark mode support\n2. Create ThemeProvider context for theme state management\n3. Implement useTheme hook for accessing theme state\n4. Add system preference detection\n5. Create theme toggle component\n6. Implement theme persistence in local storage\n7. Add smooth transition between themes\n8. Update all components to support both themes",
            "status": "pending",
            "testStrategy": "Test theme switching functionality. Verify system preference detection. Test theme persistence across page reloads. Ensure all components render correctly in both themes."
          }
        ]
      },
      {
        "id": 5,
        "title": "Company and User Management Interfaces",
        "description": "Build the administrative interfaces for managing companies (tenants) and users, including creation, editing, and role assignment.",
        "details": "1. Create company management pages:\n   - Company list view\n   - Company creation form\n   - Company details/edit view\n   - Company settings page\n2. Implement user management interfaces:\n   - User list with filtering and search\n   - User creation/invitation form\n   - User role assignment\n   - User profile editing\n3. Implement the data fetching logic:\n```typescript\n// Example user fetching hook\nexport const useUsers = (companyId: string) => {\n  const [users, setUsers] = useState<User[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const fetchUsers = async () => {\n      try {\n        setLoading(true)\n        const { data, error } = await supabase\n          .from('users')\n          .select('*')\n          .eq('company_id', companyId)\n        \n        if (error) throw error\n        setUsers(data || [])\n      } catch (err) {\n        setError(err as Error)\n      } finally {\n        setLoading(false)\n      }\n    }\n    \n    fetchUsers()\n  }, [companyId])\n\n  return { users, loading, error }\n}\n```\n4. Create form validation logic\n5. Implement role-based access control UI\n6. Add bulk user import functionality",
        "testStrategy": "Test CRUD operations for companies and users with different permission levels. Verify form validation for required fields and data formats. Test bulk import functionality with various data formats. Ensure proper error handling and user feedback.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Company List View Component",
            "description": "Implement the company list view component that displays all companies with pagination, sorting, and basic filtering capabilities.",
            "dependencies": [],
            "details": "Create a React component for the company list view. Use a table or card layout to display company information including name, status, number of users, and creation date. Implement pagination with limit/offset pattern. Add sorting functionality for relevant columns. Include a search bar for filtering companies by name. Use the Supabase client to fetch company data with proper error handling and loading states.",
            "status": "pending",
            "testStrategy": "Test rendering with mock data. Verify pagination controls work correctly. Test sorting functionality for each column. Ensure search filtering returns correct results."
          },
          {
            "id": 2,
            "title": "Implement Company Data Fetching Hook",
            "description": "Create a custom React hook for fetching and managing company data from the Supabase backend.",
            "dependencies": [],
            "details": "Implement a useCompanies hook similar to the provided useUsers example. The hook should handle fetching companies with pagination, sorting, and filtering parameters. Include state management for loading, error handling, and the companies array. Add functions for refreshing data and handling pagination changes. Implement proper TypeScript interfaces for company data structure.",
            "status": "pending",
            "testStrategy": "Test hook behavior with mock Supabase responses. Verify error handling works correctly. Test pagination parameter changes. Ensure proper state management during loading and after data is fetched."
          },
          {
            "id": 3,
            "title": "Build Company Creation Form",
            "description": "Create a form component for adding new companies with validation and submission handling.",
            "dependencies": [
              "5.2"
            ],
            "details": "Implement a form component with fields for company name, description, industry, size, and other relevant details. Use a form library like Formik or React Hook Form for state management and validation. Add client-side validation for required fields and data formats. Implement submission handling that uses the Supabase client to create new company records. Include success and error notifications for user feedback.",
            "status": "pending",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify submission handling with mock API responses. Test error scenarios and ensure proper user feedback. Verify form reset functionality after successful submission."
          },
          {
            "id": 4,
            "title": "Develop Company Details/Edit View",
            "description": "Create a detailed view for individual companies with the ability to edit company information.",
            "dependencies": [
              "5.2"
            ],
            "details": "Implement a company details page that displays comprehensive information about a selected company. Create an edit mode that transforms the view into an editable form. Reuse validation logic from the company creation form. Implement save functionality that updates the company record in Supabase. Add confirmation dialogs for important changes. Include a section showing basic usage statistics and user counts.",
            "status": "pending",
            "testStrategy": "Test view/edit mode toggle functionality. Verify form validation in edit mode. Test update functionality with mock API responses. Ensure proper handling of concurrent edit scenarios."
          },
          {
            "id": 5,
            "title": "Create Company Settings Page",
            "description": "Implement a settings page for company-specific configurations including branding, integrations, and preferences.",
            "dependencies": [
              "5.4"
            ],
            "details": "Build a settings page with tabs or sections for different configuration categories. Include branding settings (logo, colors, custom domain), notification preferences, integration settings, and security options. Implement save functionality for each section that updates the appropriate records in Supabase. Add validation for settings fields where appropriate. Include a reset to defaults option for each section.",
            "status": "pending",
            "testStrategy": "Test settings persistence across page reloads. Verify validation for each settings field. Test the reset to defaults functionality. Ensure proper error handling and user feedback for settings updates."
          },
          {
            "id": 6,
            "title": "Implement User List Component with Filtering",
            "description": "Create a user list view with advanced filtering, search, and pagination capabilities.",
            "dependencies": [],
            "details": "Implement a user list component that displays users with relevant information (name, email, role, status). Add filtering capabilities for role, status, and other attributes. Implement a search function that filters by name or email. Add pagination controls with configurable page size. Include sorting functionality for relevant columns. Use the provided useUsers hook for data fetching and state management.",
            "status": "pending",
            "testStrategy": "Test rendering with various data sets. Verify filter combinations work correctly. Test search functionality with partial matches. Ensure pagination works with different filter combinations."
          },
          {
            "id": 7,
            "title": "Enhance User Data Fetching Hook",
            "description": "Extend the provided useUsers hook with additional functionality for filtering, pagination, and data management.",
            "dependencies": [],
            "details": "Enhance the provided useUsers hook to support pagination, filtering, and sorting parameters. Add functions for refreshing data, changing pagination, and applying filters. Implement proper TypeScript interfaces for user data structure. Add functionality for handling user status changes and role updates. Optimize the hook to minimize unnecessary re-fetches.",
            "status": "pending",
            "testStrategy": "Test hook behavior with different parameter combinations. Verify error handling for various error scenarios. Test pagination and filtering logic. Ensure proper state management during loading and after data is fetched."
          },
          {
            "id": 8,
            "title": "Create User Creation and Invitation Form",
            "description": "Implement a form for creating new users and sending invitations to join the platform.",
            "dependencies": [
              "5.7"
            ],
            "details": "Build a form component for adding new users with fields for name, email, role, and other relevant information. Implement an invitation flow that sends emails to new users. Add validation for email format and required fields. Create a preview of the invitation email. Implement submission handling that creates user records in Supabase and triggers invitation emails. Add success and error notifications for user feedback.",
            "status": "pending",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify email invitation flow with mock email service. Test error scenarios and ensure proper user feedback. Verify duplicate email handling."
          },
          {
            "id": 9,
            "title": "Implement User Role Assignment Interface",
            "description": "Create an interface for assigning and managing user roles with appropriate permissions.",
            "dependencies": [
              "5.7"
            ],
            "details": "Implement a role assignment interface that allows administrators to change user roles. Display available roles with descriptions of their permissions. Add confirmation dialogs for role changes that affect permissions. Implement the backend logic for updating user roles in Supabase. Include a visual indicator of the current user's role. Add validation to prevent removing all admin users.",
            "status": "pending",
            "testStrategy": "Test role assignment with different user types. Verify permission changes take effect immediately. Test validation logic for preventing removal of all admins. Ensure proper error handling and user feedback."
          },
          {
            "id": 10,
            "title": "Build User Profile Editing Component",
            "description": "Create a component for users to view and edit their profile information.",
            "dependencies": [
              "5.7"
            ],
            "details": "Implement a user profile component that displays user information and allows editing. Include fields for name, contact information, preferences, and profile picture. Add validation for required fields and data formats. Implement image upload functionality for profile pictures. Create save functionality that updates user records in Supabase. Add success and error notifications for user feedback.",
            "status": "pending",
            "testStrategy": "Test profile editing with valid and invalid inputs. Verify image upload functionality. Test error scenarios and ensure proper user feedback. Verify changes persist after page reload."
          },
          {
            "id": 11,
            "title": "Implement Form Validation Logic",
            "description": "Create reusable validation logic for company and user forms to ensure data integrity.",
            "dependencies": [],
            "details": "Implement a validation utility that can be used across company and user forms. Create validation rules for common fields like email, phone numbers, and required fields. Add custom validation for business-specific rules. Implement real-time validation feedback. Create helper functions for displaying validation errors in form components. Ensure validation logic is consistent across all forms.",
            "status": "pending",
            "testStrategy": "Test validation rules with various input combinations. Verify error messages are clear and helpful. Test validation timing (on blur, on submit, etc.). Ensure validation logic handles edge cases correctly."
          },
          {
            "id": 12,
            "title": "Develop Role-Based Access Control UI",
            "description": "Implement the user interface components for managing role-based access control across the application.",
            "dependencies": [
              "5.9"
            ],
            "details": "Create an interface for defining and managing roles and their permissions. Implement a matrix view showing roles and their associated permissions. Add functionality to create, edit, and delete custom roles. Implement permission inheritance and override capabilities. Create a preview mode to see the application from different role perspectives. Add validation to prevent creating roles with conflicting permissions.",
            "status": "pending",
            "testStrategy": "Test role creation and editing functionality. Verify permission changes are reflected in the UI. Test role deletion with users assigned to that role. Ensure proper error handling and validation for role management."
          },
          {
            "id": 13,
            "title": "Create Bulk User Import Functionality",
            "description": "Implement functionality for importing multiple users at once via CSV or Excel file upload.",
            "dependencies": [
              "5.8"
            ],
            "details": "Create a file upload component that accepts CSV or Excel files. Implement parsing logic for extracting user data from uploaded files. Add validation for file format and required user fields. Create a preview interface showing parsed data before import. Implement batch processing for creating multiple user records. Add error handling for partial successes. Create a downloadable template file for users to fill in.",
            "status": "pending",
            "testStrategy": "Test file upload with various file formats and sizes. Verify parsing logic handles different CSV formats correctly. Test validation of imported data. Ensure proper error handling for malformed files and invalid data."
          },
          {
            "id": 14,
            "title": "Implement Navigation and Layout for Management Interfaces",
            "description": "Create the navigation structure and page layouts for company and user management interfaces.",
            "dependencies": [],
            "details": "Implement a navigation sidebar or header for accessing company and user management pages. Create consistent page layouts with appropriate spacing and responsive design. Add breadcrumbs for navigation context. Implement tab navigation for multi-section pages. Ensure proper routing between management interfaces. Add loading states and error boundaries for each page.",
            "status": "pending",
            "testStrategy": "Test navigation flow between different management pages. Verify responsive behavior on different screen sizes. Test loading states and error boundaries. Ensure consistent styling across all management interfaces."
          },
          {
            "id": 15,
            "title": "Add Permission-Based UI Rendering",
            "description": "Implement logic to conditionally render UI elements based on user permissions and roles.",
            "dependencies": [
              "5.12"
            ],
            "details": "Create a permission checking utility that determines if a user can access specific features. Implement conditional rendering for UI elements based on user permissions. Add redirect logic for unauthorized access attempts. Create fallback UI for users with limited permissions. Implement permission-based navigation that only shows accessible options. Add tooltips explaining why certain features are unavailable.",
            "status": "pending",
            "testStrategy": "Test UI rendering with different user roles. Verify unauthorized access attempts are properly handled. Test navigation visibility with different permission sets. Ensure proper fallback UI for limited permissions."
          }
        ]
      },
      {
        "id": 6,
        "title": "Advocate Management System",
        "description": "Develop the advocate management system for creating, editing, and managing customer advocates, including availability settings and fatigue prevention.",
        "details": "1. Create advocate management interfaces:\n   - Advocate list view with filtering and search\n   - Advocate creation and editing forms\n   - Advocate profile view\n   - Availability management interface\n2. Implement advocate data models and services:\n```typescript\n// types/advocate.ts\nexport interface Advocate {\n  id: string\n  user_id: string\n  company_id: string\n  name: string\n  title: string\n  company_name: string\n  industry: string\n  company_size: string\n  use_cases: string[]\n  geographic_region: string\n  expertise_areas: string[]\n  availability_score: number\n  total_calls_completed: number\n  last_call_date: string | null\n  max_calls_per_month: number\n  status: 'active' | 'inactive' | 'pending'\n  created_at: string\n  updated_at: string\n}\n\n// services/advocateService.ts\nexport const createAdvocate = async (advocateData: Omit<Advocate, 'id' | 'created_at' | 'updated_at'>) => {\n  const { data, error } = await supabase\n    .from('advocates')\n    .insert(advocateData)\n    .select()\n  \n  if (error) throw error\n  return data[0]\n}\n```\n3. Implement fatigue prevention system:\n   - Track advocate participation frequency\n   - Calculate and update availability scores\n   - Implement cooling-off periods\n   - Create notification system for advocate status changes\n4. Build advocate invitation and onboarding flow\n5. Create advocate availability calendar management",
        "testStrategy": "Test CRUD operations for advocates. Verify fatigue prevention logic with simulated call history. Test availability calculation with various scenarios. Ensure advocate invitation flow works correctly. Verify calendar integration for availability management.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Advocate Data Models and Types",
            "description": "Define the TypeScript interfaces and types for the advocate management system, including the main Advocate interface and related types.",
            "dependencies": [],
            "details": "Create the necessary TypeScript interfaces in the types directory. Start with the Advocate interface as provided in the task description. Add additional types for advocate availability, status tracking, and filtering options. Ensure all properties have appropriate types and documentation.",
            "status": "pending",
            "testStrategy": "Verify type definitions with TypeScript compiler. Create sample objects to ensure they conform to the defined interfaces."
          },
          {
            "id": 2,
            "title": "Implement Advocate Service CRUD Operations",
            "description": "Create the advocate service with CRUD operations for managing advocate data in the Supabase database.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement the advocate service with functions for creating, reading, updating, and deleting advocate records. Use the Supabase client for database operations. Include error handling and return appropriate responses. Implement the createAdvocate function as provided in the task description, and add getAdvocate, updateAdvocate, deleteAdvocate, and listAdvocates functions.",
            "status": "pending",
            "testStrategy": "Test each CRUD operation with mock data. Verify error handling for database failures. Test filtering and pagination for list operations."
          },
          {
            "id": 3,
            "title": "Build Advocate List View Component",
            "description": "Create the advocate list view component with filtering, sorting, and search functionality.",
            "dependencies": [
              "6.2"
            ],
            "details": "Implement a responsive list view component for advocates. Include search functionality that filters by name, company, and expertise areas. Add filtering options for status, industry, and availability. Implement sorting by various fields. Use pagination for efficient loading of large datasets. Include status indicators for advocate availability.",
            "status": "pending",
            "testStrategy": "Test search and filtering functionality with various inputs. Verify pagination works correctly. Test responsive layout on different screen sizes."
          },
          {
            "id": 4,
            "title": "Create Advocate Profile View Component",
            "description": "Implement the advocate profile view component that displays detailed information about an advocate.",
            "dependencies": [
              "6.2"
            ],
            "details": "Create a detailed profile view component that displays all advocate information. Include sections for personal details, company information, expertise areas, availability status, and call history. Add visual indicators for availability score and status. Implement navigation between the list view and profile view.",
            "status": "pending",
            "testStrategy": "Test profile view with various advocate data scenarios. Verify all information displays correctly. Test navigation between views."
          },
          {
            "id": 5,
            "title": "Implement Advocate Creation Form",
            "description": "Build the form component for creating new advocates in the system.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Create a multi-step form for advocate creation. Include fields for all required advocate properties. Implement form validation for required fields and data formats. Add support for selecting multiple expertise areas and use cases. Integrate with the advocate service to submit the form data. Provide appropriate feedback on success or failure.",
            "status": "pending",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify form submission works correctly. Test multi-step navigation. Ensure error messages are displayed appropriately."
          },
          {
            "id": 6,
            "title": "Implement Advocate Editing Form",
            "description": "Create the form component for editing existing advocate information.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.5"
            ],
            "details": "Adapt the advocate creation form for editing existing advocates. Pre-populate the form with current advocate data. Implement partial updates to avoid overwriting unchanged fields. Add confirmation for status changes. Include audit tracking for changes.",
            "status": "pending",
            "testStrategy": "Test form pre-population with existing data. Verify partial updates work correctly. Test confirmation dialogs for status changes."
          },
          {
            "id": 7,
            "title": "Develop Advocate Availability Management Interface",
            "description": "Create the interface for managing advocate availability settings, including calendar integration and time preferences.",
            "dependencies": [
              "6.2",
              "6.4"
            ],
            "details": "Implement an availability management interface that allows advocates to set their preferred call times. Include calendar integration for blocking out unavailable times. Add recurring availability patterns (e.g., available every Tuesday morning). Implement time zone handling for global availability. Create visual calendar view for availability settings.",
            "status": "pending",
            "testStrategy": "Test calendar integration with various availability patterns. Verify time zone handling works correctly. Test recurring availability settings."
          },
          {
            "id": 8,
            "title": "Implement Fatigue Prevention System Core Logic",
            "description": "Develop the core logic for the fatigue prevention system that tracks advocate participation and prevents overuse.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Create a service that tracks advocate participation frequency. Implement logic to calculate and update availability scores based on recent activity. Define cooling-off periods based on call frequency. Create functions to determine if an advocate is available for a new call based on their history and preferences.",
            "status": "pending",
            "testStrategy": "Test availability calculation with various call history scenarios. Verify cooling-off periods are enforced correctly. Test edge cases like advocates with no prior calls."
          },
          {
            "id": 9,
            "title": "Build Advocate Status Notification System",
            "description": "Implement the notification system for advocate status changes and availability updates.",
            "dependencies": [
              "6.8"
            ],
            "details": "Create a notification service that monitors advocate status changes. Implement email notifications for status changes (active, inactive, cooling-off). Add in-app notifications for upcoming calls and availability changes. Create notification preferences for advocates and administrators.",
            "status": "pending",
            "testStrategy": "Test notification generation for various status changes. Verify email delivery with mock email service. Test notification preferences and opt-out functionality."
          },
          {
            "id": 10,
            "title": "Develop Advocate Invitation and Onboarding Flow",
            "description": "Create the workflow for inviting new advocates to the platform and guiding them through the onboarding process.",
            "dependencies": [
              "6.2",
              "6.5"
            ],
            "details": "Implement an invitation system that sends email invitations to potential advocates. Create a secure registration flow for invited advocates. Build an onboarding wizard that guides new advocates through profile completion, availability settings, and system introduction. Add admin interfaces for tracking invitation status and onboarding progress.",
            "status": "pending",
            "testStrategy": "Test invitation sending and tracking. Verify secure registration links work correctly. Test the onboarding wizard with various completion scenarios."
          },
          {
            "id": 11,
            "title": "Implement Advocate Analytics Dashboard",
            "description": "Create an analytics dashboard for monitoring advocate performance, availability, and engagement metrics.",
            "dependencies": [
              "6.2",
              "6.8"
            ],
            "details": "Build an analytics dashboard that displays key metrics for advocates. Include visualizations for call frequency, feedback scores, and availability trends. Add filtering by time period, advocate attributes, and performance metrics. Implement export functionality for reports.",
            "status": "pending",
            "testStrategy": "Test dashboard with various data scenarios. Verify visualizations render correctly. Test filtering and export functionality."
          },
          {
            "id": 12,
            "title": "Integrate Advocate Management with User Authentication",
            "description": "Integrate the advocate management system with the authentication system to enforce proper access controls.",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Integrate the advocate management interfaces with the authentication system. Implement role-based access controls for different user types (admins, advocates, sales reps). Add company-based tenant isolation to ensure advocates are only visible to appropriate users. Modify service calls to include authentication tokens and permission checks.",
            "status": "pending",
            "testStrategy": "Test access controls with different user roles. Verify tenant isolation prevents cross-company data access. Test authentication token handling and expiration."
          }
        ]
      },
      {
        "id": 7,
        "title": "Opportunity Management and CRM Integration",
        "description": "Implement the opportunity management system and integrate with CRM systems (Salesforce and HubSpot) to sync opportunity data and activity logging.",
        "details": "1. Create opportunity data models and interfaces:\n   - Opportunity list view\n   - Opportunity details view\n   - Opportunity creation/edit forms\n2. Implement Salesforce integration:\n   - OAuth authentication flow\n   - Data synchronization for opportunities\n   - Activity logging\n   - Custom fields for reference tracking\n```typescript\n// services/salesforceService.ts\nexport const connectSalesforce = async (companyId: string, authCode: string) => {\n  // Exchange auth code for tokens\n  // Store connection details in database\n}\n\nexport const syncOpportunities = async (companyId: string) => {\n  // Fetch opportunities from Salesforce\n  // Sync with local database\n}\n\nexport const logReferenceActivity = async (opportunityId: string, callId: string, notes: string) => {\n  // Log reference call activity in Salesforce\n}\n```\n3. Implement HubSpot integration (similar pattern to Salesforce)\n4. Create bidirectional sync mechanism\n5. Implement webhook handlers for CRM updates\n6. Build embedded widget components for CRM systems\n7. Create reporting integration for CRM dashboards",
        "testStrategy": "Test CRM authentication flows with mock OAuth servers. Verify bidirectional sync with test CRM instances. Test activity logging with various call scenarios. Ensure error handling for API failures. Verify webhook handlers correctly process CRM updates.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create opportunity data models and database schema",
            "description": "Define and implement the database schema for opportunities, including relationships to companies, users, and advocates.",
            "dependencies": [],
            "details": "Create SQL migration for opportunities table with fields for name, stage, value, company_id, owner_id, etc. Implement TypeScript interfaces for opportunity data models. Set up Row Level Security policies to ensure proper data isolation between tenants. Include status tracking fields and timestamps for synchronization with CRM systems.",
            "status": "pending",
            "testStrategy": "Write SQL queries to test the schema integrity and relationships. Verify RLS policies by attempting cross-tenant data access."
          },
          {
            "id": 2,
            "title": "Implement opportunity list view component",
            "description": "Create a component to display a list of opportunities with filtering, sorting, and pagination capabilities.",
            "dependencies": [
              "7.1"
            ],
            "details": "Build a React component for displaying opportunities in a table/list format. Implement filters for opportunity stage, value range, and creation date. Add sorting functionality for columns. Implement pagination for large datasets. Include search functionality to filter by opportunity name or details.",
            "status": "pending",
            "testStrategy": "Test rendering with various data sets. Verify filtering and sorting functionality. Test pagination with large data sets. Ensure responsive design works on different screen sizes."
          },
          {
            "id": 3,
            "title": "Implement opportunity details view component",
            "description": "Create a component to display detailed information about a single opportunity, including related activities and reference calls.",
            "dependencies": [
              "7.1"
            ],
            "details": "Build a React component for displaying comprehensive opportunity details. Include sections for basic info, related contacts, activity history, and reference calls. Implement tabs for organizing different types of information. Add edit functionality with proper permission checks.",
            "status": "pending",
            "testStrategy": "Test rendering with various opportunity states. Verify all data is displayed correctly. Test tab navigation and content loading."
          },
          {
            "id": 4,
            "title": "Create opportunity creation and edit forms",
            "description": "Implement forms for creating new opportunities and editing existing ones with validation.",
            "dependencies": [
              "7.1"
            ],
            "details": "Build React form components using Formik or React Hook Form. Implement validation for required fields and data formats. Create form sections for different categories of information. Add functionality to save drafts before submission. Implement error handling and success notifications.",
            "status": "pending",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify form submission and error handling. Test draft saving functionality."
          },
          {
            "id": 5,
            "title": "Implement Salesforce OAuth authentication flow",
            "description": "Create the authentication flow for connecting to Salesforce, including OAuth token exchange and storage.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the OAuth 2.0 flow for Salesforce authentication. Create API endpoints for initiating auth, handling callbacks, and token refresh. Store encrypted tokens securely in the database. Implement token refresh logic to handle expiring access tokens. Add UI components for connection status and reconnection.",
            "status": "pending",
            "testStrategy": "Test OAuth flow with mock Salesforce endpoints. Verify token storage and encryption. Test token refresh logic with expired tokens."
          },
          {
            "id": 6,
            "title": "Implement Salesforce data synchronization for opportunities",
            "description": "Create services to sync opportunity data between the application and Salesforce.",
            "dependencies": [
              "7.1",
              "7.5"
            ],
            "details": "Implement bidirectional sync between local database and Salesforce. Create mapping logic for field transformations between systems. Handle conflict resolution for simultaneous updates. Implement batch processing for large datasets. Add logging for sync operations and errors.",
            "status": "pending",
            "testStrategy": "Test sync with mock Salesforce API responses. Verify conflict resolution with simultaneous updates. Test error handling with API failures."
          },
          {
            "id": 7,
            "title": "Implement Salesforce activity logging",
            "description": "Create services to log reference call activities and other events to Salesforce.",
            "dependencies": [
              "7.5",
              "7.6"
            ],
            "details": "Implement activity logging for reference calls, including call outcomes, notes, and follow-ups. Create mapping between internal activity types and Salesforce activity types. Add support for custom fields in Salesforce activities. Implement queuing system for failed log attempts.",
            "status": "pending",
            "testStrategy": "Test activity logging with various call scenarios. Verify custom field mapping. Test retry logic for failed API calls."
          },
          {
            "id": 8,
            "title": "Implement HubSpot OAuth authentication flow",
            "description": "Create the authentication flow for connecting to HubSpot, including OAuth token exchange and storage.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the OAuth 2.0 flow for HubSpot authentication. Create API endpoints for initiating auth, handling callbacks, and token refresh. Store encrypted tokens securely in the database. Implement token refresh logic to handle expiring access tokens. Add UI components for connection status and reconnection.",
            "status": "pending",
            "testStrategy": "Test OAuth flow with mock HubSpot endpoints. Verify token storage and encryption. Test token refresh logic with expired tokens."
          },
          {
            "id": 9,
            "title": "Implement HubSpot data synchronization for opportunities",
            "description": "Create services to sync opportunity data between the application and HubSpot.",
            "dependencies": [
              "7.1",
              "7.8"
            ],
            "details": "Implement bidirectional sync between local database and HubSpot. Create mapping logic for field transformations between systems. Handle conflict resolution for simultaneous updates. Implement batch processing for large datasets. Add logging for sync operations and errors.",
            "status": "pending",
            "testStrategy": "Test sync with mock HubSpot API responses. Verify conflict resolution with simultaneous updates. Test error handling with API failures."
          },
          {
            "id": 10,
            "title": "Implement HubSpot activity logging",
            "description": "Create services to log reference call activities and other events to HubSpot.",
            "dependencies": [
              "7.8",
              "7.9"
            ],
            "details": "Implement activity logging for reference calls, including call outcomes, notes, and follow-ups. Create mapping between internal activity types and HubSpot activity types. Add support for custom properties in HubSpot activities. Implement queuing system for failed log attempts.",
            "status": "pending",
            "testStrategy": "Test activity logging with various call scenarios. Verify custom property mapping. Test retry logic for failed API calls."
          },
          {
            "id": 11,
            "title": "Create CRM webhook handlers for real-time updates",
            "description": "Implement webhook handlers to receive and process real-time updates from Salesforce and HubSpot.",
            "dependencies": [
              "7.6",
              "7.9"
            ],
            "details": "Create API endpoints to receive webhook notifications from CRM systems. Implement signature verification for webhook security. Process incoming data and update local database accordingly. Handle different event types (create, update, delete). Add monitoring and alerting for webhook failures.",
            "status": "pending",
            "testStrategy": "Test webhook handlers with sample payloads from both CRMs. Verify signature validation logic. Test handling of different event types. Ensure proper error handling for malformed requests."
          },
          {
            "id": 12,
            "title": "Implement CRM connection management UI",
            "description": "Create user interface components for managing CRM connections, including setup, status, and troubleshooting.",
            "dependencies": [
              "7.5",
              "7.8"
            ],
            "details": "Build React components for CRM connection management. Implement connection status indicators. Create setup wizards for new connections. Add troubleshooting tools for connection issues. Implement permission controls for CRM management features.",
            "status": "pending",
            "testStrategy": "Test UI rendering in different connection states. Verify setup wizard flow. Test error handling and display of troubleshooting information."
          },
          {
            "id": 13,
            "title": "Build embedded widget components for CRM systems",
            "description": "Create embeddable widgets that can be integrated into Salesforce and HubSpot interfaces.",
            "dependencies": [
              "7.6",
              "7.9"
            ],
            "details": "Develop embeddable JavaScript widgets for CRM systems. Create authentication mechanism for embedded contexts. Implement UI components that match CRM visual styles. Add functionality to view and schedule reference calls directly from CRM. Create documentation for widget installation.",
            "status": "pending",
            "testStrategy": "Test widget loading in mock CRM environments. Verify authentication in embedded context. Test responsive design within CRM layouts."
          },
          {
            "id": 14,
            "title": "Implement reporting integration for CRM dashboards",
            "description": "Create integration points for exposing reference call metrics and data in CRM reporting dashboards.",
            "dependencies": [
              "7.6",
              "7.9",
              "7.7",
              "7.10"
            ],
            "details": "Implement data endpoints for CRM reporting tools. Create pre-built report templates for common metrics. Develop custom objects/entities in CRMs for advanced reporting. Add scheduled data exports for offline reporting. Implement proper access controls for sensitive metrics.",
            "status": "pending",
            "testStrategy": "Test data endpoint responses with various query parameters. Verify report template generation. Test scheduled export functionality."
          },
          {
            "id": 15,
            "title": "Create unified CRM service abstraction layer",
            "description": "Implement a unified service layer that abstracts away differences between CRM systems.",
            "dependencies": [
              "7.6",
              "7.7",
              "7.9",
              "7.10"
            ],
            "details": "Create a unified CRM service interface that works with multiple CRM providers. Implement provider-specific adapters for Salesforce and HubSpot. Add factory pattern for selecting the appropriate provider. Create comprehensive error handling and retry logic. Add support for future CRM integrations.",
            "status": "pending",
            "testStrategy": "Test service with both CRM providers. Verify adapter pattern correctly handles provider differences. Test factory selection logic with various company configurations."
          },
          {
            "id": 16,
            "title": "Implement CRM sync scheduling and monitoring",
            "description": "Create a system for scheduling regular CRM synchronization and monitoring sync health.",
            "dependencies": [
              "7.6",
              "7.9",
              "7.15"
            ],
            "details": "Implement scheduled jobs for regular CRM synchronization. Create admin dashboard for monitoring sync status and history. Add alerting for sync failures or discrepancies. Implement manual sync triggers for immediate synchronization. Add detailed logging for troubleshooting.",
            "status": "pending",
            "testStrategy": "Test scheduled job execution. Verify monitoring dashboard displays accurate information. Test alerting with simulated failures. Verify manual sync triggers work correctly."
          }
        ]
      },
      {
        "id": 8,
        "title": "AI-Powered Advocate Matching System",
        "description": "Develop the AI-powered advocate matching system that recommends the best advocates based on prospect profiles, advocate relevance, and availability.",
        "details": "1. Implement the matching algorithm infrastructure:\n   - Create data preparation utilities\n   - Build OpenAI integration for matching\n   - Implement fallback rule-based matching\n2. Create the matching service:\n```typescript\n// services/matchingService.ts\nexport const findMatchingAdvocates = async (opportunityId: string, filters?: MatchFilters) => {\n  // Fetch opportunity details\n  const opportunity = await getOpportunity(opportunityId)\n  \n  // Prepare context for AI matching\n  const matchingContext = {\n    industry: opportunity.prospect_industry,\n    companySize: opportunity.prospect_size,\n    useCase: opportunity.use_case,\n    // Other relevant factors\n  }\n  \n  // Call OpenAI for intelligent matching\n  const aiMatches = await getAIRecommendations(matchingContext)\n  \n  // Apply availability and fatigue filters\n  const availableMatches = await filterByAvailability(aiMatches)\n  \n  // Apply any additional filters\n  const finalMatches = filters ? applyCustomFilters(availableMatches, filters) : availableMatches\n  \n  return finalMatches\n}\n\nasync function getAIRecommendations(context) {\n  const { data } = await openai.createCompletion({\n    model: \"gpt-4\",\n    prompt: generateMatchingPrompt(context),\n    // Other OpenAI parameters\n  })\n  \n  // Process and structure the response\n  return processAIResponse(data)\n}\n```\n3. Implement confidence scoring system\n4. Create feedback loop for improving recommendations\n5. Build the matching UI components:\n   - Recommendation display with confidence scores\n   - Filtering interface\n   - Selection and booking flow\n6. Implement caching for performance optimization",
        "testStrategy": "Test matching algorithm with various opportunity profiles. Verify AI integration with mock responses. Test fallback mechanisms when AI is unavailable. Measure recommendation quality with historical data. Verify confidence scoring accuracy. Test the feedback loop for recommendation improvement.",
        "priority": "high",
        "dependencies": [
          2,
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Data Preparation Utilities",
            "description": "Develop utilities to prepare and structure data for the AI matching algorithm, including opportunity and advocate data normalization.",
            "dependencies": [],
            "details": "Create a set of utility functions in `utils/dataPreparation.ts` that transform raw opportunity and advocate data into a structured format suitable for the matching algorithm. Include functions for extracting relevant features, normalizing text fields, and creating embeddings for semantic matching. Implement methods to handle missing data and standardize industry terms and company sizes.",
            "status": "pending",
            "testStrategy": "Write unit tests for each utility function with various input scenarios including edge cases like missing data. Verify that the output format is consistent and properly structured for the matching algorithm."
          },
          {
            "id": 2,
            "title": "Implement OpenAI Integration for Matching",
            "description": "Build the integration with OpenAI API for intelligent advocate matching based on opportunity context.",
            "dependencies": [
              "8.1"
            ],
            "details": "Create a service in `services/aiService.ts` that handles communication with OpenAI. Implement functions to generate appropriate prompts based on opportunity context, send requests to OpenAI API, and parse responses. Include error handling, retry logic, and response validation. Configure the service to use the appropriate OpenAI model (GPT-4) and parameters for optimal matching results.",
            "status": "pending",
            "testStrategy": "Test the OpenAI integration with mock API responses. Verify prompt generation with different opportunity contexts. Test error handling and retry mechanisms by simulating API failures."
          },
          {
            "id": 3,
            "title": "Develop Rule-Based Fallback Matching System",
            "description": "Create a rule-based matching system that serves as a fallback when AI matching is unavailable or returns insufficient results.",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement a rule-based matching algorithm in `services/fallbackMatching.ts` that uses deterministic rules to match advocates to opportunities. Include logic for industry matching, company size compatibility, use case alignment, and geographic relevance. Design the system to be configurable with weighted scoring for different matching criteria. Ensure the output format matches the AI-based system for seamless integration.",
            "status": "pending",
            "testStrategy": "Test the rule-based matching with various opportunity profiles and advocate datasets. Verify that the scoring system correctly prioritizes the most relevant advocates. Compare results with expected outcomes for known test cases."
          },
          {
            "id": 4,
            "title": "Create Core Matching Service",
            "description": "Develop the main matching service that orchestrates the AI and rule-based matching systems and applies filters.",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Implement the `services/matchingService.ts` as outlined in the task description. Create the `findMatchingAdvocates` function that fetches opportunity details, prepares context for AI matching, calls the AI service, applies availability and fatigue filters, and handles custom filters. Add proper error handling and logging. Ensure the service gracefully falls back to rule-based matching when AI matching fails or returns insufficient results.",
            "status": "pending",
            "testStrategy": "Test the matching service with various opportunity profiles. Verify that it correctly integrates both AI and fallback matching systems. Test the filter application logic with different filter combinations. Simulate AI service failures to verify fallback behavior."
          },
          {
            "id": 5,
            "title": "Implement Availability and Fatigue Filtering",
            "description": "Create functions to filter advocate matches based on their availability and prevent advocate fatigue.",
            "dependencies": [
              "8.4"
            ],
            "details": "Develop the `filterByAvailability` function in `services/availabilityService.ts` that checks advocate calendars and availability settings. Implement fatigue prevention logic that considers recent and upcoming calls to avoid overusing the same advocates. Create a scoring system that factors in recency and frequency of previous engagements. Integrate with the advocate management system to access availability data.",
            "status": "pending",
            "testStrategy": "Test availability filtering with various calendar scenarios. Verify fatigue prevention with simulated call history data. Test edge cases like advocates with no availability or fully booked schedules."
          },
          {
            "id": 6,
            "title": "Implement Custom Filtering System",
            "description": "Create a flexible filtering system that allows users to apply additional criteria to advocate matches.",
            "dependencies": [
              "8.4"
            ],
            "details": "Implement the `applyCustomFilters` function in `services/filterService.ts` that processes user-defined filters. Support filtering by industry, company size, geographic region, use case, language, and other relevant attributes. Design the filter system to be extensible for future filter types. Ensure filters can be combined with logical AND/OR operations.",
            "status": "pending",
            "testStrategy": "Test the custom filtering system with various filter combinations. Verify that complex filter logic works correctly. Test performance with large datasets and multiple filters."
          },
          {
            "id": 7,
            "title": "Develop Confidence Scoring System",
            "description": "Implement a system to calculate and assign confidence scores to advocate matches based on relevance and fit.",
            "dependencies": [
              "8.4"
            ],
            "details": "Create a confidence scoring module in `services/confidenceScoring.ts` that evaluates the quality of each match. Develop algorithms to calculate scores based on industry match, use case relevance, company size similarity, and other factors. Normalize scores on a 0-100 scale. Include confidence metadata from AI responses when available. Ensure scores are consistent between AI and rule-based matching systems.",
            "status": "pending",
            "testStrategy": "Test confidence scoring with various match scenarios. Verify score normalization and consistency. Compare scores against expert-rated matches to validate the scoring algorithm."
          },
          {
            "id": 8,
            "title": "Create Feedback Collection System",
            "description": "Implement a system to collect feedback on advocate matches to improve future recommendations.",
            "dependencies": [
              "8.7"
            ],
            "details": "Develop a feedback collection service in `services/feedbackService.ts` that captures user ratings and comments on advocate matches. Create data structures to store feedback data in the database. Implement functions to associate feedback with specific matches and opportunities. Design the system to collect both explicit feedback (ratings) and implicit feedback (selections made).",
            "status": "pending",
            "testStrategy": "Test feedback collection with various user inputs. Verify that feedback is correctly associated with matches and stored in the database. Test the feedback API endpoints with different request scenarios."
          },
          {
            "id": 9,
            "title": "Implement Feedback-Based Learning System",
            "description": "Create a system that uses collected feedback to improve future advocate matching recommendations.",
            "dependencies": [
              "8.8"
            ],
            "details": "Develop a learning system in `services/matchLearning.ts` that analyzes feedback data to refine matching algorithms. Implement functions to adjust matching weights based on historical feedback. Create a periodic job to process feedback and update matching parameters. Design the system to identify patterns in successful matches and incorporate them into future recommendations.",
            "status": "pending",
            "testStrategy": "Test the learning system with historical feedback data. Verify that matching parameters are appropriately adjusted based on feedback. Measure recommendation quality improvement over time with simulated feedback cycles."
          },
          {
            "id": 10,
            "title": "Build Recommendation Display Component",
            "description": "Create the UI component for displaying advocate recommendations with confidence scores and relevant information.",
            "dependencies": [
              "8.7"
            ],
            "details": "Develop a React component in `components/AdvocateRecommendations.tsx` that displays advocate matches with their confidence scores, relevance factors, and availability. Implement sorting by confidence score and other attributes. Include advocate details like industry experience, company size, and use case expertise. Design the component to be responsive and accessible.",
            "status": "pending",
            "testStrategy": "Create unit tests for the component with various data scenarios. Test sorting and filtering functionality. Verify responsive behavior at different screen sizes. Test accessibility compliance."
          },
          {
            "id": 11,
            "title": "Create Filtering Interface Component",
            "description": "Build the UI component for applying custom filters to advocate recommendations.",
            "dependencies": [
              "8.6",
              "8.10"
            ],
            "details": "Implement a filtering interface component in `components/AdvocateFilters.tsx` that allows users to apply and manage custom filters. Include filter controls for industry, company size, geographic region, use case, and other attributes. Design the component with clear visual feedback for active filters. Implement filter combination logic with AND/OR operations.",
            "status": "pending",
            "testStrategy": "Test the filtering interface with various filter combinations. Verify that the UI correctly reflects active filters. Test filter application and removal. Verify that filter changes trigger appropriate data updates."
          },
          {
            "id": 12,
            "title": "Develop Advocate Selection and Booking Flow",
            "description": "Create the UI flow for selecting advocates from recommendations and booking them for reference calls.",
            "dependencies": [
              "8.10"
            ],
            "details": "Implement the selection and booking flow in `components/AdvocateBooking.tsx` that allows users to select advocates from recommendations and schedule calls. Include confirmation steps, calendar integration, and notification setup. Design the flow to handle multiple advocate selections. Implement validation to prevent double-booking and scheduling conflicts.",
            "status": "pending",
            "testStrategy": "Test the booking flow with various selection scenarios. Verify calendar integration and availability checking. Test validation logic for scheduling conflicts. Verify that notifications are correctly triggered."
          },
          {
            "id": 13,
            "title": "Implement Caching System for Performance Optimization",
            "description": "Develop a caching system to improve performance of advocate matching and reduce API calls.",
            "dependencies": [
              "8.4"
            ],
            "details": "Create a caching service in `services/cachingService.ts` that stores and retrieves matching results. Implement cache invalidation strategies based on data changes and time expiration. Use Redis or a similar in-memory store for high-performance caching. Design the system to cache at multiple levels: raw AI responses, processed matches, and filtered results.",
            "status": "pending",
            "testStrategy": "Test cache hit and miss scenarios. Verify cache invalidation when underlying data changes. Measure performance improvements with and without caching. Test cache behavior under concurrent access."
          },
          {
            "id": 14,
            "title": "Create Admin Interface for Matching Configuration",
            "description": "Build an admin interface for configuring and tuning the matching algorithm parameters.",
            "dependencies": [
              "8.7",
              "8.9"
            ],
            "details": "Develop an admin configuration interface in `components/admin/MatchingConfiguration.tsx` that allows administrators to view and adjust matching algorithm parameters. Include controls for confidence threshold, weighting factors, and fallback behavior. Implement validation for configuration changes. Design the interface with clear explanations of each parameter's impact.",
            "status": "pending",
            "testStrategy": "Test the admin interface with various configuration changes. Verify that changes are correctly saved and applied to the matching algorithm. Test validation logic for invalid configurations. Verify that configuration history is maintained."
          }
        ]
      },
      {
        "id": 9,
        "title": "Calendar Integration and Scheduling System",
        "description": "Implement the scheduling system with calendar integrations (Google Calendar, Outlook) for real-time availability display and automated meeting creation.",
        "details": "1. Implement OAuth flows for calendar providers:\n   - Google Calendar authentication\n   - Microsoft Graph (Outlook) authentication\n2. Create calendar service abstractions:\n```typescript\n// services/calendarService.ts\ninterface CalendarProvider {\n  getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]>\n  createMeeting(details: MeetingDetails): Promise<Meeting>\n  updateMeeting(meetingId: string, details: Partial<MeetingDetails>): Promise<Meeting>\n  deleteMeeting(meetingId: string): Promise<void>\n}\n\nclass GoogleCalendarProvider implements CalendarProvider {\n  // Implementation for Google Calendar\n}\n\nclass OutlookCalendarProvider implements CalendarProvider {\n  // Implementation for Outlook\n}\n\nexport const getCalendarProvider = (type: 'google' | 'outlook'): CalendarProvider => {\n  if (type === 'google') return new GoogleCalendarProvider()\n  return new OutlookCalendarProvider()\n}\n```\n3. Implement availability calculation and display:\n   - Fetch and merge calendar events\n   - Calculate available time slots\n   - Handle time zone differences\n4. Build meeting creation workflow:\n   - Create calendar events\n   - Generate video meeting links (Zoom/Teams)\n   - Send calendar invitations\n5. Implement notification system:\n   - Booking confirmations\n   - Reminder notifications\n   - Rescheduling/cancellation handling\n6. Create the scheduling UI components:\n   - Date/time picker\n   - Availability display\n   - Booking confirmation\n   - Rescheduling interface",
        "testStrategy": "Test OAuth flows with mock authentication servers. Verify availability calculation with various calendar scenarios. Test meeting creation across different calendar providers. Ensure proper time zone handling. Test notification delivery for various events. Verify rescheduling and cancellation workflows.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Google Calendar OAuth Flow",
            "description": "Set up OAuth authentication flow for Google Calendar integration, including authorization endpoints, token handling, and user consent screens.",
            "dependencies": [],
            "details": "1. Create OAuth configuration for Google Calendar API in Google Cloud Console\n2. Implement authorization URL generation with required scopes (calendar.readonly, calendar.events)\n3. Create callback handler to process OAuth code and exchange for tokens\n4. Implement token storage in database with encryption\n5. Add token refresh mechanism for expired tokens\n6. Create user interface for connecting Google Calendar\n\nExample code:\n```typescript\n// services/auth/googleAuth.ts\nimport { oauth2Client } from '../config/googleApi';\n\nexport const generateAuthUrl = (userId: string): string => {\n  return oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: ['https://www.googleapis.com/auth/calendar.readonly', 'https://www.googleapis.com/auth/calendar.events'],\n    state: userId, // Pass user ID to callback\n    prompt: 'consent'\n  });\n};\n\nexport const handleCallback = async (code: string): Promise<{\n  tokens: any;\n  userId: string;\n}> => {\n  const { tokens } = await oauth2Client.getToken(code);\n  // Store tokens in database\n  return { tokens, userId };\n};\n```",
            "status": "pending",
            "testStrategy": "1. Create mock OAuth endpoints for testing\n2. Verify correct scopes are requested\n3. Test token exchange with mock responses\n4. Verify token storage and encryption\n5. Test token refresh mechanism with expired tokens\n6. Verify error handling for failed authentication attempts"
          },
          {
            "id": 2,
            "title": "Implement Microsoft Outlook OAuth Flow",
            "description": "Set up OAuth authentication flow for Microsoft Outlook Calendar integration using Microsoft Graph API, including authorization endpoints, token handling, and user consent screens.",
            "dependencies": [],
            "details": "1. Register application in Azure AD portal\n2. Configure Microsoft Graph API permissions (Calendars.Read, Calendars.ReadWrite)\n3. Implement authorization URL generation with required scopes\n4. Create callback handler to process OAuth code and exchange for tokens\n5. Implement token storage in database with encryption\n6. Add token refresh mechanism for expired tokens\n7. Create user interface for connecting Outlook Calendar\n\nExample code:\n```typescript\n// services/auth/outlookAuth.ts\nimport { confidentialClientApplication } from '../config/microsoftGraph';\n\nexport const generateAuthUrl = (userId: string): string => {\n  const authCodeUrlParameters = {\n    scopes: ['Calendars.Read', 'Calendars.ReadWrite'],\n    redirectUri: process.env.OUTLOOK_REDIRECT_URI,\n    state: userId\n  };\n  \n  return confidentialClientApplication.getAuthCodeUrl(authCodeUrlParameters);\n};\n\nexport const handleCallback = async (code: string): Promise<{\n  tokens: any;\n  userId: string;\n}> => {\n  const tokenResponse = await confidentialClientApplication.acquireTokenByCode({\n    code,\n    redirectUri: process.env.OUTLOOK_REDIRECT_URI,\n    scopes: ['Calendars.Read', 'Calendars.ReadWrite']\n  });\n  \n  // Store tokens in database\n  return { tokens: tokenResponse, userId };\n};\n```",
            "status": "pending",
            "testStrategy": "1. Create mock OAuth endpoints for testing\n2. Verify correct scopes are requested\n3. Test token exchange with mock responses\n4. Verify token storage and encryption\n5. Test token refresh mechanism with expired tokens\n6. Verify error handling for failed authentication attempts"
          },
          {
            "id": 3,
            "title": "Implement Google Calendar Provider",
            "description": "Create the Google Calendar provider implementation that handles fetching availability, creating meetings, updating meetings, and deleting meetings using the Google Calendar API.",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Implement the CalendarProvider interface for Google Calendar\n2. Create methods to fetch calendar events within a date range\n3. Implement availability calculation based on existing events\n4. Add methods to create, update, and delete calendar events\n5. Handle time zone conversions for events\n6. Implement video conferencing link generation (Google Meet)\n\nExample code:\n```typescript\n// services/calendar/googleCalendarProvider.ts\nimport { google } from 'googleapis';\nimport { CalendarProvider, AvailabilitySlot, MeetingDetails, Meeting } from '../calendarService';\n\nexport class GoogleCalendarProvider implements CalendarProvider {\n  private getAuthClient(userId: string) {\n    // Fetch tokens from database and create authenticated client\n    // ...\n    return authClient;\n  }\n\n  async getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]> {\n    const auth = this.getAuthClient(userId);\n    const calendar = google.calendar({ version: 'v3', auth });\n    \n    const response = await calendar.events.list({\n      calendarId: 'primary',\n      timeMin: startDate.toISOString(),\n      timeMax: endDate.toISOString(),\n      singleEvents: true,\n      orderBy: 'startTime',\n    });\n    \n    // Process events and calculate availability slots\n    // ...\n    \n    return availabilitySlots;\n  }\n\n  async createMeeting(details: MeetingDetails): Promise<Meeting> {\n    const auth = this.getAuthClient(details.userId);\n    const calendar = google.calendar({ version: 'v3', auth });\n    \n    const event = {\n      summary: details.title,\n      description: details.description,\n      start: { dateTime: details.startTime.toISOString() },\n      end: { dateTime: details.endTime.toISOString() },\n      attendees: details.attendees.map(email => ({ email })),\n      conferenceData: {\n        createRequest: { requestId: uuid() }\n      }\n    };\n    \n    const response = await calendar.events.insert({\n      calendarId: 'primary',\n      conferenceDataVersion: 1,\n      requestBody: event\n    });\n    \n    return this.mapToMeeting(response.data);\n  }\n\n  // Implement updateMeeting and deleteMeeting methods\n  // ...\n}\n```",
            "status": "pending",
            "testStrategy": "1. Mock Google Calendar API responses for testing\n2. Test availability calculation with various calendar scenarios\n3. Verify meeting creation with correct parameters\n4. Test meeting updates and deletions\n5. Verify proper handling of time zones\n6. Test error handling for API failures"
          },
          {
            "id": 4,
            "title": "Implement Outlook Calendar Provider",
            "description": "Create the Outlook Calendar provider implementation that handles fetching availability, creating meetings, updating meetings, and deleting meetings using the Microsoft Graph API.",
            "dependencies": [
              "9.2"
            ],
            "details": "1. Implement the CalendarProvider interface for Outlook Calendar\n2. Create methods to fetch calendar events within a date range\n3. Implement availability calculation based on existing events\n4. Add methods to create, update, and delete calendar events\n5. Handle time zone conversions for events\n6. Implement video conferencing link generation (Microsoft Teams)\n\nExample code:\n```typescript\n// services/calendar/outlookCalendarProvider.ts\nimport { Client } from '@microsoft/microsoft-graph-client';\nimport { CalendarProvider, AvailabilitySlot, MeetingDetails, Meeting } from '../calendarService';\n\nexport class OutlookCalendarProvider implements CalendarProvider {\n  private getGraphClient(userId: string) {\n    // Fetch tokens from database and create authenticated client\n    // ...\n    return client;\n  }\n\n  async getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]> {\n    const client = this.getGraphClient(userId);\n    \n    const events = await client\n      .api(`/me/calendarView?startDateTime=${startDate.toISOString()}&endDateTime=${endDate.toISOString()}`)\n      .select('subject,start,end,isAllDay')\n      .orderby('start/dateTime')\n      .get();\n    \n    // Process events and calculate availability slots\n    // ...\n    \n    return availabilitySlots;\n  }\n\n  async createMeeting(details: MeetingDetails): Promise<Meeting> {\n    const client = this.getGraphClient(details.userId);\n    \n    const event = {\n      subject: details.title,\n      body: {\n        contentType: 'HTML',\n        content: details.description\n      },\n      start: {\n        dateTime: details.startTime.toISOString(),\n        timeZone: 'UTC'\n      },\n      end: {\n        dateTime: details.endTime.toISOString(),\n        timeZone: 'UTC'\n      },\n      attendees: details.attendees.map(email => ({\n        emailAddress: { address: email },\n        type: 'required'\n      })),\n      isOnlineMeeting: true,\n      onlineMeetingProvider: 'teamsForBusiness'\n    };\n    \n    const response = await client.api('/me/events').post(event);\n    \n    return this.mapToMeeting(response);\n  }\n\n  // Implement updateMeeting and deleteMeeting methods\n  // ...\n}\n```",
            "status": "pending",
            "testStrategy": "1. Mock Microsoft Graph API responses for testing\n2. Test availability calculation with various calendar scenarios\n3. Verify meeting creation with correct parameters\n4. Test meeting updates and deletions\n5. Verify proper handling of time zones\n6. Test error handling for API failures"
          },
          {
            "id": 5,
            "title": "Implement Calendar Service Factory and Abstractions",
            "description": "Create the calendar service factory and abstractions that provide a unified interface for working with different calendar providers.",
            "dependencies": [
              "9.3",
              "9.4"
            ],
            "details": "1. Implement the CalendarProvider interface\n2. Create factory method to get appropriate calendar provider\n3. Implement shared utility functions for availability calculations\n4. Add methods for working with multiple calendar providers simultaneously\n5. Create database models for storing calendar connections\n\nExample code:\n```typescript\n// services/calendarService.ts\nexport interface AvailabilitySlot {\n  start: Date;\n  end: Date;\n}\n\nexport interface MeetingDetails {\n  userId: string;\n  title: string;\n  description: string;\n  startTime: Date;\n  endTime: Date;\n  attendees: string[];\n  videoConferencing?: boolean;\n}\n\nexport interface Meeting {\n  id: string;\n  title: string;\n  description: string;\n  startTime: Date;\n  endTime: Date;\n  attendees: string[];\n  videoConferenceLink?: string;\n  calendarLink: string;\n}\n\nexport interface CalendarProvider {\n  getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]>;\n  createMeeting(details: MeetingDetails): Promise<Meeting>;\n  updateMeeting(meetingId: string, details: Partial<MeetingDetails>): Promise<Meeting>;\n  deleteMeeting(meetingId: string): Promise<void>;\n}\n\nimport { GoogleCalendarProvider } from './calendar/googleCalendarProvider';\nimport { OutlookCalendarProvider } from './calendar/outlookCalendarProvider';\n\nexport const getCalendarProvider = (type: 'google' | 'outlook'): CalendarProvider => {\n  if (type === 'google') return new GoogleCalendarProvider();\n  return new OutlookCalendarProvider();\n};\n\n// Get user's connected calendar providers\nexport const getUserCalendarProviders = async (userId: string): Promise<Array<{\n  type: 'google' | 'outlook';\n  provider: CalendarProvider;\n}>> => {\n  // Fetch user's connected calendars from database\n  // Return initialized providers\n};\n\n// Get availability across all connected calendars\nexport const getUserAvailability = async (\n  userId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<AvailabilitySlot[]> => {\n  const providers = await getUserCalendarProviders(userId);\n  \n  // Fetch availability from all providers\n  const availabilityPromises = providers.map(({ provider }) => \n    provider.getAvailability(userId, startDate, endDate)\n  );\n  \n  const availabilities = await Promise.all(availabilityPromises);\n  \n  // Merge availabilities and resolve conflicts\n  return mergeAvailabilities(availabilities);\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test factory method returns correct provider instances\n2. Verify availability merging with multiple calendars\n3. Test handling of conflicting events across calendars\n4. Verify proper database operations for calendar connections\n5. Test error handling when a provider fails"
          },
          {
            "id": 6,
            "title": "Implement Availability Calculation Algorithm",
            "description": "Create an algorithm to calculate available time slots based on calendar events, working hours, and buffer times.",
            "dependencies": [
              "9.5"
            ],
            "details": "1. Implement function to merge events from multiple calendars\n2. Create algorithm to find free slots between events\n3. Add support for working hours constraints\n4. Implement buffer time before/after meetings\n5. Handle time zone differences in availability calculation\n6. Add support for minimum meeting duration filtering\n\nExample code:\n```typescript\n// services/availability/availabilityCalculator.ts\nimport { AvailabilitySlot } from '../calendarService';\n\ninterface CalendarEvent {\n  start: Date;\n  end: Date;\n}\n\ninterface WorkingHours {\n  daysOfWeek: number[]; // 0 = Sunday, 6 = Saturday\n  startTime: string; // Format: \"HH:MM\"\n  endTime: string; // Format: \"HH:MM\"\n  timeZone: string;\n}\n\nexport const mergeEvents = (eventSets: CalendarEvent[][]): CalendarEvent[] => {\n  // Flatten and sort all events\n  const allEvents = eventSets.flat().sort((a, b) => a.start.getTime() - b.start.getTime());\n  \n  // Merge overlapping events\n  const mergedEvents: CalendarEvent[] = [];\n  \n  for (const event of allEvents) {\n    const lastEvent = mergedEvents[mergedEvents.length - 1];\n    \n    if (!lastEvent || event.start > lastEvent.end) {\n      mergedEvents.push(event);\n    } else if (event.end > lastEvent.end) {\n      lastEvent.end = event.end;\n    }\n  }\n  \n  return mergedEvents;\n};\n\nexport const calculateAvailability = (\n  startDate: Date,\n  endDate: Date,\n  events: CalendarEvent[],\n  workingHours: WorkingHours,\n  bufferMinutes: number = 0,\n  minimumDurationMinutes: number = 15\n): AvailabilitySlot[] => {\n  const availableSlots: AvailabilitySlot[] = [];\n  const mergedEvents = [...events];\n  \n  // Add working hours constraints as events\n  // ...\n  \n  // Sort events chronologically\n  mergedEvents.sort((a, b) => a.start.getTime() - b.start.getTime());\n  \n  // Find gaps between events\n  let currentTime = new Date(startDate);\n  \n  for (const event of mergedEvents) {\n    // Add buffer to current time\n    const bufferTime = new Date(currentTime);\n    bufferTime.setMinutes(bufferTime.getMinutes() + bufferMinutes);\n    \n    // If there's a gap between current time (with buffer) and next event\n    if (bufferTime < event.start) {\n      // Check if gap meets minimum duration\n      const gapDuration = event.start.getTime() - bufferTime.getTime();\n      if (gapDuration >= minimumDurationMinutes * 60 * 1000) {\n        availableSlots.push({\n          start: new Date(bufferTime),\n          end: new Date(event.start)\n        });\n      }\n    }\n    \n    // Move current time to end of event plus buffer\n    currentTime = new Date(event.end);\n    currentTime.setMinutes(currentTime.getMinutes() + bufferMinutes);\n  }\n  \n  // Check for availability after last event\n  if (currentTime < endDate) {\n    availableSlots.push({\n      start: new Date(currentTime),\n      end: new Date(endDate)\n    });\n  }\n  \n  return availableSlots;\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test with various calendar event scenarios\n2. Verify working hours constraints are properly applied\n3. Test buffer time calculations\n4. Verify time zone handling with events in different time zones\n5. Test minimum duration filtering\n6. Verify merging of events from multiple calendars"
          },
          {
            "id": 7,
            "title": "Implement Meeting Creation Workflow",
            "description": "Create the workflow for scheduling meetings, including calendar event creation, video conferencing links, and sending invitations.",
            "dependencies": [
              "9.5"
            ],
            "details": "1. Implement meeting creation service\n2. Add support for generating video conferencing links (Zoom/Teams/Meet)\n3. Create email invitation templates\n4. Implement meeting confirmation workflow\n5. Add support for adding meeting details to both host and attendee calendars\n\nExample code:\n```typescript\n// services/meeting/meetingService.ts\nimport { MeetingDetails, Meeting, getCalendarProvider } from '../calendarService';\nimport { sendMeetingInvitation } from '../notifications/emailService';\nimport { generateZoomMeetingLink } from '../integrations/zoomService';\n\nexport interface ScheduleMeetingRequest {\n  hostUserId: string;\n  hostCalendarType: 'google' | 'outlook';\n  title: string;\n  description: string;\n  startTime: Date;\n  endTime: Date;\n  attendees: string[];\n  useVideoConferencing: boolean;\n  videoProvider?: 'zoom' | 'teams' | 'meet';\n}\n\nexport const scheduleMeeting = async (request: ScheduleMeetingRequest): Promise<Meeting> => {\n  // Get the appropriate calendar provider\n  const calendarProvider = getCalendarProvider(request.hostCalendarType);\n  \n  // Generate video conferencing link if requested\n  let videoConferenceLink: string | undefined;\n  \n  if (request.useVideoConferencing) {\n    if (request.videoProvider === 'zoom') {\n      videoConferenceLink = await generateZoomMeetingLink({\n        topic: request.title,\n        startTime: request.startTime,\n        duration: Math.ceil((request.endTime.getTime() - request.startTime.getTime()) / (60 * 1000))\n      });\n    }\n    // Handle other providers or use native calendar video conferencing\n  }\n  \n  // Create meeting details\n  const meetingDetails: MeetingDetails = {\n    userId: request.hostUserId,\n    title: request.title,\n    description: request.description + (videoConferenceLink ? `\\n\\nJoin meeting: ${videoConferenceLink}` : ''),\n    startTime: request.startTime,\n    endTime: request.endTime,\n    attendees: request.attendees,\n    videoConferencing: request.useVideoConferencing\n  };\n  \n  // Create the meeting in the calendar\n  const meeting = await calendarProvider.createMeeting(meetingDetails);\n  \n  // Send email invitations\n  await Promise.all(request.attendees.map(attendee => \n    sendMeetingInvitation({\n      to: attendee,\n      meeting,\n      hostName: 'Host Name', // Get from user profile\n      hostEmail: 'host@example.com' // Get from user profile\n    })\n  ));\n  \n  return meeting;\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test meeting creation with different calendar providers\n2. Verify video conferencing link generation\n3. Test email invitation sending\n4. Verify proper error handling for failed meeting creation\n5. Test with various time zones and date formats"
          },
          {
            "id": 8,
            "title": "Implement Notification System for Calendar Events",
            "description": "Create a notification system for calendar events, including booking confirmations, reminders, and rescheduling/cancellation notifications.",
            "dependencies": [
              "9.7"
            ],
            "details": "1. Create notification templates for different event types\n2. Implement email notification service\n3. Add support for SMS notifications (optional)\n4. Create in-app notification system\n5. Implement reminder scheduling based on event times\n6. Add notification preferences for users\n\nExample code:\n```typescript\n// services/notifications/calendarNotifications.ts\nimport { Meeting } from '../calendarService';\nimport { sendEmail } from './emailService';\nimport { sendSms } from './smsService';\nimport { createInAppNotification } from './inAppNotificationService';\n\nexport enum NotificationType {\n  BOOKING_CONFIRMATION = 'booking_confirmation',\n  MEETING_REMINDER = 'meeting_reminder',\n  MEETING_RESCHEDULED = 'meeting_rescheduled',\n  MEETING_CANCELLED = 'meeting_cancelled'\n}\n\nexport interface NotificationPreferences {\n  email: boolean;\n  sms: boolean;\n  inApp: boolean;\n  reminderTimes: number[]; // Minutes before meeting\n}\n\nexport const sendMeetingNotification = async (\n  type: NotificationType,\n  meeting: Meeting,\n  recipients: Array<{\n    email: string;\n    phone?: string;\n    userId?: string;\n    preferences: NotificationPreferences;\n  }>\n): Promise<void> => {\n  const notifications = [];\n  \n  for (const recipient of recipients) {\n    // Send email notification\n    if (recipient.preferences.email) {\n      notifications.push(sendEmail({\n        to: recipient.email,\n        templateId: getEmailTemplateForType(type),\n        data: {\n          meeting,\n          recipientEmail: recipient.email\n        }\n      }));\n    }\n    \n    // Send SMS notification\n    if (recipient.preferences.sms && recipient.phone) {\n      notifications.push(sendSms({\n        to: recipient.phone,\n        templateId: getSmsTemplateForType(type),\n        data: {\n          meeting\n        }\n      }));\n    }\n    \n    // Create in-app notification\n    if (recipient.preferences.inApp && recipient.userId) {\n      notifications.push(createInAppNotification({\n        userId: recipient.userId,\n        type,\n        data: {\n          meeting\n        }\n      }));\n    }\n  }\n  \n  await Promise.all(notifications);\n};\n\nexport const scheduleMeetingReminders = async (\n  meeting: Meeting,\n  recipients: Array<{\n    email: string;\n    phone?: string;\n    userId?: string;\n    preferences: NotificationPreferences;\n  }>\n): Promise<void> => {\n  for (const recipient of recipients) {\n    for (const reminderTime of recipient.preferences.reminderTimes) {\n      const reminderDate = new Date(meeting.startTime);\n      reminderDate.setMinutes(reminderDate.getMinutes() - reminderTime);\n      \n      // Schedule reminder\n      await scheduleNotification({\n        type: NotificationType.MEETING_REMINDER,\n        meeting,\n        recipient,\n        scheduledTime: reminderDate\n      });\n    }\n  }\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test notification sending for different event types\n2. Verify reminder scheduling with various time offsets\n3. Test notification preferences are respected\n4. Verify proper handling of failed notifications\n5. Test notification content for different templates"
          },
          {
            "id": 9,
            "title": "Implement Date/Time Picker Component",
            "description": "Create a reusable date/time picker component for selecting meeting times, with support for time zone selection and duration options.",
            "dependencies": [],
            "details": "1. Create a date picker component with calendar view\n2. Implement time selection with appropriate time increments\n3. Add time zone selector with automatic detection\n4. Create duration selector for common meeting lengths\n5. Implement responsive design for mobile and desktop\n6. Add accessibility features (keyboard navigation, screen reader support)\n\nExample code:\n```typescript\n// components/DateTimePicker.tsx\nimport React, { useState } from 'react';\nimport { format, addMinutes } from 'date-fns';\nimport { Calendar } from './Calendar';\nimport { TimeSelector } from './TimeSelector';\nimport { TimeZoneSelector } from './TimeZoneSelector';\nimport { DurationSelector } from './DurationSelector';\n\ninterface DateTimePickerProps {\n  initialDate?: Date;\n  minDate?: Date;\n  maxDate?: Date;\n  timeZone?: string;\n  availableTimeSlots?: Array<{\n    start: Date;\n    end: Date;\n  }>;\n  onChange: (selection: {\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  }) => void;\n}\n\nexport const DateTimePicker: React.FC<DateTimePickerProps> = ({\n  initialDate = new Date(),\n  minDate,\n  maxDate,\n  timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone,\n  availableTimeSlots = [],\n  onChange\n}) => {\n  const [selectedDate, setSelectedDate] = useState<Date>(initialDate);\n  const [selectedTime, setSelectedTime] = useState<string>(format(initialDate, 'HH:mm'));\n  const [selectedTimeZone, setSelectedTimeZone] = useState<string>(timeZone);\n  const [duration, setDuration] = useState<number>(30); // minutes\n  \n  // Get available time slots for the selected date\n  const availableTimesForDate = availableTimeSlots.filter(slot => {\n    const slotDate = new Date(slot.start);\n    return (\n      slotDate.getFullYear() === selectedDate.getFullYear() &&\n      slotDate.getMonth() === selectedDate.getMonth() &&\n      slotDate.getDate() === selectedDate.getDate()\n    );\n  });\n  \n  // Handle date change\n  const handleDateChange = (date: Date) => {\n    setSelectedDate(date);\n    \n    // If there are available slots for this date, select the first one\n    if (availableTimesForDate.length > 0) {\n      setSelectedTime(format(availableTimesForDate[0].start, 'HH:mm'));\n    }\n  };\n  \n  // Handle time change\n  const handleTimeChange = (time: string) => {\n    setSelectedTime(time);\n    updateSelectedDateTime(selectedDate, time, selectedTimeZone, duration);\n  };\n  \n  // Handle time zone change\n  const handleTimeZoneChange = (tz: string) => {\n    setSelectedTimeZone(tz);\n    updateSelectedDateTime(selectedDate, selectedTime, tz, duration);\n  };\n  \n  // Handle duration change\n  const handleDurationChange = (mins: number) => {\n    setDuration(mins);\n    updateSelectedDateTime(selectedDate, selectedTime, selectedTimeZone, mins);\n  };\n  \n  // Update the selected date/time and call onChange\n  const updateSelectedDateTime = (date: Date, time: string, tz: string, durationMins: number) => {\n    const [hours, minutes] = time.split(':').map(Number);\n    \n    const startTime = new Date(date);\n    startTime.setHours(hours, minutes, 0, 0);\n    \n    const endTime = addMinutes(startTime, durationMins);\n    \n    onChange({\n      startTime,\n      endTime,\n      timeZone: tz\n    });\n  };\n  \n  return (\n    <div className=\"date-time-picker\">\n      <Calendar\n        selectedDate={selectedDate}\n        minDate={minDate}\n        maxDate={maxDate}\n        availableDates={availableTimeSlots.map(slot => new Date(slot.start))}\n        onChange={handleDateChange}\n      />\n      \n      <TimeSelector\n        selectedTime={selectedTime}\n        availableSlots={availableTimesForDate}\n        onChange={handleTimeChange}\n      />\n      \n      <DurationSelector\n        duration={duration}\n        onChange={handleDurationChange}\n        options={[15, 30, 45, 60, 90]}\n      />\n      \n      <TimeZoneSelector\n        selectedTimeZone={selectedTimeZone}\n        onChange={handleTimeZoneChange}\n      />\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test date selection with various date ranges\n2. Verify time selection respects available time slots\n3. Test time zone conversion functionality\n4. Verify duration selection updates end time correctly\n5. Test accessibility with keyboard navigation\n6. Verify component works on different screen sizes"
          },
          {
            "id": 10,
            "title": "Implement Availability Display Component",
            "description": "Create a component to display user availability, showing available and busy time slots with appropriate visual indicators.",
            "dependencies": [
              "9.6",
              "9.9"
            ],
            "details": "1. Create a component to display daily/weekly availability\n2. Implement visual indicators for available and busy times\n3. Add time slot selection functionality\n4. Create responsive grid layout for different time formats\n5. Implement loading states for availability data fetching\n6. Add refresh functionality to update availability\n\nExample code:\n```typescript\n// components/AvailabilityDisplay.tsx\nimport React, { useState, useEffect } from 'react';\nimport { format, addDays, isSameDay } from 'date-fns';\nimport { AvailabilitySlot } from '../services/calendarService';\n\ninterface AvailabilityDisplayProps {\n  userId: string;\n  startDate: Date;\n  numberOfDays: number;\n  onSlotSelect: (slot: {\n    start: Date;\n    end: Date;\n  }) => void;\n  slotDuration: number; // minutes\n  workingHours: {\n    start: string; // Format: \"HH:MM\"\n    end: string; // Format: \"HH:MM\"\n  };\n}\n\nexport const AvailabilityDisplay: React.FC<AvailabilityDisplayProps> = ({\n  userId,\n  startDate,\n  numberOfDays,\n  onSlotSelect,\n  slotDuration,\n  workingHours\n}) => {\n  const [availabilitySlots, setAvailabilitySlots] = useState<AvailabilitySlot[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Calculate end date\n  const endDate = addDays(startDate, numberOfDays);\n  \n  // Fetch availability data\n  const fetchAvailability = async () => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(`/api/availability?userId=${userId}&startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`);\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch availability');\n      }\n      \n      const data = await response.json();\n      setAvailabilitySlots(data.availabilitySlots.map((slot: any) => ({\n        start: new Date(slot.start),\n        end: new Date(slot.end)\n      })));\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  useEffect(() => {\n    fetchAvailability();\n  }, [userId, startDate, numberOfDays]);\n  \n  // Generate time slots for display\n  const generateTimeSlots = () => {\n    const days = [];\n    \n    for (let i = 0; i < numberOfDays; i++) {\n      const currentDate = addDays(startDate, i);\n      const daySlots = [];\n      \n      // Parse working hours\n      const [startHour, startMinute] = workingHours.start.split(':').map(Number);\n      const [endHour, endMinute] = workingHours.end.split(':').map(Number);\n      \n      // Create slots within working hours\n      const slotStartTime = new Date(currentDate);\n      slotStartTime.setHours(startHour, startMinute, 0, 0);\n      \n      const dayEndTime = new Date(currentDate);\n      dayEndTime.setHours(endHour, endMinute, 0, 0);\n      \n      while (slotStartTime < dayEndTime) {\n        const slotEndTime = new Date(slotStartTime);\n        slotEndTime.setMinutes(slotEndTime.getMinutes() + slotDuration);\n        \n        if (slotEndTime > dayEndTime) {\n          break;\n        }\n        \n        // Check if slot is available\n        const isAvailable = availabilitySlots.some(availableSlot => {\n          return (\n            slotStartTime >= availableSlot.start &&\n            slotEndTime <= availableSlot.end\n          );\n        });\n        \n        daySlots.push({\n          start: new Date(slotStartTime),\n          end: new Date(slotEndTime),\n          isAvailable\n        });\n        \n        // Move to next slot\n        slotStartTime.setMinutes(slotStartTime.getMinutes() + slotDuration);\n      }\n      \n      days.push({\n        date: currentDate,\n        slots: daySlots\n      });\n    }\n    \n    return days;\n  };\n  \n  const timeSlots = generateTimeSlots();\n  \n  // Handle slot selection\n  const handleSlotClick = (slot: {\n    start: Date;\n    end: Date;\n    isAvailable: boolean;\n  }) => {\n    if (slot.isAvailable) {\n      onSlotSelect({\n        start: slot.start,\n        end: slot.end\n      });\n    }\n  };\n  \n  if (isLoading) {\n    return <div className=\"loading\">Loading availability...</div>;\n  }\n  \n  if (error) {\n    return (\n      <div className=\"error\">\n        <p>{error}</p>\n        <button onClick={fetchAvailability}>Retry</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"availability-display\">\n      <div className=\"days-container\">\n        {timeSlots.map((day, dayIndex) => (\n          <div key={dayIndex} className=\"day-column\">\n            <div className=\"day-header\">\n              {format(day.date, 'EEE, MMM d')}\n            </div>\n            <div className=\"slots-container\">\n              {day.slots.map((slot, slotIndex) => (\n                <div\n                  key={slotIndex}\n                  className={`time-slot ${slot.isAvailable ? 'available' : 'busy'}`}\n                  onClick={() => handleSlotClick(slot)}\n                >\n                  {format(slot.start, 'h:mm a')}\n                </div>\n              ))}\n            </div>\n          </div>\n        ))}\n      </div>\n      <button className=\"refresh-button\" onClick={fetchAvailability}>\n        Refresh Availability\n      </button>\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test rendering with various availability patterns\n2. Verify slot selection functionality\n3. Test loading and error states\n4. Verify refresh functionality updates the display\n5. Test with different time zones and working hours\n6. Verify responsive layout on different screen sizes"
          },
          {
            "id": 11,
            "title": "Implement Booking Confirmation Component",
            "description": "Create a component for displaying booking confirmation details, including meeting information, calendar links, and options to add to calendar.",
            "dependencies": [
              "9.7"
            ],
            "details": "1. Create a booking confirmation component\n2. Display meeting details (title, time, attendees)\n3. Show video conferencing link\n4. Add calendar links for different providers (Google, Outlook, iCal)\n5. Implement copy-to-clipboard functionality\n6. Add options to reschedule or cancel\n\nExample code:\n```typescript\n// components/BookingConfirmation.tsx\nimport React from 'react';\nimport { format } from 'date-fns';\nimport { Meeting } from '../services/calendarService';\n\ninterface BookingConfirmationProps {\n  meeting: Meeting;\n  onReschedule?: () => void;\n  onCancel?: () => void;\n  showAddToCalendarOptions?: boolean;\n}\n\nexport const BookingConfirmation: React.FC<BookingConfirmationProps> = ({\n  meeting,\n  onReschedule,\n  onCancel,\n  showAddToCalendarOptions = true\n}) => {\n  // Generate calendar links\n  const generateGoogleCalendarLink = () => {\n    const startTime = meeting.startTime.toISOString().replace(/-|:|\\./g, '');\n    const endTime = meeting.endTime.toISOString().replace(/-|:|\\./g, '');\n    \n    return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(meeting.title)}&dates=${startTime}/${endTime}&details=${encodeURIComponent(meeting.description)}`;\n  };\n  \n  const generateOutlookCalendarLink = () => {\n    return `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(meeting.title)}&startdt=${meeting.startTime.toISOString()}&enddt=${meeting.endTime.toISOString()}&body=${encodeURIComponent(meeting.description)}`;\n  };\n  \n  const generateICalLink = () => {\n    // In a real implementation, this would generate an .ics file\n    return `/api/calendar/ical?meetingId=${meeting.id}`;\n  };\n  \n  // Copy meeting link to clipboard\n  const copyMeetingLink = () => {\n    navigator.clipboard.writeText(meeting.videoConferenceLink || '');\n  };\n  \n  return (\n    <div className=\"booking-confirmation\">\n      <div className=\"confirmation-header\">\n        <h2>Meeting Confirmed!</h2>\n      </div>\n      \n      <div className=\"meeting-details\">\n        <h3>{meeting.title}</h3>\n        \n        <div className=\"meeting-time\">\n          <div className=\"date\">{format(meeting.startTime, 'EEEE, MMMM d, yyyy')}</div>\n          <div className=\"time\">\n            {format(meeting.startTime, 'h:mm a')} - {format(meeting.endTime, 'h:mm a')}\n          </div>\n        </div>\n        \n        {meeting.videoConferenceLink && (\n          <div className=\"video-link\">\n            <h4>Video Conference Link:</h4>\n            <div className=\"link-container\">\n              <a href={meeting.videoConferenceLink} target=\"_blank\" rel=\"noopener noreferrer\">\n                {meeting.videoConferenceLink}\n              </a>\n              <button className=\"copy-button\" onClick={copyMeetingLink}>\n                Copy\n              </button>\n            </div>\n          </div>\n        )}\n        \n        <div className=\"attendees\">\n          <h4>Attendees:</h4>\n          <ul>\n            {meeting.attendees.map((attendee, index) => (\n              <li key={index}>{attendee}</li>\n            ))}\n          </ul>\n        </div>\n        \n        {meeting.description && (\n          <div className=\"description\">\n            <h4>Description:</h4>\n            <p>{meeting.description}</p>\n          </div>\n        )}\n      </div>\n      \n      {showAddToCalendarOptions && (\n        <div className=\"calendar-options\">\n          <h4>Add to Calendar:</h4>\n          <div className=\"calendar-buttons\">\n            <a\n              href={generateGoogleCalendarLink()}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"calendar-button google\"\n            >\n              Google Calendar\n            </a>\n            <a\n              href={generateOutlookCalendarLink()}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"calendar-button outlook\"\n            >\n              Outlook\n            </a>\n            <a\n              href={generateICalLink()}\n              download=\"meeting.ics\"\n              className=\"calendar-button ical\"\n            >\n              iCal File\n            </a>\n          </div>\n        </div>\n      )}\n      \n      <div className=\"action-buttons\">\n        {onReschedule && (\n          <button className=\"reschedule-button\" onClick={onReschedule}>\n            Reschedule\n          </button>\n        )}\n        {onCancel && (\n          <button className=\"cancel-button\" onClick={onCancel}>\n            Cancel Meeting\n          </button>\n        )}\n      </div>\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test rendering with different meeting details\n2. Verify calendar link generation\n3. Test copy-to-clipboard functionality\n4. Verify reschedule and cancel button actions\n5. Test with and without video conferencing links\n6. Verify responsive layout on different screen sizes"
          },
          {
            "id": 12,
            "title": "Implement Rescheduling Interface",
            "description": "Create an interface for rescheduling existing meetings, including cancellation of the original meeting and creation of a new one.",
            "dependencies": [
              "9.7",
              "9.10",
              "9.11"
            ],
            "details": "1. Create a rescheduling workflow component\n2. Implement meeting lookup by ID\n3. Display current meeting details\n4. Add availability selection for new time\n5. Implement rescheduling confirmation\n6. Create notification system for rescheduled meetings\n\nExample code:\n```typescript\n// components/RescheduleMeeting.tsx\nimport React, { useState, useEffect } from 'react';\nimport { Meeting } from '../services/calendarService';\nimport { DateTimePicker } from './DateTimePicker';\nimport { AvailabilityDisplay } from './AvailabilityDisplay';\nimport { BookingConfirmation } from './BookingConfirmation';\n\nenum RescheduleStep {\n  LOADING,\n  CURRENT_DETAILS,\n  SELECT_NEW_TIME,\n  CONFIRMATION\n}\n\ninterface RescheduleMeetingProps {\n  meetingId: string;\n  userId: string;\n  onComplete: () => void;\n  onCancel: () => void;\n}\n\nexport const RescheduleMeeting: React.FC<RescheduleMeetingProps> = ({\n  meetingId,\n  userId,\n  onComplete,\n  onCancel\n}) => {\n  const [currentStep, setCurrentStep] = useState<RescheduleStep>(RescheduleStep.LOADING);\n  const [currentMeeting, setCurrentMeeting] = useState<Meeting | null>(null);\n  const [newMeeting, setNewMeeting] = useState<Meeting | null>(null);\n  const [selectedTimeSlot, setSelectedTimeSlot] = useState<{\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  } | null>(null);\n  const [availabilitySlots, setAvailabilitySlots] = useState<Array<{\n    start: Date;\n    end: Date;\n  }>>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Fetch current meeting details\n  useEffect(() => {\n    const fetchMeeting = async () => {\n      try {\n        const response = await fetch(`/api/meetings/${meetingId}`);\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch meeting details');\n        }\n        \n        const data = await response.json();\n        setCurrentMeeting({\n          ...data,\n          startTime: new Date(data.startTime),\n          endTime: new Date(data.endTime)\n        });\n        \n        setCurrentStep(RescheduleStep.CURRENT_DETAILS);\n      } catch (err) {\n        setError(err.message);\n      }\n    };\n    \n    fetchMeeting();\n  }, [meetingId]);\n  \n  // Fetch availability for new time selection\n  const fetchAvailability = async (startDate: Date, days: number) => {\n    setIsLoading(true);\n    \n    try {\n      const endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + days);\n      \n      const response = await fetch(`/api/availability?userId=${userId}&startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`);\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch availability');\n      }\n      \n      const data = await response.json();\n      setAvailabilitySlots(data.availabilitySlots.map((slot: any) => ({\n        start: new Date(slot.start),\n        end: new Date(slot.end)\n      })));\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Handle time slot selection\n  const handleTimeSlotSelect = (slot: {\n    start: Date;\n    end: Date;\n  }) => {\n    setSelectedTimeSlot({\n      startTime: slot.start,\n      endTime: slot.end,\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    });\n  };\n  \n  // Handle date/time selection from picker\n  const handleDateTimeChange = (selection: {\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  }) => {\n    setSelectedTimeSlot(selection);\n  };\n  \n  // Proceed to new time selection\n  const proceedToTimeSelection = () => {\n    setCurrentStep(RescheduleStep.SELECT_NEW_TIME);\n    \n    // Start with current date for availability\n    const startDate = new Date();\n    fetchAvailability(startDate, 14); // Fetch 2 weeks of availability\n  };\n  \n  // Reschedule the meeting\n  const handleReschedule = async () => {\n    if (!currentMeeting || !selectedTimeSlot) return;\n    \n    setIsLoading(true);\n    \n    try {\n      // Call API to reschedule meeting\n      const response = await fetch(`/api/meetings/${meetingId}/reschedule`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          startTime: selectedTimeSlot.startTime.toISOString(),\n          endTime: selectedTimeSlot.endTime.toISOString(),\n          timeZone: selectedTimeSlot.timeZone\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to reschedule meeting');\n      }\n      \n      const data = await response.json();\n      setNewMeeting({\n        ...data,\n        startTime: new Date(data.startTime),\n        endTime: new Date(data.endTime)\n      });\n      \n      setCurrentStep(RescheduleStep.CONFIRMATION);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Render based on current step\n  const renderContent = () => {\n    switch (currentStep) {\n      case RescheduleStep.LOADING:\n        return <div className=\"loading\">Loading meeting details...</div>;\n        \n      case RescheduleStep.CURRENT_DETAILS:\n        if (!currentMeeting) return null;\n        \n        return (\n          <div className=\"current-meeting\">\n            <h2>Current Meeting Details</h2>\n            <BookingConfirmation\n              meeting={currentMeeting}\n              showAddToCalendarOptions={false}\n            />\n            <div className=\"action-buttons\">\n              <button\n                className=\"primary-button\"\n                onClick={proceedToTimeSelection}\n              >\n                Select New Time\n              </button>\n              <button\n                className=\"secondary-button\"\n                onClick={onCancel}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        );\n        \n      case RescheduleStep.SELECT_NEW_TIME:\n        return (\n          <div className=\"select-new-time\">\n            <h2>Select New Meeting Time</h2>\n            <div className=\"time-selection-container\">\n              <div className=\"availability-section\">\n                <h3>Available Time Slots</h3>\n                <AvailabilityDisplay\n                  userId={userId}\n                  startDate={new Date()}\n                  numberOfDays={7}\n                  onSlotSelect={handleTimeSlotSelect}\n                  slotDuration={30}\n                  workingHours={{ start: '09:00', end: '17:00' }}\n                />\n              </div>\n              <div className=\"date-time-picker-section\">\n                <h3>Custom Date/Time</h3>\n                <DateTimePicker\n                  initialDate={new Date()}\n                  minDate={new Date()}\n                  availableTimeSlots={availabilitySlots}\n                  onChange={handleDateTimeChange}\n                />\n              </div>\n            </div>\n            \n            <div className=\"selected-time\">\n              {selectedTimeSlot && (\n                <div>\n                  <h3>Selected Time:</h3>\n                  <p>\n                    {selectedTimeSlot.startTime.toLocaleString()} - {selectedTimeSlot.endTime.toLocaleString()}\n                  </p>\n                </div>\n              )}\n            </div>\n            \n            <div className=\"action-buttons\">\n              <button\n                className=\"primary-button\"\n                onClick={handleReschedule}\n                disabled={!selectedTimeSlot || isLoading}\n              >\n                {isLoading ? 'Rescheduling...' : 'Confirm Reschedule'}\n              </button>\n              <button\n                className=\"secondary-button\"\n                onClick={() => setCurrentStep(RescheduleStep.CURRENT_DETAILS)}\n                disabled={isLoading}\n              >\n                Back\n              </button>\n            </div>\n          </div>\n        );\n        \n      case RescheduleStep.CONFIRMATION:\n        if (!newMeeting) return null;\n        \n        return (\n          <div className=\"reschedule-confirmation\">\n            <h2>Meeting Rescheduled</h2>\n            <p>Your meeting has been successfully rescheduled.</p>\n            <BookingConfirmation meeting={newMeeting} />\n            <button\n              className=\"primary-button\"\n              onClick={onComplete}\n            >\n              Done\n            </button>\n          </div>\n        );\n    }\n  };\n  \n  if (error) {\n    return (\n      <div className=\"error-container\">\n        <h2>Error</h2>\n        <p>{error}</p>\n        <button onClick={onCancel}>Back</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"reschedule-meeting-container\">\n      {renderContent()}\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test the complete rescheduling workflow\n2. Verify meeting details are correctly displayed\n3. Test availability fetching and display\n4. Verify time slot selection functionality\n5. Test rescheduling API integration\n6. Verify confirmation display with new meeting details"
          },
          {
            "id": 13,
            "title": "Integrate Calendar System with User Interface",
            "description": "Integrate all calendar components into a cohesive user interface, including scheduling pages, availability settings, and meeting management.",
            "dependencies": [
              "9.5",
              "9.9",
              "9.10",
              "9.11",
              "9.12"
            ],
            "details": "1. Create main scheduling page layout\n2. Implement user calendar settings page\n3. Create meeting management interface\n4. Add navigation between calendar components\n5. Implement responsive design for all screens\n6. Add loading states and error handling\n\nExample code:\n```typescript\n// pages/schedule/index.tsx\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport { DateTimePicker } from '../../components/DateTimePicker';\nimport { AvailabilityDisplay } from '../../components/AvailabilityDisplay';\nimport { BookingConfirmation } from '../../components/BookingConfirmation';\nimport { RescheduleMeeting } from '../../components/RescheduleMeeting';\nimport { getUserCalendarProviders } from '../../services/calendarService';\n\nenum ScheduleStep {\n  SELECT_DATE,\n  ENTER_DETAILS,\n  CONFIRMATION\n}\n\nconst SchedulePage: React.FC = () => {\n  const router = useRouter();\n  const { userId, rescheduleId } = router.query;\n  \n  const [currentStep, setCurrentStep] = useState<ScheduleStep>(ScheduleStep.SELECT_DATE);\n  const [selectedTimeSlot, setSelectedTimeSlot] = useState<{\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  } | null>(null);\n  const [meetingDetails, setMeetingDetails] = useState<{\n    title: string;\n    name: string;\n    email: string;\n    notes: string;\n  }>({ title: '', name: '', email: '', notes: '' });\n  const [createdMeeting, setCreatedMeeting] = useState<any>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [connectedCalendars, setConnectedCalendars] = useState<Array<{\n    type: 'google' | 'outlook';\n    email: string;\n  }>>([]);\n  \n  // Check if this is a reschedule\n  useEffect(() => {\n    if (rescheduleId) {\n      // Handle reschedule flow\n    }\n  }, [rescheduleId]);\n  \n  // Fetch connected calendars\n  useEffect(() => {\n    if (!userId) return;\n    \n    const fetchCalendars = async () => {\n      try {\n        const response = await fetch(`/api/users/${userId}/calendars`);\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch connected calendars');\n        }\n        \n        const data = await response.json();\n        setConnectedCalendars(data.calendars);\n      } catch (err) {\n        setError('Failed to load calendar connections');\n      }\n    };\n    \n    fetchCalendars();\n  }, [userId]);\n  \n  // Handle time slot selection\n  const handleTimeSlotSelect = (slot: {\n    start: Date;\n    end: Date;\n  }) => {\n    setSelectedTimeSlot({\n      startTime: slot.start,\n      endTime: slot.end,\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    });\n    setCurrentStep(ScheduleStep.ENTER_DETAILS);\n  };\n  \n  // Handle date/time selection from picker\n  const handleDateTimeChange = (selection: {\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  }) => {\n    setSelectedTimeSlot(selection);\n    setCurrentStep(ScheduleStep.ENTER_DETAILS);\n  };\n  \n  // Handle meeting details form submission\n  const handleDetailsSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!selectedTimeSlot || !userId) return;\n    \n    setIsLoading(true);\n    \n    try {\n      const response = await fetch('/api/meetings', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          hostUserId: userId,\n          title: meetingDetails.title,\n          startTime: selectedTimeSlot.startTime.toISOString(),\n          endTime: selectedTimeSlot.endTime.toISOString(),\n          timeZone: selectedTimeSlot.timeZone,\n          attendees: [meetingDetails.email],\n          notes: meetingDetails.notes,\n          guestName: meetingDetails.name\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to create meeting');\n      }\n      \n      const data = await response.json();\n      setCreatedMeeting({\n        ...data,\n        startTime: new Date(data.startTime),\n        endTime: new Date(data.endTime)\n      });\n      \n      setCurrentStep(ScheduleStep.CONFIRMATION);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Handle input changes\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    const { name, value } = e.target;\n    setMeetingDetails(prev => ({ ...prev, [name]: value }));\n  };\n  \n  // Render based on current step\n  const renderContent = () => {\n    switch (currentStep) {\n      case ScheduleStep.SELECT_DATE:\n        return (\n          <div className=\"select-date-container\">\n            <h1>Schedule a Meeting</h1>\n            \n            {connectedCalendars.length === 0 ? (\n              <div className=\"no-calendars\">\n                <p>No calendars connected. Please connect a calendar to continue.</p>\n                <button onClick={() => router.push(`/settings/calendars?userId=${userId}`)}>\n                  Connect Calendar\n                </button>\n              </div>\n            ) : (\n              <>\n                <div className=\"availability-section\">\n                  <h2>Select a Time Slot</h2>\n                  <AvailabilityDisplay\n                    userId={userId as string}\n                    startDate={new Date()}\n                    numberOfDays={7}\n                    onSlotSelect={handleTimeSlotSelect}\n                    slotDuration={30}\n                    workingHours={{ start: '09:00', end: '17:00' }}\n                  />\n                </div>\n                \n                <div className=\"date-time-picker-section\">\n                  <h2>Or Choose a Custom Time</h2>\n                  <DateTimePicker\n                    initialDate={new Date()}\n                    minDate={new Date()}\n                    onChange={handleDateTimeChange}\n                  />\n                </div>\n              </>\n            )}\n          </div>\n        );\n        \n      case ScheduleStep.ENTER_DETAILS:\n        if (!selectedTimeSlot) return null;\n        \n        return (\n          <div className=\"enter-details-container\">\n            <h1>Meeting Details</h1>\n            \n            <div className=\"selected-time-info\">\n              <h3>Selected Time:</h3>\n              <p>\n                {selectedTimeSlot.startTime.toLocaleString(undefined, {\n                  weekday: 'long',\n                  year: 'numeric',\n                  month: 'long',\n                  day: 'numeric',\n                  hour: 'numeric',\n                  minute: '2-digit'\n                })}\n                {' - '}\n                {selectedTimeSlot.endTime.toLocaleString(undefined, {\n                  hour: 'numeric',\n                  minute: '2-digit'\n                })}\n              </p>\n            </div>\n            \n            <form onSubmit={handleDetailsSubmit} className=\"meeting-details-form\">\n              <div className=\"form-group\">\n                <label htmlFor=\"title\">Meeting Title</label>\n                <input\n                  type=\"text\"\n                  id=\"title\"\n                  name=\"title\"\n                  value={meetingDetails.title}\n                  onChange={handleInputChange}\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"name\">Your Name</label>\n                <input\n                  type=\"text\"\n                  id=\"name\"\n                  name=\"name\"\n                  value={meetingDetails.name}\n                  onChange={handleInputChange}\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"email\">Your Email</label>\n                <input\n                  type=\"email\"\n                  id=\"email\"\n                  name=\"email\"\n                  value={meetingDetails.email}\n                  onChange={handleInputChange}\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"notes\">Additional Notes</label>\n                <textarea\n                  id=\"notes\"\n                  name=\"notes\"\n                  value={meetingDetails.notes}\n                  onChange={handleInputChange}\n                  rows={4}\n                />\n              </div>\n              \n              <div className=\"form-actions\">\n                <button\n                  type=\"button\"\n                  className=\"back-button\"\n                  onClick={() => setCurrentStep(ScheduleStep.SELECT_DATE)}\n                >\n                  Back\n                </button>\n                <button\n                  type=\"submit\"\n                  className=\"schedule-button\"\n                  disabled={isLoading}\n                >\n                  {isLoading ? 'Scheduling...' : 'Schedule Meeting'}\n                </button>\n              </div>\n            </form>\n          </div>\n        );\n        \n      case ScheduleStep.CONFIRMATION:\n        if (!createdMeeting) return null;\n        \n        return (\n          <div className=\"confirmation-container\">\n            <BookingConfirmation meeting={createdMeeting} />\n          </div>\n        );\n    }\n  };\n  \n  // Handle reschedule mode\n  if (rescheduleId) {\n    return (\n      <div className=\"schedule-page reschedule-mode\">\n        <RescheduleMeeting\n          meetingId={rescheduleId as string}\n          userId={userId as string}\n          onComplete={() => router.push('/meetings')}\n          onCancel={() => router.push('/meetings')}\n        />\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div className=\"error-container\">\n        <h2>Error</h2>\n        <p>{error}</p>\n        <button onClick={() => setError(null)}>Try Again</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"schedule-page\">\n      {renderContent()}\n    </div>\n  );\n};\n\nexport default SchedulePage;\n```",
            "status": "pending",
            "testStrategy": "1. Test the complete scheduling workflow\n2. Verify calendar connection handling\n3. Test availability display and time slot selection\n4. Verify meeting details form submission\n5. Test confirmation display\n6. Verify rescheduling integration\n7. Test responsive layout on different screen sizes"
          }
        ]
      },
      {
        "id": 10,
        "title": "Prospect Booking Experience",
        "description": "Create the prospect-facing booking experience with magic links, advocate profiles, and one-click scheduling.",
        "details": "1. Implement magic link generation and validation:\n```typescript\n// services/bookingLinkService.ts\nexport const generateMagicLink = async (opportunityId: string, advocateId: string) => {\n  // Generate unique token\n  const token = generateUniqueToken()\n  \n  // Store token with expiration\n  await storeMagicLinkToken(token, { opportunityId, advocateId })\n  \n  // Generate full URL\n  return `${process.env.NEXT_PUBLIC_APP_URL}/booking/${token}`\n}\n\nexport const validateMagicLink = async (token: string) => {\n  // Retrieve and validate token\n  const linkData = await getMagicLinkData(token)\n  \n  if (!linkData || isExpired(linkData.expiresAt)) {\n    throw new Error('Invalid or expired booking link')\n  }\n  \n  return linkData\n}\n```\n2. Create public-facing booking pages:\n   - Advocate profile display\n   - Availability calendar\n   - Booking confirmation\n3. Implement prospect data collection:\n   - Basic contact information\n   - Meeting preferences\n4. Build the booking confirmation flow:\n   - Email confirmation\n   - Calendar invitation\n   - Preparation materials\n5. Create meeting reminder system\n6. Implement analytics tracking for booking conversion",
        "testStrategy": "Test magic link generation and validation with various scenarios. Verify the booking flow from prospect perspective. Test email deliverability for confirmations. Ensure calendar invitations are correctly formatted. Test with different browsers and devices to verify responsive design.",
        "priority": "high",
        "dependencies": [
          6,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Reference Call Management System",
        "description": "Implement the reference call management system for tracking, recording, and analyzing customer reference calls.",
        "details": "1. Create reference call data models and interfaces:\n   - Call list view with filtering and search\n   - Call details view\n   - Call scheduling and management\n2. Implement call recording integration:\n   - Zoom API integration\n   - Microsoft Teams integration\n   - Recording storage and access control\n3. Build pre-call preparation workflow:\n   - Context sharing for advocates\n   - Talking points generation\n   - Prospect information sharing\n4. Create post-call feedback collection:\n```typescript\n// components/PostCallFeedback.tsx\nconst PostCallFeedback = ({ callId }: { callId: string }) => {\n  const [feedback, setFeedback] = useState({\n    effectiveness: 0,\n    topics: [],\n    notes: '',\n  })\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault()\n    await submitCallFeedback(callId, feedback)\n    // Show success message\n  }\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Feedback form fields */}\n    </form>\n  )\n}\n```\n5. Implement call status tracking and reporting\n6. Create notification system for call events",
        "testStrategy": "Test call creation and management workflows. Verify recording integration with mock API responses. Test feedback collection and storage. Ensure proper access controls for call recordings. Verify notification delivery for call events.",
        "priority": "medium",
        "dependencies": [
          6,
          9,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create reference call data models and interfaces",
            "description": "Define the data models and TypeScript interfaces for reference calls, including all necessary properties for tracking, scheduling, and managing calls.",
            "dependencies": [],
            "details": "Create a new file `types/referenceCall.ts` with interfaces for ReferenceCall, CallParticipant, CallStatus, and related types. Include properties for call ID, title, description, scheduled date/time, duration, status, participants (advocates, prospects), recording URLs, and associated metadata. Ensure models support the requirements for filtering, searching, and reporting.",
            "status": "pending",
            "testStrategy": "Create unit tests to validate type definitions and ensure they meet all requirements for the call management system."
          },
          {
            "id": 2,
            "title": "Implement reference call API services",
            "description": "Create service functions for CRUD operations on reference calls, including creating, retrieving, updating, and deleting calls.",
            "dependencies": [
              "11.1"
            ],
            "details": "Create `services/referenceCallService.ts` with functions for createCall, getCall, updateCall, deleteCall, listCalls, and searchCalls. Implement proper error handling and response typing. Ensure the service functions handle pagination for list operations and support filtering by various call properties.",
            "status": "pending",
            "testStrategy": "Write unit tests with mock API responses to verify each service function correctly handles success and error cases."
          },
          {
            "id": 3,
            "title": "Build call list view component with filtering and search",
            "description": "Create a component to display a list of reference calls with filtering, sorting, and search capabilities.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `components/calls/CallListView.tsx` that displays reference calls in a table or card format. Implement filters for call status, date range, advocate, and other relevant properties. Add search functionality that filters across call titles, descriptions, and participant information. Include pagination for large result sets and sorting options for columns.",
            "status": "pending",
            "testStrategy": "Test component rendering with various data sets. Verify filter and search functionality works correctly. Test pagination and sorting behavior."
          },
          {
            "id": 4,
            "title": "Implement call details view component",
            "description": "Create a component to display detailed information about a specific reference call, including participants, status, and related actions.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `components/calls/CallDetailsView.tsx` that shows comprehensive information about a call, including scheduling details, participants, status, and any recordings. Include action buttons for editing, canceling, or rescheduling calls. Display call preparation materials and post-call feedback if available.",
            "status": "pending",
            "testStrategy": "Test component rendering with various call states (scheduled, completed, canceled). Verify all actions function correctly and appropriate information is displayed based on call status."
          },
          {
            "id": 5,
            "title": "Develop call scheduling and management interface",
            "description": "Create the interface for scheduling new calls and managing existing ones, including date/time selection and participant assignment.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "Create `components/calls/CallSchedulingForm.tsx` with form fields for call title, description, date/time selection, duration, and participant selection. Integrate with the calendar system (Task 9) to show available time slots. Include functionality to send invitations to participants and update calendar events when call details change.",
            "status": "pending",
            "testStrategy": "Test form validation and submission. Verify integration with calendar system works correctly. Test participant selection and invitation process."
          },
          {
            "id": 6,
            "title": "Implement Zoom API integration for call recording",
            "description": "Integrate with Zoom API to create meetings, generate join links, and capture recordings for reference calls.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `services/integrations/zoomService.ts` with functions to create Zoom meetings, generate participant links, start/stop recordings, and retrieve recording URLs. Implement OAuth flow for Zoom authentication if needed. Ensure proper error handling for API failures.",
            "status": "pending",
            "testStrategy": "Test Zoom API integration with mock responses. Verify meeting creation, link generation, and recording retrieval work correctly. Test error handling for various failure scenarios."
          },
          {
            "id": 7,
            "title": "Implement Microsoft Teams integration for call recording",
            "description": "Integrate with Microsoft Teams API to create meetings, generate join links, and capture recordings for reference calls.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `services/integrations/teamsService.ts` with functions to create Teams meetings, generate participant links, manage recordings, and retrieve recording URLs. Implement Microsoft Graph API authentication. Handle Teams-specific meeting properties and recording formats.",
            "status": "pending",
            "testStrategy": "Test Teams API integration with mock responses. Verify meeting creation, link generation, and recording retrieval work correctly. Test authentication flow and error handling."
          },
          {
            "id": 8,
            "title": "Develop recording storage and access control system",
            "description": "Implement secure storage for call recordings with appropriate access controls and retention policies.",
            "dependencies": [
              "11.6",
              "11.7"
            ],
            "details": "Create `services/recordingService.ts` to handle storage of recording metadata and secure access to recording files. Implement access control based on user roles and permissions. Set up secure URLs with expiration for accessing recordings. Define retention policies for recordings based on company settings.",
            "status": "pending",
            "testStrategy": "Test recording storage and retrieval with various file types. Verify access controls prevent unauthorized access. Test URL generation and expiration functionality."
          },
          {
            "id": 9,
            "title": "Build pre-call preparation workflow for advocates",
            "description": "Create the workflow for advocates to prepare for reference calls, including context sharing and talking points.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.4"
            ],
            "details": "Create `components/calls/PreCallPreparation.tsx` with sections for call context, prospect information, and talking points. Implement functionality for advocates to review and add preparation materials. Include a checklist of preparation tasks and status tracking.",
            "status": "pending",
            "testStrategy": "Test preparation workflow with various call scenarios. Verify information is correctly displayed and saved. Test checklist functionality and status updates."
          },
          {
            "id": 10,
            "title": "Implement talking points generation system",
            "description": "Create a system for generating and managing talking points for reference calls based on advocate experience and prospect interests.",
            "dependencies": [
              "11.9"
            ],
            "details": "Create `services/talkingPointsService.ts` to generate suggested talking points based on advocate profile, prospect information, and historical call data. Implement functionality for manual addition, editing, and organization of talking points. Include categorization and prioritization of talking points.",
            "status": "pending",
            "testStrategy": "Test talking points generation with various advocate and prospect profiles. Verify manual editing and organization functions work correctly."
          },
          {
            "id": 11,
            "title": "Develop prospect information sharing component",
            "description": "Create a component for sharing relevant prospect information with advocates before calls.",
            "dependencies": [
              "11.9"
            ],
            "details": "Create `components/calls/ProspectInformation.tsx` to display key information about prospects, including company details, use case interests, and specific questions or concerns. Implement controls for what information is shared with advocates based on privacy settings.",
            "status": "pending",
            "testStrategy": "Test component with various prospect profiles. Verify privacy controls work correctly. Test information display and formatting."
          },
          {
            "id": 12,
            "title": "Complete post-call feedback collection component",
            "description": "Finish implementing the post-call feedback collection component for gathering insights after calls.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.4"
            ],
            "details": "Complete the `components/PostCallFeedback.tsx` component started in the task description. Add form fields for effectiveness rating, topics discussed, and notes. Implement validation and submission logic. Add success/error messaging and state management.",
            "status": "pending",
            "testStrategy": "Test form validation and submission. Verify feedback is correctly stored and associated with the call. Test error handling and success messaging."
          },
          {
            "id": 13,
            "title": "Implement call status tracking system",
            "description": "Create a system for tracking and updating the status of reference calls throughout their lifecycle.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `services/callStatusService.ts` with functions to update and track call status (scheduled, in-progress, completed, canceled, etc.). Implement automatic status updates based on time and manual updates based on user actions. Include status history tracking for audit purposes.",
            "status": "pending",
            "testStrategy": "Test status transitions with various scenarios. Verify automatic and manual status updates work correctly. Test status history tracking and reporting."
          },
          {
            "id": 14,
            "title": "Build call reporting and analytics dashboard",
            "description": "Create a dashboard for reporting and analyzing reference call data, including metrics and trends.",
            "dependencies": [
              "11.13",
              "11.12"
            ],
            "details": "Create `components/calls/CallAnalyticsDashboard.tsx` with visualizations for call volume, effectiveness ratings, common topics, and other relevant metrics. Implement filters for date ranges, advocates, and call types. Include export functionality for reports.",
            "status": "pending",
            "testStrategy": "Test dashboard rendering with various data sets. Verify filters and calculations work correctly. Test export functionality and data formatting."
          },
          {
            "id": 15,
            "title": "Implement notification system for call events",
            "description": "Create a notification system for call-related events such as scheduling, reminders, and status changes.",
            "dependencies": [
              "11.13"
            ],
            "details": "Create `services/callNotificationService.ts` to generate and send notifications for call events. Implement different notification types (email, in-app, calendar) based on event type and user preferences. Set up scheduling for reminder notifications before calls.",
            "status": "pending",
            "testStrategy": "Test notification generation and delivery for various event types. Verify reminders are sent at the correct times. Test user preference handling for notification types."
          },
          {
            "id": 16,
            "title": "Integrate call system with calendar services",
            "description": "Integrate the reference call system with the calendar integration from Task 9 for scheduling and availability management.",
            "dependencies": [
              "11.5",
              "11.15"
            ],
            "details": "Modify the call scheduling components and services to use the calendar integration from Task 9. Implement availability checking before scheduling calls. Ensure calendar events are created, updated, and deleted in sync with call management actions.",
            "status": "pending",
            "testStrategy": "Test integration with calendar services for scheduling, rescheduling, and cancellation. Verify availability checking prevents scheduling conflicts."
          }
        ]
      },
      {
        "id": 12,
        "title": "Call Intelligence Engine",
        "description": "Develop the AI-powered call intelligence engine that analyzes reference call recordings and extracts key insights.",
        "details": "1. Implement call recording processing pipeline:\n   - Audio extraction from video recordings\n   - Transcription service integration\n   - Text preprocessing for analysis\n2. Create OpenAI integration for analysis:\n```typescript\n// services/callIntelligenceService.ts\nexport const analyzeCallTranscript = async (callId: string, transcript: string) => {\n  // Prepare analysis prompt\n  const prompt = generateAnalysisPrompt(transcript)\n  \n  // Call OpenAI for analysis\n  const { data } = await openai.createCompletion({\n    model: \"gpt-4\",\n    prompt,\n    // Other parameters\n  })\n  \n  // Process and structure the insights\n  const insights = processAnalysisResponse(data)\n  \n  // Store insights in database\n  await storeCallInsights(callId, insights)\n  \n  return insights\n}\n\nfunction processAnalysisResponse(response) {\n  return {\n    competitive_intel: extractCompetitiveIntel(response),\n    objections: extractObjections(response),\n    success_factors: extractSuccessFactors(response),\n    prospect_sentiment: extractSentiment(response),\n    next_steps: extractNextSteps(response)\n  }\n}\n```\n3. Implement insight extraction for key categories:\n   - Competitive mentions\n   - Objections raised\n   - Success factors highlighted\n   - Next steps identified\n4. Create CRM integration for insight sharing\n5. Build insights visualization dashboard\n6. Implement trend analysis across multiple calls",
        "testStrategy": "Test transcription accuracy with sample recordings. Verify insight extraction with various conversation scenarios. Test CRM integration for insight sharing. Measure analysis quality with human-validated results. Verify trend analysis with historical data.",
        "priority": "medium",
        "dependencies": [
          7,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Audio Extraction from Video Recordings",
            "description": "Create a service to extract audio from video call recordings for further processing",
            "dependencies": [],
            "details": "Create a utility service that uses ffmpeg or a similar library to extract audio tracks from video recordings. The service should accept video file paths or URLs and output audio files in a format suitable for transcription (e.g., MP3 or WAV). Include error handling for corrupted files and logging for processing status.",
            "status": "pending",
            "testStrategy": "Test with various video formats (MP4, WebM, etc.) and verify audio extraction quality. Ensure proper error handling for corrupted files."
          },
          {
            "id": 2,
            "title": "Integrate Transcription Service",
            "description": "Implement integration with a speech-to-text service to transcribe call recordings",
            "dependencies": [
              "12.1"
            ],
            "details": "Integrate with a transcription service (e.g., AWS Transcribe, Google Speech-to-Text) to convert audio to text. Create a service that accepts audio files, sends them to the transcription API, and retrieves the text results. Include speaker diarization if supported by the chosen service to distinguish between different speakers in the conversation.",
            "status": "pending",
            "testStrategy": "Test with sample audio files of varying quality and accents. Verify transcription accuracy and proper speaker identification."
          },
          {
            "id": 3,
            "title": "Implement Text Preprocessing Pipeline",
            "description": "Create a preprocessing pipeline to clean and structure transcription text for analysis",
            "dependencies": [
              "12.2"
            ],
            "details": "Develop a text preprocessing service that cleans and structures the raw transcription text. This should include removing filler words, normalizing text, segmenting by speaker, and formatting the text for optimal analysis by the AI model. The output should be structured in a way that preserves conversation flow and speaker identification.",
            "status": "pending",
            "testStrategy": "Test with various transcription outputs to ensure proper cleaning and structuring. Verify that important context is preserved."
          },
          {
            "id": 4,
            "title": "Create Analysis Prompt Generator",
            "description": "Implement a function to generate effective prompts for OpenAI based on call transcripts",
            "dependencies": [
              "12.3"
            ],
            "details": "Implement the `generateAnalysisPrompt` function that creates structured prompts for OpenAI. The prompt should guide the model to extract specific insights like competitive intelligence, objections, success factors, sentiment, and next steps. Include clear instructions and examples in the prompt to improve analysis quality.",
            "status": "pending",
            "testStrategy": "Test with different transcript samples to ensure prompts effectively guide the AI to extract relevant insights."
          },
          {
            "id": 5,
            "title": "Implement OpenAI Integration Service",
            "description": "Create a service to handle communication with OpenAI API for transcript analysis",
            "dependencies": [
              "12.4"
            ],
            "details": "Implement the core OpenAI integration service that sends prompts to the API and receives responses. This should include proper error handling, retry logic, and response validation. Configure appropriate model parameters (temperature, max tokens, etc.) for optimal analysis results.",
            "status": "pending",
            "testStrategy": "Test API integration with various transcript lengths. Verify error handling and retry logic. Measure response times and optimize as needed."
          },
          {
            "id": 6,
            "title": "Develop Competitive Intelligence Extraction",
            "description": "Create a function to extract competitive intelligence mentions from AI responses",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractCompetitiveIntel` function to parse OpenAI responses and identify mentions of competitors, competitive features, and market positioning. The function should structure this information in a consistent format for storage and display.",
            "status": "pending",
            "testStrategy": "Test with responses containing various competitor mentions. Verify accurate extraction and proper formatting of competitive intelligence."
          },
          {
            "id": 7,
            "title": "Implement Objections Extraction",
            "description": "Create a function to identify and categorize objections raised during calls",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractObjections` function to identify customer objections, concerns, and hesitations from the AI analysis. The function should categorize objections (e.g., price, features, implementation) and include context around how they were addressed.",
            "status": "pending",
            "testStrategy": "Test with transcripts containing various types of objections. Verify proper categorization and context preservation."
          },
          {
            "id": 8,
            "title": "Develop Success Factors Extraction",
            "description": "Create a function to identify key success factors and positive signals from calls",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractSuccessFactors` function to identify positive signals, features that resonated with prospects, and other success indicators from the AI analysis. The function should structure these insights for easy consumption by sales teams.",
            "status": "pending",
            "testStrategy": "Test with transcripts containing various positive signals. Verify accurate identification of success factors."
          },
          {
            "id": 9,
            "title": "Implement Sentiment Analysis Extraction",
            "description": "Create a function to extract and quantify prospect sentiment from AI responses",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractSentiment` function to analyze the overall sentiment of the prospect throughout the call. This should include sentiment trends (how sentiment changed during the call) and key moments that influenced sentiment shifts.",
            "status": "pending",
            "testStrategy": "Test with transcripts showing various sentiment patterns. Verify accurate sentiment assessment and identification of sentiment shifts."
          },
          {
            "id": 10,
            "title": "Develop Next Steps Extraction",
            "description": "Create a function to identify and structure next steps mentioned in calls",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractNextSteps` function to identify action items, follow-ups, and commitments made during the call. The function should structure these as actionable items with relevant context and potential due dates if mentioned.",
            "status": "pending",
            "testStrategy": "Test with transcripts containing various types of next steps and commitments. Verify accurate extraction and proper formatting."
          },
          {
            "id": 11,
            "title": "Implement Database Storage for Call Insights",
            "description": "Create a service to store and retrieve call analysis insights in the database",
            "dependencies": [
              "12.6",
              "12.7",
              "12.8",
              "12.9",
              "12.10"
            ],
            "details": "Implement the `storeCallInsights` function to save structured insights to the database. Design appropriate database schema to store different types of insights with relationships to calls, opportunities, and advocates. Include indexing for efficient querying of insights.",
            "status": "pending",
            "testStrategy": "Test storage and retrieval of various insight types. Verify proper relationships and query performance."
          },
          {
            "id": 12,
            "title": "Create CRM Integration for Insight Sharing",
            "description": "Implement integration with CRM systems to share call insights with sales teams",
            "dependencies": [
              "12.11"
            ],
            "details": "Develop a service to push relevant call insights to CRM systems (e.g., Salesforce, HubSpot). This should include mapping insights to appropriate CRM fields, creating activities or notes, and ensuring proper attribution. Implement authentication and API integration with major CRM providers.",
            "status": "pending",
            "testStrategy": "Test integration with different CRM systems. Verify proper data mapping and synchronization. Test error handling for API failures."
          },
          {
            "id": 13,
            "title": "Build Insights Visualization Dashboard",
            "description": "Create a dashboard to visualize call insights in an actionable format",
            "dependencies": [
              "12.11"
            ],
            "details": "Develop a frontend dashboard to display call insights in a visual, actionable format. Include charts for sentiment analysis, tables for competitive mentions and objections, and summaries of key insights. Implement filtering and sorting capabilities to help users find relevant insights.",
            "status": "pending",
            "testStrategy": "Test dashboard with various insight datasets. Verify proper visualization and interactive features. Test responsiveness on different devices."
          },
          {
            "id": 14,
            "title": "Implement Multi-Call Trend Analysis",
            "description": "Create functionality to analyze trends across multiple calls for the same opportunity or advocate",
            "dependencies": [
              "12.11"
            ],
            "details": "Develop a service to analyze trends across multiple calls, identifying patterns in objections, competitive mentions, and sentiment over time. Create aggregation functions to summarize insights across calls and visualize changes over time.",
            "status": "pending",
            "testStrategy": "Test with datasets containing multiple related calls. Verify accurate trend identification and meaningful aggregation of insights."
          }
        ]
      },
      {
        "id": 13,
        "title": "Rewards Engine",
        "description": "Implement the compliance-first rewards engine for advocate recognition, including charitable donations, professional development funds, and direct stipends.",
        "details": "1. Create reward data models and interfaces:\n   - Reward options management\n   - Reward history tracking\n   - Reward fulfillment status\n2. Implement reward types:\n   - Charitable donations integration\n   - Professional development fund management\n   - Direct stipend processing\n   - Company credits/team rewards\n3. Build reward selection and fulfillment flow:\n```typescript\n// services/rewardsService.ts\nexport const getAvailableRewards = async (companyId: string) => {\n  const { data, error } = await supabase\n    .from('reward_options')\n    .select('*')\n    .eq('company_id', companyId)\n    .eq('active', true)\n  \n  if (error) throw error\n  return data\n}\n\nexport const processReward = async (advocateId: string, callId: string, rewardOption: RewardOption) => {\n  // Create reward record\n  const reward = await createRewardRecord(advocateId, callId, rewardOption)\n  \n  // Process based on reward type\n  switch (rewardOption.type) {\n    case 'charity':\n      return processCharitableDonation(reward)\n    case 'development_fund':\n      return processDevelopmentFund(reward)\n    case 'stipend':\n      return processStipend(reward)\n    // Other reward types\n  }\n}\n```\n4. Implement tax documentation generation (1099 forms)\n5. Create reward tracking and reporting\n6. Build advocate reward history view\n7. Implement compliance checks and approvals workflow",
        "testStrategy": "Test reward selection and processing for different reward types. Verify tax documentation generation. Test compliance checks with various scenarios. Ensure proper tracking and reporting of rewards. Verify advocate reward history display.",
        "priority": "medium",
        "dependencies": [
          3,
          6,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Reward Data Models and Database Schema",
            "description": "Design and implement the database schema for the rewards engine, including tables for reward options, reward history, and fulfillment status.",
            "dependencies": [],
            "details": "Create SQL migrations for the following tables:\n1. `reward_options` - Store available reward types for each company\n2. `reward_history` - Track all reward transactions\n3. `reward_fulfillment` - Track the status of reward processing\n\nExample SQL:\n```sql\nCREATE TABLE reward_options (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID NOT NULL REFERENCES companies(id),\n  name TEXT NOT NULL,\n  description TEXT,\n  type TEXT NOT NULL CHECK (type IN ('charity', 'development_fund', 'stipend', 'company_credit')),\n  amount DECIMAL(10,2) NOT NULL,\n  active BOOLEAN DEFAULT true,\n  tax_implications BOOLEAN DEFAULT false,\n  settings JSONB DEFAULT '{}',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE TABLE reward_history (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  advocate_id UUID NOT NULL REFERENCES users(id),\n  call_id UUID REFERENCES calls(id),\n  reward_option_id UUID NOT NULL REFERENCES reward_options(id),\n  amount DECIMAL(10,2) NOT NULL,\n  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),\n  processed_at TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE TABLE reward_fulfillment (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  reward_id UUID NOT NULL REFERENCES reward_history(id),\n  processor_type TEXT NOT NULL,\n  processor_id TEXT,\n  status TEXT NOT NULL DEFAULT 'pending',\n  details JSONB DEFAULT '{}',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n\nAdd appropriate indexes and RLS policies to ensure data security.",
            "status": "pending",
            "testStrategy": "Write SQL queries to test the schema integrity, relationships, and constraints. Verify that the tables properly enforce data validation rules like reward types."
          },
          {
            "id": 2,
            "title": "Implement TypeScript Interfaces for Reward Models",
            "description": "Create TypeScript interfaces and types for all reward-related data structures to ensure type safety throughout the application.",
            "dependencies": [
              "13.1"
            ],
            "details": "Create a new file `types/rewards.ts` with the following interfaces:\n\n```typescript\nexport type RewardType = 'charity' | 'development_fund' | 'stipend' | 'company_credit';\n\nexport interface RewardOption {\n  id: string;\n  company_id: string;\n  name: string;\n  description?: string;\n  type: RewardType;\n  amount: number;\n  active: boolean;\n  tax_implications: boolean;\n  settings: Record<string, any>;\n  created_at: string;\n  updated_at: string;\n}\n\nexport type RewardStatus = 'pending' | 'processing' | 'completed' | 'failed';\n\nexport interface RewardHistory {\n  id: string;\n  advocate_id: string;\n  call_id?: string;\n  reward_option_id: string;\n  amount: number;\n  status: RewardStatus;\n  processed_at?: string;\n  created_at: string;\n  updated_at: string;\n  reward_option?: RewardOption;\n  fulfillment?: RewardFulfillment;\n}\n\nexport interface RewardFulfillment {\n  id: string;\n  reward_id: string;\n  processor_type: string;\n  processor_id?: string;\n  status: string;\n  details: Record<string, any>;\n  created_at: string;\n  updated_at: string;\n}\n```",
            "status": "pending",
            "testStrategy": "Verify type compatibility with sample data from the database. Ensure interfaces are comprehensive and match the database schema."
          },
          {
            "id": 3,
            "title": "Create Reward Options Management Service",
            "description": "Implement a service for managing reward options, including CRUD operations for company administrators to configure available rewards.",
            "dependencies": [
              "13.2"
            ],
            "details": "Create a new file `services/rewardOptionsService.ts` with the following functions:\n\n```typescript\nimport { supabase } from '../lib/supabaseClient';\nimport { RewardOption, RewardType } from '../types/rewards';\n\nexport const getRewardOptions = async (companyId: string, includeInactive = false): Promise<RewardOption[]> => {\n  const query = supabase\n    .from('reward_options')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (!includeInactive) {\n    query.eq('active', true);\n  }\n  \n  const { data, error } = await query;\n  if (error) throw error;\n  return data as RewardOption[];\n};\n\nexport const getRewardOptionById = async (id: string): Promise<RewardOption> => {\n  const { data, error } = await supabase\n    .from('reward_options')\n    .select('*')\n    .eq('id', id)\n    .single();\n  \n  if (error) throw error;\n  return data as RewardOption;\n};\n\nexport const createRewardOption = async (rewardOption: Omit<RewardOption, 'id' | 'created_at' | 'updated_at'>): Promise<RewardOption> => {\n  const { data, error } = await supabase\n    .from('reward_options')\n    .insert(rewardOption)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as RewardOption;\n};\n\nexport const updateRewardOption = async (id: string, updates: Partial<RewardOption>): Promise<RewardOption> => {\n  const { data, error } = await supabase\n    .from('reward_options')\n    .update({ ...updates, updated_at: new Date().toISOString() })\n    .eq('id', id)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as RewardOption;\n};\n\nexport const toggleRewardOptionActive = async (id: string, active: boolean): Promise<RewardOption> => {\n  return updateRewardOption(id, { active });\n};\n```",
            "status": "pending",
            "testStrategy": "Test each CRUD operation with valid and invalid data. Verify that reward options are properly filtered by company_id and active status."
          },
          {
            "id": 4,
            "title": "Implement Reward History Tracking Service",
            "description": "Create a service for tracking and querying reward history, including filtering by advocate, status, and date range.",
            "dependencies": [
              "13.2"
            ],
            "details": "Create a new file `services/rewardHistoryService.ts` with the following functions:\n\n```typescript\nimport { supabase } from '../lib/supabaseClient';\nimport { RewardHistory, RewardStatus } from '../types/rewards';\n\nexport const getRewardHistory = async (filters: {\n  company_id?: string;\n  advocate_id?: string;\n  status?: RewardStatus;\n  start_date?: string;\n  end_date?: string;\n}): Promise<RewardHistory[]> => {\n  let query = supabase\n    .from('reward_history')\n    .select(`\n      *,\n      reward_option:reward_option_id(*),\n      fulfillment:id(reward_fulfillment(*))\n    `);\n  \n  if (filters.company_id) {\n    query = query.eq('reward_option.company_id', filters.company_id);\n  }\n  \n  if (filters.advocate_id) {\n    query = query.eq('advocate_id', filters.advocate_id);\n  }\n  \n  if (filters.status) {\n    query = query.eq('status', filters.status);\n  }\n  \n  if (filters.start_date) {\n    query = query.gte('created_at', filters.start_date);\n  }\n  \n  if (filters.end_date) {\n    query = query.lte('created_at', filters.end_date);\n  }\n  \n  const { data, error } = await query;\n  if (error) throw error;\n  return data as unknown as RewardHistory[];\n};\n\nexport const getRewardById = async (id: string): Promise<RewardHistory> => {\n  const { data, error } = await supabase\n    .from('reward_history')\n    .select(`\n      *,\n      reward_option:reward_option_id(*),\n      fulfillment:id(reward_fulfillment(*))\n    `)\n    .eq('id', id)\n    .single();\n  \n  if (error) throw error;\n  return data as unknown as RewardHistory;\n};\n\nexport const createRewardRecord = async (\n  advocate_id: string,\n  reward_option_id: string,\n  amount: number,\n  call_id?: string\n): Promise<RewardHistory> => {\n  const { data, error } = await supabase\n    .from('reward_history')\n    .insert({\n      advocate_id,\n      reward_option_id,\n      amount,\n      call_id,\n      status: 'pending'\n    })\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as RewardHistory;\n};\n\nexport const updateRewardStatus = async (id: string, status: RewardStatus, processed_at?: string): Promise<RewardHistory> => {\n  const updates: Partial<RewardHistory> = { \n    status, \n    updated_at: new Date().toISOString() \n  };\n  \n  if (status === 'completed' && !processed_at) {\n    updates.processed_at = new Date().toISOString();\n  } else if (processed_at) {\n    updates.processed_at = processed_at;\n  }\n  \n  const { data, error } = await supabase\n    .from('reward_history')\n    .update(updates)\n    .eq('id', id)\n    .select()\n    .single();\n  \n  if (error) throw error;\n  return data as RewardHistory;\n};\n```",
            "status": "pending",
            "testStrategy": "Test reward history retrieval with various filter combinations. Verify that status updates correctly modify the processed_at timestamp when appropriate."
          },
          {
            "id": 5,
            "title": "Implement Charitable Donation Processor",
            "description": "Create a service to process charitable donations, including integration with donation platforms or manual tracking for finance team fulfillment.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Create a new file `services/rewardProcessors/charitableDonationProcessor.ts` with the following implementation:\n\n```typescript\nimport { RewardHistory, RewardFulfillment } from '../../types/rewards';\nimport { supabase } from '../../lib/supabaseClient';\nimport { updateRewardStatus } from '../rewardHistoryService';\n\nexport const processCharitableDonation = async (reward: RewardHistory): Promise<RewardFulfillment> => {\n  try {\n    // Create fulfillment record\n    const { data: fulfillment, error } = await supabase\n      .from('reward_fulfillment')\n      .insert({\n        reward_id: reward.id,\n        processor_type: 'charity',\n        status: 'pending',\n        details: {\n          charity_name: reward.reward_option?.settings?.charity_name || 'Unspecified',\n          donation_reference: `DON-${reward.id.substring(0, 8)}`,\n          notes: 'Pending finance team processing'\n        }\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    \n    // Update reward status to processing\n    await updateRewardStatus(reward.id, 'processing');\n    \n    // In a real implementation, you might:\n    // 1. Call an external donation API\n    // 2. Send notification to finance team\n    // 3. Create a task in a workflow system\n    \n    // For now, we'll just return the fulfillment record\n    return fulfillment as RewardFulfillment;\n  } catch (error) {\n    console.error('Error processing charitable donation:', error);\n    await updateRewardStatus(reward.id, 'failed');\n    throw error;\n  }\n};\n\nexport const completeCharitableDonation = async (\n  fulfillment_id: string,\n  details: {\n    confirmation_number?: string;\n    processed_by?: string;\n    notes?: string;\n  }\n): Promise<RewardFulfillment> => {\n  // Get the fulfillment record\n  const { data: fulfillment, error: fetchError } = await supabase\n    .from('reward_fulfillment')\n    .select('*, reward:reward_id(*)')\n    .eq('id', fulfillment_id)\n    .single();\n  \n  if (fetchError) throw fetchError;\n  \n  // Update the fulfillment record\n  const { data: updatedFulfillment, error: updateError } = await supabase\n    .from('reward_fulfillment')\n    .update({\n      status: 'completed',\n      processor_id: details.confirmation_number || null,\n      details: {\n        ...fulfillment.details,\n        confirmation_number: details.confirmation_number,\n        processed_by: details.processed_by,\n        notes: details.notes,\n        completed_at: new Date().toISOString()\n      }\n    })\n    .eq('id', fulfillment_id)\n    .select()\n    .single();\n  \n  if (updateError) throw updateError;\n  \n  // Update the reward status\n  await updateRewardStatus(fulfillment.reward.id, 'completed');\n  \n  return updatedFulfillment as RewardFulfillment;\n};\n```",
            "status": "pending",
            "testStrategy": "Test the donation processor with various reward amounts and charity settings. Verify that fulfillment records are created correctly and status updates propagate to the reward history."
          },
          {
            "id": 6,
            "title": "Implement Professional Development Fund Processor",
            "description": "Create a service to process professional development fund rewards, including tracking available balances and processing reimbursement requests.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Create a new file `services/rewardProcessors/developmentFundProcessor.ts` with the following implementation:\n\n```typescript\nimport { RewardHistory, RewardFulfillment } from '../../types/rewards';\nimport { supabase } from '../../lib/supabaseClient';\nimport { updateRewardStatus } from '../rewardHistoryService';\n\n// Helper function to get current development fund balance for an advocate\nexport const getDevelopmentFundBalance = async (advocate_id: string): Promise<number> => {\n  const { data, error } = await supabase\n    .from('reward_history')\n    .select('amount, status')\n    .eq('advocate_id', advocate_id)\n    .eq('status', 'completed')\n    .in('reward_option.type', ['development_fund']);\n  \n  if (error) throw error;\n  \n  // Sum up all completed development fund rewards\n  return data.reduce((total, reward) => total + (reward.amount || 0), 0);\n};\n\nexport const processDevelopmentFund = async (reward: RewardHistory): Promise<RewardFulfillment> => {\n  try {\n    // Create fulfillment record\n    const { data: fulfillment, error } = await supabase\n      .from('reward_fulfillment')\n      .insert({\n        reward_id: reward.id,\n        processor_type: 'development_fund',\n        status: 'pending',\n        details: {\n          fund_reference: `DEV-${reward.id.substring(0, 8)}`,\n          available_for_use: true,\n          expiration_date: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year from now\n          notes: 'Development fund credit added to advocate balance'\n        }\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    \n    // Update reward status to completed immediately since this is just adding to their balance\n    await updateRewardStatus(reward.id, 'completed');\n    \n    return fulfillment as RewardFulfillment;\n  } catch (error) {\n    console.error('Error processing development fund:', error);\n    await updateRewardStatus(reward.id, 'failed');\n    throw error;\n  }\n};\n\n// Function to process a reimbursement request against the development fund\nexport const processReimbursementRequest = async (\n  advocate_id: string,\n  amount: number,\n  details: {\n    description: string;\n    receipt_url?: string;\n    category?: string;\n  }\n): Promise<{ success: boolean; message: string; remaining_balance?: number }> => {\n  // Get current balance\n  const currentBalance = await getDevelopmentFundBalance(advocate_id);\n  \n  if (currentBalance < amount) {\n    return {\n      success: false,\n      message: `Insufficient funds. Current balance: $${currentBalance.toFixed(2)}`\n    };\n  }\n  \n  // In a real implementation, you would:\n  // 1. Create a reimbursement request record\n  // 2. Notify finance team or trigger approval workflow\n  // 3. Process payment when approved\n  \n  // For this example, we'll just return success\n  return {\n    success: true,\n    message: 'Reimbursement request submitted successfully',\n    remaining_balance: currentBalance - amount\n  };\n};\n```",
            "status": "pending",
            "testStrategy": "Test the development fund processor with various reward amounts. Verify that fund balances are calculated correctly. Test reimbursement requests with sufficient and insufficient balances."
          },
          {
            "id": 7,
            "title": "Implement Direct Stipend Processor",
            "description": "Create a service to process direct stipend payments to advocates, including integration with payment providers or manual processing by the finance team.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Create a new file `services/rewardProcessors/stipendProcessor.ts` with the following implementation:\n\n```typescript\nimport { RewardHistory, RewardFulfillment } from '../../types/rewards';\nimport { supabase } from '../../lib/supabaseClient';\nimport { updateRewardStatus } from '../rewardHistoryService';\n\nexport const processStipend = async (reward: RewardHistory): Promise<RewardFulfillment> => {\n  try {\n    // Create fulfillment record\n    const { data: fulfillment, error } = await supabase\n      .from('reward_fulfillment')\n      .insert({\n        reward_id: reward.id,\n        processor_type: 'stipend',\n        status: 'pending',\n        details: {\n          payment_reference: `STIP-${reward.id.substring(0, 8)}`,\n          tax_reportable: true,\n          payment_method: reward.reward_option?.settings?.payment_method || 'bank_transfer',\n          notes: 'Pending finance team processing'\n        }\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    \n    // Update reward status to processing\n    await updateRewardStatus(reward.id, 'processing');\n    \n    // In a real implementation, you might:\n    // 1. Call an external payment API (Stripe, PayPal, etc.)\n    // 2. Send notification to finance team\n    // 3. Create a task in a workflow system\n    // 4. Flag for tax reporting\n    \n    // For now, we'll just return the fulfillment record\n    return fulfillment as RewardFulfillment;\n  } catch (error) {\n    console.error('Error processing stipend:', error);\n    await updateRewardStatus(reward.id, 'failed');\n    throw error;\n  }\n};\n\nexport const completeStipendPayment = async (\n  fulfillment_id: string,\n  details: {\n    transaction_id?: string;\n    processed_by?: string;\n    payment_date?: string;\n    notes?: string;\n  }\n): Promise<RewardFulfillment> => {\n  // Get the fulfillment record\n  const { data: fulfillment, error: fetchError } = await supabase\n    .from('reward_fulfillment')\n    .select('*, reward:reward_id(*)')\n    .eq('id', fulfillment_id)\n    .single();\n  \n  if (fetchError) throw fetchError;\n  \n  // Update the fulfillment record\n  const { data: updatedFulfillment, error: updateError } = await supabase\n    .from('reward_fulfillment')\n    .update({\n      status: 'completed',\n      processor_id: details.transaction_id || null,\n      details: {\n        ...fulfillment.details,\n        transaction_id: details.transaction_id,\n        processed_by: details.processed_by,\n        payment_date: details.payment_date || new Date().toISOString(),\n        notes: details.notes,\n        completed_at: new Date().toISOString()\n      }\n    })\n    .eq('id', fulfillment_id)\n    .select()\n    .single();\n  \n  if (updateError) throw updateError;\n  \n  // Update the reward status\n  await updateRewardStatus(fulfillment.reward.id, 'completed');\n  \n  return updatedFulfillment as RewardFulfillment;\n};\n\n// Function to generate tax reporting data\nexport const generateTaxReportingData = async (year: number, company_id?: string): Promise<any[]> => {\n  // Query all completed stipends for the given year\n  const startDate = `${year}-01-01`;\n  const endDate = `${year}-12-31`;\n  \n  let query = supabase\n    .from('reward_history')\n    .select(`\n      id,\n      advocate_id,\n      amount,\n      processed_at,\n      reward_option:reward_option_id(*),\n      advocate:advocate_id(id, first_name, last_name, email, tax_id)\n    `)\n    .eq('status', 'completed')\n    .eq('reward_option.type', 'stipend')\n    .gte('processed_at', startDate)\n    .lte('processed_at', endDate);\n  \n  if (company_id) {\n    query = query.eq('reward_option.company_id', company_id);\n  }\n  \n  const { data, error } = await query;\n  \n  if (error) throw error;\n  \n  // Group by advocate and sum amounts\n  const advocateMap = new Map();\n  \n  data.forEach(reward => {\n    const advocateId = reward.advocate_id;\n    if (!advocateMap.has(advocateId)) {\n      advocateMap.set(advocateId, {\n        advocate_id: advocateId,\n        first_name: reward.advocate.first_name,\n        last_name: reward.advocate.last_name,\n        email: reward.advocate.email,\n        tax_id: reward.advocate.tax_id,\n        total_amount: 0,\n        payments: []\n      });\n    }\n    \n    const record = advocateMap.get(advocateId);\n    record.total_amount += reward.amount;\n    record.payments.push({\n      reward_id: reward.id,\n      amount: reward.amount,\n      date: reward.processed_at\n    });\n  });\n  \n  return Array.from(advocateMap.values());\n};\n```",
            "status": "pending",
            "testStrategy": "Test the stipend processor with various payment methods and amounts. Verify tax reporting data generation for different time periods. Test payment completion workflow with various status updates."
          },
          {
            "id": 8,
            "title": "Implement Company Credits Processor",
            "description": "Create a service to process company credit rewards, which can be used for team events or company merchandise.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Create a new file `services/rewardProcessors/companyCreditsProcessor.ts` with the following implementation:\n\n```typescript\nimport { RewardHistory, RewardFulfillment } from '../../types/rewards';\nimport { supabase } from '../../lib/supabaseClient';\nimport { updateRewardStatus } from '../rewardHistoryService';\n\n// Helper function to get current company credits balance for a company\nexport const getCompanyCreditsBalance = async (company_id: string): Promise<number> => {\n  const { data, error } = await supabase\n    .from('reward_history')\n    .select('amount, status, reward_option:reward_option_id(*)')\n    .eq('reward_option.company_id', company_id)\n    .eq('status', 'completed')\n    .eq('reward_option.type', 'company_credit');\n  \n  if (error) throw error;\n  \n  // Sum up all completed company credit rewards\n  return data.reduce((total, reward) => total + (reward.amount || 0), 0);\n};\n\nexport const processCompanyCredits = async (reward: RewardHistory): Promise<RewardFulfillment> => {\n  try {\n    // Get company ID from the reward option\n    const { data: rewardOption, error: optionError } = await supabase\n      .from('reward_options')\n      .select('company_id')\n      .eq('id', reward.reward_option_id)\n      .single();\n    \n    if (optionError) throw optionError;\n    \n    // Create fulfillment record\n    const { data: fulfillment, error } = await supabase\n      .from('reward_fulfillment')\n      .insert({\n        reward_id: reward.id,\n        processor_type: 'company_credit',\n        status: 'pending',\n        details: {\n          credit_reference: `CREDIT-${reward.id.substring(0, 8)}`,\n          company_id: rewardOption.company_id,\n          notes: 'Company credits added to balance'\n        }\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    \n    // Update reward status to completed immediately since this is just adding to the balance\n    await updateRewardStatus(reward.id, 'completed');\n    \n    return fulfillment as RewardFulfillment;\n  } catch (error) {\n    console.error('Error processing company credits:', error);\n    await updateRewardStatus(reward.id, 'failed');\n    throw error;\n  }\n};\n\n// Function to redeem company credits for an event or merchandise\nexport const redeemCompanyCredits = async (\n  company_id: string,\n  amount: number,\n  details: {\n    description: string;\n    event_date?: string;\n    category: 'team_event' | 'merchandise' | 'other';\n    requested_by: string;\n  }\n): Promise<{ success: boolean; message: string; remaining_balance?: number }> => {\n  // Get current balance\n  const currentBalance = await getCompanyCreditsBalance(company_id);\n  \n  if (currentBalance < amount) {\n    return {\n      success: false,\n      message: `Insufficient credits. Current balance: $${currentBalance.toFixed(2)}`\n    };\n  }\n  \n  // Create redemption record\n  const { data, error } = await supabase\n    .from('company_credit_redemptions')\n    .insert({\n      company_id,\n      amount,\n      description: details.description,\n      event_date: details.event_date,\n      category: details.category,\n      requested_by: details.requested_by,\n      status: 'pending'\n    })\n    .select()\n    .single();\n  \n  if (error) {\n    console.error('Error creating redemption record:', error);\n    return {\n      success: false,\n      message: 'Failed to create redemption request'\n    };\n  }\n  \n  return {\n    success: true,\n    message: 'Redemption request submitted successfully',\n    remaining_balance: currentBalance - amount\n  };\n};\n```",
            "status": "pending",
            "testStrategy": "Test the company credits processor with various reward amounts. Verify credit balances are calculated correctly. Test redemption requests with sufficient and insufficient balances."
          },
          {
            "id": 9,
            "title": "Implement Main Rewards Service",
            "description": "Create the main rewards service that orchestrates the reward selection and fulfillment process, integrating all reward type processors.",
            "dependencies": [
              "13.5",
              "13.6",
              "13.7",
              "13.8"
            ],
            "details": "Create a new file `services/rewardsService.ts` with the following implementation:\n\n```typescript\nimport { supabase } from '../lib/supabaseClient';\nimport { RewardOption, RewardHistory, RewardFulfillment } from '../types/rewards';\nimport { createRewardRecord, updateRewardStatus } from './rewardHistoryService';\nimport { processCharitableDonation } from './rewardProcessors/charitableDonationProcessor';\nimport { processDevelopmentFund } from './rewardProcessors/developmentFundProcessor';\nimport { processStipend } from './rewardProcessors/stipendProcessor';\nimport { processCompanyCredits } from './rewardProcessors/companyCreditsProcessor';\n\n// Get available rewards for a company\nexport const getAvailableRewards = async (companyId: string) => {\n  const { data, error } = await supabase\n    .from('reward_options')\n    .select('*')\n    .eq('company_id', companyId)\n    .eq('active', true);\n  \n  if (error) throw error;\n  return data as RewardOption[];\n};\n\n// Process a reward based on its type\nexport const processReward = async (\n  advocateId: string,\n  rewardOptionId: string,\n  callId?: string\n): Promise<RewardHistory> => {\n  try {\n    // Get the reward option\n    const { data: rewardOption, error: optionError } = await supabase\n      .from('reward_options')\n      .select('*')\n      .eq('id', rewardOptionId)\n      .single();\n    \n    if (optionError) throw optionError;\n    \n    // Create reward record\n    const reward = await createRewardRecord(\n      advocateId,\n      rewardOptionId,\n      rewardOption.amount,\n      callId\n    );\n    \n    // Process based on reward type\n    let fulfillment: RewardFulfillment;\n    \n    switch (rewardOption.type) {\n      case 'charity':\n        fulfillment = await processCharitableDonation(reward);\n        break;\n      case 'development_fund':\n        fulfillment = await processDevelopmentFund(reward);\n        break;\n      case 'stipend':\n        fulfillment = await processStipend(reward);\n        break;\n      case 'company_credit':\n        fulfillment = await processCompanyCredits(reward);\n        break;\n      default:\n        throw new Error(`Unsupported reward type: ${rewardOption.type}`);\n    }\n    \n    // Get the updated reward with fulfillment details\n    const updatedReward = await getRewardWithFulfillment(reward.id);\n    return updatedReward;\n  } catch (error) {\n    console.error('Error processing reward:', error);\n    throw error;\n  }\n};\n\n// Helper to get a reward with its fulfillment details\nexport const getRewardWithFulfillment = async (rewardId: string): Promise<RewardHistory> => {\n  const { data, error } = await supabase\n    .from('reward_history')\n    .select(`\n      *,\n      reward_option:reward_option_id(*),\n      fulfillment:id(reward_fulfillment(*))\n    `)\n    .eq('id', rewardId)\n    .single();\n  \n  if (error) throw error;\n  return data as unknown as RewardHistory;\n};\n\n// Cancel a pending reward\nexport const cancelReward = async (rewardId: string, reason: string): Promise<RewardHistory> => {\n  // Get the current reward\n  const { data: reward, error: fetchError } = await supabase\n    .from('reward_history')\n    .select('*')\n    .eq('id', rewardId)\n    .single();\n  \n  if (fetchError) throw fetchError;\n  \n  // Only allow cancellation of pending or processing rewards\n  if (!['pending', 'processing'].includes(reward.status)) {\n    throw new Error(`Cannot cancel reward with status: ${reward.status}`);\n  }\n  \n  // Update the reward status\n  const { data: updatedReward, error: updateError } = await supabase\n    .from('reward_history')\n    .update({\n      status: 'failed',\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', rewardId)\n    .select()\n    .single();\n  \n  if (updateError) throw updateError;\n  \n  // Update the fulfillment record if it exists\n  const { data: fulfillment } = await supabase\n    .from('reward_fulfillment')\n    .select('id')\n    .eq('reward_id', rewardId)\n    .single();\n  \n  if (fulfillment) {\n    await supabase\n      .from('reward_fulfillment')\n      .update({\n        status: 'cancelled',\n        details: {\n          ...fulfillment.details,\n          cancellation_reason: reason,\n          cancelled_at: new Date().toISOString()\n        }\n      })\n      .eq('id', fulfillment.id);\n  }\n  \n  return updatedReward as RewardHistory;\n};\n```",
            "status": "pending",
            "testStrategy": "Test the main rewards service with each reward type. Verify that the correct processor is called based on reward type. Test error handling and cancellation functionality."
          },
          {
            "id": 10,
            "title": "Implement Tax Documentation Generator",
            "description": "Create a service to generate tax documentation (1099 forms) for advocates who have received taxable rewards.",
            "dependencies": [
              "13.7"
            ],
            "details": "Create a new file `services/taxDocumentationService.ts` with the following implementation:\n\n```typescript\nimport { supabase } from '../lib/supabaseClient';\nimport { generateTaxReportingData } from './rewardProcessors/stipendProcessor';\n\ninterface TaxDocument {\n  id: string;\n  advocate_id: string;\n  year: number;\n  document_type: string;\n  status: 'pending' | 'generated' | 'sent' | 'acknowledged';\n  generated_at?: string;\n  sent_at?: string;\n  acknowledged_at?: string;\n  document_url?: string;\n  total_amount: number;\n  created_at: string;\n  updated_at: string;\n}\n\n// Generate tax documents for a specific year\nexport const generateTaxDocuments = async (year: number, company_id?: string): Promise<TaxDocument[]> => {\n  try {\n    // Get tax reporting data for the year\n    const taxData = await generateTaxReportingData(year, company_id);\n    \n    // Filter for advocates who received more than $600 (IRS threshold for 1099-MISC)\n    const eligibleAdvocates = taxData.filter(data => data.total_amount >= 600);\n    \n    // Create tax document records\n    const documents: TaxDocument[] = [];\n    \n    for (const advocate of eligibleAdvocates) {\n      // Check if document already exists\n      const { data: existingDoc } = await supabase\n        .from('tax_documents')\n        .select('id')\n        .eq('advocate_id', advocate.advocate_id)\n        .eq('year', year)\n        .single();\n      \n      if (existingDoc) {\n        // Update existing document\n        const { data: updatedDoc } = await supabase\n          .from('tax_documents')\n          .update({\n            total_amount: advocate.total_amount,\n            updated_at: new Date().toISOString()\n          })\n          .eq('id', existingDoc.id)\n          .select()\n          .single();\n        \n        documents.push(updatedDoc as TaxDocument);\n      } else {\n        // Create new document\n        const { data: newDoc } = await supabase\n          .from('tax_documents')\n          .insert({\n            advocate_id: advocate.advocate_id,\n            year,\n            document_type: '1099-MISC',\n            status: 'pending',\n            total_amount: advocate.total_amount\n          })\n          .select()\n          .single();\n        \n        documents.push(newDoc as TaxDocument);\n      }\n    }\n    \n    return documents;\n  } catch (error) {\n    console.error('Error generating tax documents:', error);\n    throw error;\n  }\n};\n\n// Generate the actual PDF document for a tax document record\nexport const generateTaxDocumentPDF = async (documentId: string): Promise<TaxDocument> => {\n  try {\n    // Get the tax document record\n    const { data: document, error } = await supabase\n      .from('tax_documents')\n      .select(`\n        *,\n        advocate:advocate_id(*)\n      `)\n      .eq('id', documentId)\n      .single();\n    \n    if (error) throw error;\n    \n    // In a real implementation, you would:\n    // 1. Generate a PDF using a library like PDFKit\n    // 2. Upload the PDF to storage\n    // 3. Update the document record with the URL\n    \n    // For this example, we'll just update the status\n    const { data: updatedDoc } = await supabase\n      .from('tax_documents')\n      .update({\n        status: 'generated',\n        generated_at: new Date().toISOString(),\n        document_url: `https://example.com/tax-documents/${document.id}.pdf`, // Placeholder URL\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', documentId)\n      .select()\n      .single();\n    \n    return updatedDoc as TaxDocument;\n  } catch (error) {\n    console.error('Error generating tax document PDF:', error);\n    throw error;\n  }\n};\n\n// Send tax document to advocate\nexport const sendTaxDocument = async (documentId: string): Promise<TaxDocument> => {\n  try {\n    // Get the tax document record\n    const { data: document, error } = await supabase\n      .from('tax_documents')\n      .select(`\n        *,\n        advocate:advocate_id(email, first_name, last_name)\n      `)\n      .eq('id', documentId)\n      .single();\n    \n    if (error) throw error;\n    \n    if (document.status !== 'generated') {\n      throw new Error('Document must be generated before sending');\n    }\n    \n    // In a real implementation, you would:\n    // 1. Send an email with the document attached or a secure link\n    // 2. Record the sending in an audit log\n    \n    // For this example, we'll just update the status\n    const { data: updatedDoc } = await supabase\n      .from('tax_documents')\n      .update({\n        status: 'sent',\n        sent_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', documentId)\n      .select()\n      .single();\n    \n    return updatedDoc as TaxDocument;\n  } catch (error) {\n    console.error('Error sending tax document:', error);\n    throw error;\n  }\n};\n```",
            "status": "pending",
            "testStrategy": "Test tax document generation for different years and companies. Verify that only advocates who meet the threshold receive documents. Test PDF generation and sending functionality."
          },
          {
            "id": 11,
            "title": "Create Reward Tracking and Reporting Service",
            "description": "Implement a service for generating reports on reward distribution, including filtering by time period, reward type, and advocate.",
            "dependencies": [
              "13.4"
            ],
            "details": "Create a new file `services/rewardReportingService.ts` with the following implementation:\n\n```typescript\nimport { supabase } from '../lib/supabaseClient';\n\ninterface RewardSummary {\n  total_rewards: number;\n  total_amount: number;\n  by_status: Record<string, { count: number; amount: number }>;\n  by_type: Record<string, { count: number; amount: number }>;\n}\n\ninterface AdvocateRewardSummary {\n  advocate_id: string;\n  advocate_name: string;\n  total_rewards: number;\n  total_amount: number;\n  by_type: Record<string, { count: number; amount: number }>;\n}\n\n// Generate a summary report of rewards\nexport const generateRewardSummary = async (filters: {\n  company_id?: string;\n  start_date?: string;\n  end_date?: string;\n}): Promise<RewardSummary> => {\n  let query = supabase\n    .from('reward_history')\n    .select(`\n      *,\n      reward_option:reward_option_id(*)\n    `);\n  \n  if (filters.company_id) {\n    query = query.eq('reward_option.company_id', filters.company_id);\n  }\n  \n  if (filters.start_date) {\n    query = query.gte('created_at', filters.start_date);\n  }\n  \n  if (filters.end_date) {\n    query = query.lte('created_at', filters.end_date);\n  }\n  \n  const { data, error } = await query;\n  \n  if (error) throw error;\n  \n  // Initialize summary\n  const summary: RewardSummary = {\n    total_rewards: 0,\n    total_amount: 0,\n    by_status: {},\n    by_type: {}\n  };\n  \n  // Process data\n  data.forEach(reward => {\n    summary.total_rewards++;\n    summary.total_amount += reward.amount;\n    \n    // By status\n    if (!summary.by_status[reward.status]) {\n      summary.by_status[reward.status] = { count: 0, amount: 0 };\n    }\n    summary.by_status[reward.status].count++;\n    summary.by_status[reward.status].amount += reward.amount;\n    \n    // By type\n    const type = reward.reward_option.type;\n    if (!summary.by_type[type]) {\n      summary.by_type[type] = { count: 0, amount: 0 };\n    }\n    summary.by_type[type].count++;\n    summary.by_type[type].amount += reward.amount;\n  });\n  \n  return summary;\n};\n\n// Generate a report of rewards by advocate\nexport const generateAdvocateRewardReport = async (filters: {\n  company_id?: string;\n  start_date?: string;\n  end_date?: string;\n}): Promise<AdvocateRewardSummary[]> => {\n  let query = supabase\n    .from('reward_history')\n    .select(`\n      *,\n      reward_option:reward_option_id(*),\n      advocate:advocate_id(id, first_name, last_name)\n    `);\n  \n  if (filters.company_id) {\n    query = query.eq('reward_option.company_id', filters.company_id);\n  }\n  \n  if (filters.start_date) {\n    query = query.gte('created_at', filters.start_date);\n  }\n  \n  if (filters.end_date) {\n    query = query.lte('created_at', filters.end_date);\n  }\n  \n  const { data, error } = await query;\n  \n  if (error) throw error;\n  \n  // Group by advocate\n  const advocateMap = new Map<string, AdvocateRewardSummary>();\n  \n  data.forEach(reward => {\n    const advocateId = reward.advocate_id;\n    const advocateName = `${reward.advocate.first_name} ${reward.advocate.last_name}`;\n    \n    if (!advocateMap.has(advocateId)) {\n      advocateMap.set(advocateId, {\n        advocate_id: advocateId,\n        advocate_name: advocateName,\n        total_rewards: 0,\n        total_amount: 0,\n        by_type: {}\n      });\n    }\n    \n    const summary = advocateMap.get(advocateId)!;\n    summary.total_rewards++;\n    summary.total_amount += reward.amount;\n    \n    // By type\n    const type = reward.reward_option.type;\n    if (!summary.by_type[type]) {\n      summary.by_type[type] = { count: 0, amount: 0 };\n    }\n    summary.by_type[type].count++;\n    summary.by_type[type].amount += reward.amount;\n  });\n  \n  return Array.from(advocateMap.values());\n};\n\n// Generate a monthly trend report\nexport const generateMonthlyTrendReport = async (filters: {\n  company_id?: string;\n  start_date: string; // Required for trend report\n  end_date: string;   // Required for trend report\n}): Promise<Record<string, { count: number; amount: number; by_type: Record<string, number> }>> => {\n  if (!filters.start_date || !filters.end_date) {\n    throw new Error('Start and end dates are required for trend reports');\n  }\n  \n  let query = supabase\n    .from('reward_history')\n    .select(`\n      *,\n      reward_option:reward_option_id(*)\n    `)\n    .gte('created_at', filters.start_date)\n    .lte('created_at', filters.end_date);\n  \n  if (filters.company_id) {\n    query = query.eq('reward_option.company_id', filters.company_id);\n  }\n  \n  const { data, error } = await query;\n  \n  if (error) throw error;\n  \n  // Group by month\n  const monthlyData: Record<string, { count: number; amount: number; by_type: Record<string, number> }> = {};\n  \n  data.forEach(reward => {\n    const date = new Date(reward.created_at);\n    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n    \n    if (!monthlyData[monthKey]) {\n      monthlyData[monthKey] = {\n        count: 0,\n        amount: 0,\n        by_type: {}\n      };\n    }\n    \n    monthlyData[monthKey].count++;\n    monthlyData[monthKey].amount += reward.amount;\n    \n    const type = reward.reward_option.type;\n    if (!monthlyData[monthKey].by_type[type]) {\n      monthlyData[monthKey].by_type[type] = 0;\n    }\n    monthlyData[monthKey].by_type[type] += reward.amount;\n  });\n  \n  return monthlyData;\n};\n```",
            "status": "pending",
            "testStrategy": "Test report generation with various filter combinations. Verify that summary calculations are accurate. Test trend reports with different date ranges."
          },
          {
            "id": 12,
            "title": "Build Advocate Reward History Component",
            "description": "Create a React component for displaying an advocate's reward history, including filtering and sorting options.",
            "dependencies": [
              "13.4"
            ],
            "details": "Create a new file `components/rewards/AdvocateRewardHistory.tsx` with the following implementation:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { supabase } from '../../lib/supabaseClient';\nimport { RewardHistory, RewardType } from '../../types/rewards';\nimport { formatCurrency, formatDate } from '../../utils/formatters';\n\ninterface AdvocateRewardHistoryProps {\n  advocateId?: string; // Optional: if not provided, use from URL params\n}\n\nconst AdvocateRewardHistory: React.FC<AdvocateRewardHistoryProps> = ({ advocateId: propAdvocateId }) => {\n  const { advocateId: urlAdvocateId } = useParams<{ advocateId: string }>();\n  const advocateId = propAdvocateId || urlAdvocateId;\n  \n  const [rewards, setRewards] = useState<RewardHistory[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [filter, setFilter] = useState<{\n    status: string | null;\n    type: RewardType | null;\n    dateRange: 'all' | '30days' | '90days' | 'year';\n  }>({ status: null, type: null, dateRange: 'all' });\n  \n  useEffect(() => {\n    if (!advocateId) return;\n    \n    const fetchRewards = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        let query = supabase\n          .from('reward_history')\n          .select(`\n            *,\n            reward_option:reward_option_id(*),\n            fulfillment:id(reward_fulfillment(*))\n          `)\n          .eq('advocate_id', advocateId)\n          .order('created_at', { ascending: false });\n        \n        // Apply filters\n        if (filter.status) {\n          query = query.eq('status', filter.status);\n        }\n        \n        if (filter.type) {\n          query = query.eq('reward_option.type', filter.type);\n        }\n        \n        if (filter.dateRange !== 'all') {\n          const now = new Date();\n          let startDate: Date;\n          \n          switch (filter.dateRange) {\n            case '30days':\n              startDate = new Date(now.setDate(now.getDate() - 30));\n              break;\n            case '90days':\n              startDate = new Date(now.setDate(now.getDate() - 90));\n              break;\n            case 'year':\n              startDate = new Date(now.setFullYear(now.getFullYear() - 1));\n              break;\n            default:\n              startDate = new Date(0); // Beginning of time\n          }\n          \n          query = query.gte('created_at', startDate.toISOString());\n        }\n        \n        const { data, error } = await query;\n        \n        if (error) throw error;\n        setRewards(data as unknown as RewardHistory[]);\n      } catch (err) {\n        console.error('Error fetching reward history:', err);\n        setError('Failed to load reward history');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchRewards();\n  }, [advocateId, filter]);\n  \n  const handleFilterChange = (key: keyof typeof filter, value: any) => {\n    setFilter(prev => ({ ...prev, [key]: value }));\n  };\n  \n  const getTotalAmount = () => {\n    return rewards.reduce((sum, reward) => sum + reward.amount, 0);\n  };\n  \n  if (loading) return <div className=\"loading\">Loading reward history...</div>;\n  if (error) return <div className=\"error\">{error}</div>;\n  \n  return (\n    <div className=\"advocate-reward-history\">\n      <div className=\"reward-summary\">\n        <h3>Reward Summary</h3>\n        <div className=\"summary-stats\">\n          <div className=\"stat\">\n            <span className=\"label\">Total Rewards</span>\n            <span className=\"value\">{rewards.length}</span>\n          </div>\n          <div className=\"stat\">\n            <span className=\"label\">Total Value</span>\n            <span className=\"value\">{formatCurrency(getTotalAmount())}</span>\n          </div>\n        </div>\n      </div>\n      \n      <div className=\"filters\">\n        <div className=\"filter-group\">\n          <label>Status</label>\n          <select \n            value={filter.status || ''} \n            onChange={(e) => handleFilterChange('status', e.target.value || null)}\n          >\n            <option value=\"\">All Statuses</option>\n            <option value=\"pending\">Pending</option>\n            <option value=\"processing\">Processing</option>\n            <option value=\"completed\">Completed</option>\n            <option value=\"failed\">Failed</option>\n          </select>\n        </div>\n        \n        <div className=\"filter-group\">\n          <label>Type</label>\n          <select \n            value={filter.type || ''} \n            onChange={(e) => handleFilterChange('type', e.target.value as RewardType || null)}\n          >\n            <option value=\"\">All Types</option>\n            <option value=\"charity\">Charitable Donation</option>\n            <option value=\"development_fund\">Development Fund</option>\n            <option value=\"stipend\">Stipend</option>\n            <option value=\"company_credit\">Company Credit</option>\n          </select>\n        </div>\n        \n        <div className=\"filter-group\">\n          <label>Date Range</label>\n          <select \n            value={filter.dateRange} \n            onChange={(e) => handleFilterChange('dateRange', e.target.value)}\n          >\n            <option value=\"all\">All Time</option>\n            <option value=\"30days\">Last 30 Days</option>\n            <option value=\"90days\">Last 90 Days</option>\n            <option value=\"year\">Last Year</option>\n          </select>\n        </div>\n      </div>\n      \n      <div className=\"rewards-list\">\n        {rewards.length === 0 ? (\n          <div className=\"empty-state\">No rewards found matching the current filters.</div>\n        ) : (\n          <table className=\"rewards-table\">\n            <thead>\n              <tr>\n                <th>Date</th>\n                <th>Type</th>\n                <th>Amount</th>\n                <th>Status</th>\n                <th>Details</th>\n              </tr>\n            </thead>\n            <tbody>\n              {rewards.map(reward => (\n                <tr key={reward.id} className={`status-${reward.status}`}>\n                  <td>{formatDate(reward.created_at)}</td>\n                  <td>\n                    {reward.reward_option?.name || reward.reward_option?.type}\n                  </td>\n                  <td>{formatCurrency(reward.amount)}</td>\n                  <td>\n                    <span className={`status-badge ${reward.status}`}>\n                      {reward.status}\n                    </span>\n                  </td>\n                  <td>\n                    {reward.fulfillment ? (\n                      <div className=\"fulfillment-details\">\n                        {reward.fulfillment.processor_type === 'charity' && (\n                          <span>Donation to: {reward.fulfillment.details?.charity_name}</span>\n                        )}\n                        {reward.fulfillment.processor_type === 'stipend' && (\n                          <span>Payment method: {reward.fulfillment.details?.payment_method}</span>\n                        )}\n                        {reward.status === 'completed' && reward.processed_at && (\n                          <div className=\"processed-date\">Processed: {formatDate(reward.processed_at)}</div>\n                        )}\n                      </div>\n                    ) : (\n                      <span>-</span>\n                    )}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default AdvocateRewardHistory;\n```",
            "status": "pending",
            "testStrategy": "Test the component with various filter combinations. Verify that rewards are displayed correctly with all relevant details. Test empty state rendering when no rewards match the filters."
          },
          {
            "id": 13,
            "title": "Implement Compliance Checks and Approvals Workflow",
            "description": "Create a service to handle compliance checks for rewards, including approval workflows for high-value rewards and tax implications.",
            "dependencies": [
              "13.9"
            ],
            "details": "Create a new file `services/rewardComplianceService.ts` with the following implementation:\n\n```typescript\nimport { supabase } from '../lib/supabaseClient';\nimport { RewardHistory, RewardOption } from '../types/rewards';\nimport { updateRewardStatus } from './rewardHistoryService';\n\ninterface ComplianceCheck {\n  id: string;\n  reward_id: string;\n  check_type: 'value_threshold' | 'tax_implications' | 'frequency' | 'custom';\n  status: 'pending' | 'approved' | 'rejected';\n  approver_id?: string;\n  notes?: string;\n  created_at: string;\n  updated_at: string;\n}\n\n// Check if a reward requires compliance approval\nexport const checkComplianceRequirements = async (reward: RewardHistory): Promise<{\n  requiresApproval: boolean;\n  checks: Partial<ComplianceCheck>[];\n}> => {\n  const checks: Partial<ComplianceCheck>[] = [];\n  \n  // Get company compliance settings\n  const { data: rewardOption } = await supabase\n    .from('reward_options')\n    .select('*, company:company_id(settings)')\n    .eq('id', reward.reward_option_id)\n    .single();\n  \n  const companySettings = rewardOption.company.settings || {};\n  const complianceSettings = companySettings.compliance || {\n    value_threshold: 500, // Default $500 threshold for high-value rewards\n    monthly_limit: 2000,  // Default $2000 monthly limit per advocate\n    require_tax_approval: true\n  };\n  \n  // Check 1: High-value reward check\n  if (reward.amount >= complianceSettings.value_threshold) {\n    checks.push({\n      reward_id: reward.id,\n      check_type: 'value_threshold',\n      status: 'pending',\n      notes: `Reward amount (${reward.amount}) exceeds threshold (${complianceSettings.value_threshold})`\n    });\n  }\n  \n  // Check 2: Tax implications check\n  if (complianceSettings.require_tax_approval && rewardOption.tax_implications) {\n    checks.push({\n      reward_id: reward.id,\n      check_type: 'tax_implications',\n      status: 'pending',\n      notes: 'Reward has tax implications requiring approval'\n    });\n  }\n  \n  // Check 3: Monthly frequency/limit check\n  const startOfMonth = new Date();\n  startOfMonth.setDate(1);\n  startOfMonth.setHours(0, 0, 0, 0);\n  \n  const { data: monthlyRewards } = await supabase\n    .from('reward_history')\n    .select('amount')\n    .eq('advocate_id', reward.advocate_id)\n    .gte('created_at', startOfMonth.toISOString())\n    .not('status', 'eq', 'failed');\n  \n  const monthlyTotal = monthlyRewards.reduce((sum, r) => sum + r.amount, 0) + reward.amount;\n  \n  if (monthlyTotal > complianceSettings.monthly_limit) {\n    checks.push({\n      reward_id: reward.id,\n      check_type: 'frequency',\n      status: 'pending',\n      notes: `Monthly total (${monthlyTotal}) exceeds limit (${complianceSettings.monthly_limit})`\n    });\n  }\n  \n  return {\n    requiresApproval: checks.length > 0,\n    checks\n  };\n};\n\n// Create compliance checks for a reward\nexport const createComplianceChecks = async (reward: RewardHistory): Promise<ComplianceCheck[]> => {\n  const { requiresApproval, checks } = await checkComplianceRequirements(reward);\n  \n  if (!requiresApproval) {\n    return [];\n  }\n  \n  // Insert all checks\n  const { data, error } = await supabase\n    .from('compliance_checks')\n    .insert(checks)\n    .select();\n  \n  if (error) throw error;\n  \n  // Update reward status to indicate pending approval\n  await updateRewardStatus(reward.id, 'pending');\n  \n  return data as ComplianceCheck[];\n};\n\n// Get pending compliance checks\nexport const getPendingComplianceChecks = async (companyId?: string): Promise<{\n  reward: RewardHistory;\n  checks: ComplianceCheck[];\n}[]> => {\n  let query = supabase\n    .from('compliance_checks')\n    .select(`\n      *,\n      reward:reward_id(*, reward_option:reward_option_id(*))\n    `)\n    .eq('status', 'pending');\n  \n  if (companyId) {\n    query = query.eq('reward.reward_option.company_id', companyId);\n  }\n  \n  const { data, error } = await query;\n  \n  if (error) throw error;\n  \n  // Group checks by reward\n  const rewardMap = new Map<string, {\n    reward: RewardHistory;\n    checks: ComplianceCheck[];\n  }>();\n  \n  data.forEach(check => {\n    const rewardId = check.reward_id;\n    if (!rewardMap.has(rewardId)) {\n      rewardMap.set(rewardId, {\n        reward: check.reward,\n        checks: []\n      });\n    }\n    \n    rewardMap.get(rewardId)!.checks.push(check);\n  });\n  \n  return Array.from(rewardMap.values());\n};\n\n// Approve or reject a compliance check\nexport const resolveComplianceCheck = async (\n  checkId: string,\n  resolution: {\n    status: 'approved' | 'rejected';\n    approver_id: string;\n    notes?: string;\n  }\n): Promise<ComplianceCheck> => {\n  // Update the check\n  const { data: updatedCheck, error } = await supabase\n    .from('compliance_checks')\n    .update({\n      status: resolution.status,\n      approver_id: resolution.approver_id,\n      notes: resolution.notes,\n      updated_at: new Date().toISOString()\n    })\n    .eq('id', checkId)\n    .select('*, reward:reward_id(*)')\n    .single();\n  \n  if (error) throw error;\n  \n  // Check if all checks for this reward are resolved\n  const { data: remainingChecks } = await supabase\n    .from('compliance_checks')\n    .select('status')\n    .eq('reward_id', updatedCheck.reward_id)\n    .eq('status', 'pending');\n  \n  // If no pending checks remain, update the reward status\n  if (remainingChecks.length === 0) {\n    // Check if any were rejected\n    const { data: rejectedChecks } = await supabase\n      .from('compliance_checks')\n      .select('id')\n      .eq('reward_id', updatedCheck.reward_id)\n      .eq('status', 'rejected');\n    \n    if (rejectedChecks.length > 0) {\n      // At least one check was rejected, fail the reward\n      await updateRewardStatus(updatedCheck.reward_id, 'failed');\n    } else {\n      // All checks approved, continue processing\n      await updateRewardStatus(updatedCheck.reward_id, 'processing');\n      \n      // In a real implementation, you would trigger the reward processing here\n      // For example: await processReward(updatedCheck.reward);\n    }\n  }\n  \n  return updatedCheck as ComplianceCheck;\n};\n```",
            "status": "pending",
            "testStrategy": "Test compliance checks with various reward amounts and settings. Verify that high-value rewards are properly flagged. Test approval and rejection workflows and ensure they update reward status correctly."
          },
          {
            "id": 14,
            "title": "Create Admin Reward Management Interface",
            "description": "Build an administrative interface for managing rewards, including approval workflows, reporting, and configuration of reward options.",
            "dependencies": [
              "13.3",
              "13.11",
              "13.13"
            ],
            "details": "Create a new file `components/admin/RewardManagement.tsx` with the following implementation:\n\n```typescript\nimport React, { useState, useEffect } from 'react';\nimport { useCompany } from '../../hooks/useCompany';\nimport { getRewardOptions, createRewardOption, updateRewardOption, toggleRewardOptionActive } from '../../services/rewardOptionsService';\nimport { generateRewardSummary, generateAdvocateRewardReport, generateMonthlyTrendReport } from '../../services/rewardReportingService';\nimport { getPendingComplianceChecks, resolveComplianceCheck } from '../../services/rewardComplianceService';\nimport { RewardOption, RewardType } from '../../types/rewards';\nimport { formatCurrency, formatDate } from '../../utils/formatters';\n\nconst RewardManagement: React.FC = () => {\n  const { company } = useCompany();\n  const [activeTab, setActiveTab] = useState<'options' | 'approvals' | 'reports'>('options');\n  const [rewardOptions, setRewardOptions] = useState<RewardOption[]>([]);\n  const [pendingApprovals, setPendingApprovals] = useState<any[]>([]);\n  const [reportType, setReportType] = useState<'summary' | 'advocates' | 'trends'>('summary');\n  const [reportData, setReportData] = useState<any>(null);\n  const [dateRange, setDateRange] = useState<{\n    start_date: string;\n    end_date: string;\n  }>({ \n    start_date: new Date(new Date().setMonth(new Date().getMonth() - 3)).toISOString().split('T')[0],\n    end_date: new Date().toISOString().split('T')[0]\n  });\n  const [loading, setLoading] = useState(false);\n  const [newRewardOption, setNewRewardOption] = useState<Partial<RewardOption>>({\n    name: '',\n    description: '',\n    type: 'charity' as RewardType,\n    amount: 100,\n    active: true,\n    tax_implications: false,\n    settings: {}\n  });\n  \n  // Load reward options\n  useEffect(() => {\n    if (!company?.id) return;\n    \n    const loadRewardOptions = async () => {\n      try {\n        const options = await getRewardOptions(company.id, true);\n        setRewardOptions(options);\n      } catch (error) {\n        console.error('Error loading reward options:', error);\n      }\n    };\n    \n    loadRewardOptions();\n  }, [company?.id]);\n  \n  // Load pending approvals\n  useEffect(() => {\n    if (!company?.id || activeTab !== 'approvals') return;\n    \n    const loadPendingApprovals = async () => {\n      try {\n        const checks = await getPendingComplianceChecks(company.id);\n        setPendingApprovals(checks);\n      } catch (error) {\n        console.error('Error loading pending approvals:', error);\n      }\n    };\n    \n    loadPendingApprovals();\n    \n    // Refresh every minute\n    const interval = setInterval(loadPendingApprovals, 60000);\n    return () => clearInterval(interval);\n  }, [company?.id, activeTab]);\n  \n  // Handle creating a new reward option\n  const handleCreateRewardOption = async () => {\n    if (!company?.id) return;\n    \n    try {\n      const option = await createRewardOption({\n        ...newRewardOption,\n        company_id: company.id\n      } as any);\n      \n      setRewardOptions([...rewardOptions, option]);\n      setNewRewardOption({\n        name: '',\n        description: '',\n        type: 'charity' as RewardType,\n        amount: 100,\n        active: true,\n        tax_implications: false,\n        settings: {}\n      });\n    } catch (error) {\n      console.error('Error creating reward option:', error);\n    }\n  };\n  \n  // Handle toggling a reward option active state\n  const handleToggleActive = async (id: string, currentActive: boolean) => {\n    try {\n      await toggleRewardOptionActive(id, !currentActive);\n      setRewardOptions(rewardOptions.map(option => \n        option.id === id ? { ...option, active: !currentActive } : option\n      ));\n    } catch (error) {\n      console.error('Error toggling reward option:', error);\n    }\n  };\n  \n  // Handle resolving a compliance check\n  const handleResolveCheck = async (checkId: string, status: 'approved' | 'rejected', notes: string) => {\n    try {\n      await resolveComplianceCheck(checkId, {\n        status,\n        approver_id: 'current-user-id', // In a real app, get from auth context\n        notes\n      });\n      \n      // Remove the resolved check from the list\n      setPendingApprovals(pendingApprovals.map(item => {\n        const updatedChecks = item.checks.filter((check: any) => check.id !== checkId);\n        return {\n          ...item,\n          checks: updatedChecks\n        };\n      }).filter(item => item.checks.length > 0));\n    } catch (error) {\n      console.error('Error resolving compliance check:', error);\n    }\n  };\n  \n  // Generate a report\n  const handleGenerateReport = async () => {\n    if (!company?.id) return;\n    setLoading(true);\n    \n    try {\n      const filters = {\n        company_id: company.id,\n        ...dateRange\n      };\n      \n      let data;\n      switch (reportType) {\n        case 'summary':\n          data = await generateRewardSummary(filters);\n          break;\n        case 'advocates':\n          data = await generateAdvocateRewardReport(filters);\n          break;\n        case 'trends':\n          data = await generateMonthlyTrendReport(filters);\n          break;\n      }\n      \n      setReportData(data);\n    } catch (error) {\n      console.error('Error generating report:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  // Render reward options tab\n  const renderRewardOptionsTab = () => (\n    <div className=\"reward-options-tab\">\n      <h3>Reward Options</h3>\n      \n      <div className=\"new-reward-form\">\n        <h4>Add New Reward Option</h4>\n        <div className=\"form-row\">\n          <div className=\"form-group\">\n            <label>Name</label>\n            <input \n              type=\"text\" \n              value={newRewardOption.name} \n              onChange={(e) => setNewRewardOption({...newRewardOption, name: e.target.value})}\n              placeholder=\"Reward name\"\n            />\n          </div>\n          \n          <div className=\"form-group\">\n            <label>Type</label>\n            <select \n              value={newRewardOption.type} \n              onChange={(e) => setNewRewardOption({...newRewardOption, type: e.target.value as RewardType})}\n            >\n              <option value=\"charity\">Charitable Donation</option>\n              <option value=\"development_fund\">Development Fund</option>\n              <option value=\"stipend\">Stipend</option>\n              <option value=\"company_credit\">Company Credit</option>\n            </select>\n          </div>\n          \n          <div className=\"form-group\">\n            <label>Amount ($)</label>\n            <input \n              type=\"number\" \n              value={newRewardOption.amount} \n              onChange={(e) => setNewRewardOption({...newRewardOption, amount: parseFloat(e.target.value)})}\n              min=\"0\"\n              step=\"10\"\n            />\n          </div>\n        </div>\n        \n        <div className=\"form-row\">\n          <div className=\"form-group\">\n            <label>Description</label>\n            <textarea \n              value={newRewardOption.description} \n              onChange={(e) => setNewRewardOption({...newRewardOption, description: e.target.value})}\n              placeholder=\"Describe this reward option\"\n            />\n          </div>\n        </div>\n        \n        <div className=\"form-row\">\n          <div className=\"form-group checkbox\">\n            <label>\n              <input \n                type=\"checkbox\" \n                checked={newRewardOption.tax_implications} \n                onChange={(e) => setNewRewardOption({...newRewardOption, tax_implications: e.target.checked})}\n              />\n              Has tax implications\n            </label>\n          </div>\n          \n          <div className=\"form-group checkbox\">\n            <label>\n              <input \n                type=\"checkbox\" \n                checked={newRewardOption.active} \n                onChange={(e) => setNewRewardOption({...newRewardOption, active: e.target.checked})}\n              />\n              Active\n            </label>\n          </div>\n        </div>\n        \n        <button className=\"btn-primary\" onClick={handleCreateRewardOption}>Add Reward Option</button>\n      </div>\n      \n      <div className=\"reward-options-list\">\n        <h4>Current Reward Options</h4>\n        <table className=\"data-table\">\n          <thead>\n            <tr>\n              <th>Name</th>\n              <th>Type</th>\n              <th>Amount</th>\n              <th>Tax Implications</th>\n              <th>Status</th>\n              <th>Actions</th>\n            </tr>\n          </thead>\n          <tbody>\n            {rewardOptions.map(option => (\n              <tr key={option.id} className={option.active ? '' : 'inactive'}>\n                <td>{option.name}</td>\n                <td>{option.type.replace('_', ' ')}</td>\n                <td>{formatCurrency(option.amount)}</td>\n                <td>{option.tax_implications ? 'Yes' : 'No'}</td>\n                <td>\n                  <span className={`status-badge ${option.active ? 'active' : 'inactive'}`}>\n                    {option.active ? 'Active' : 'Inactive'}\n                  </span>\n                </td>\n                <td>\n                  <button \n                    className={`btn-sm ${option.active ? 'btn-warning' : 'btn-success'}`}\n                    onClick={() => handleToggleActive(option.id, option.active)}\n                  >\n                    {option.active ? 'Deactivate' : 'Activate'}\n                  </button>\n                </td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  );\n  \n  // Render approvals tab\n  const renderApprovalsTab = () => (\n    <div className=\"approvals-tab\">\n      <h3>Pending Approvals</h3>\n      \n      {pendingApprovals.length === 0 ? (\n        <div className=\"empty-state\">No pending approvals</div>\n      ) : (\n        <div className=\"approvals-list\">\n          {pendingApprovals.map(item => (\n            <div key={item.reward.id} className=\"approval-card\">\n              <div className=\"reward-details\">\n                <h4>Reward #{item.reward.id.substring(0, 8)}</h4>\n                <div className=\"details-row\">\n                  <span className=\"label\">Advocate:</span>\n                  <span className=\"value\">{item.reward.advocate_id}</span>\n                </div>\n                <div className=\"details-row\">\n                  <span className=\"label\">Type:</span>\n                  <span className=\"value\">{item.reward.reward_option.type.replace('_', ' ')}</span>\n                </div>\n                <div className=\"details-row\">\n                  <span className=\"label\">Amount:</span>\n                  <span className=\"value\">{formatCurrency(item.reward.amount)}</span>\n                </div>\n                <div className=\"details-row\">\n                  <span className=\"label\">Created:</span>\n                  <span className=\"value\">{formatDate(item.reward.created_at)}</span>\n                </div>\n              </div>\n              \n              <div className=\"checks-list\">\n                <h5>Required Approvals</h5>\n                {item.checks.map((check: any) => (\n                  <div key={check.id} className=\"check-item\">\n                    <div className=\"check-type\">\n                      {check.check_type === 'value_threshold' && 'High Value'}\n                      {check.check_type === 'tax_implications' && 'Tax Implications'}\n                      {check.check_type === 'frequency' && 'Frequency Limit'}\n                      {check.check_type === 'custom' && 'Custom Check'}\n                    </div>\n                    <div className=\"check-notes\">{check.notes}</div>\n                    <div className=\"check-actions\">\n                      <button \n                        className=\"btn-sm btn-success\" \n                        onClick={() => handleResolveCheck(check.id, 'approved', 'Approved by admin')}\n                      >\n                        Approve\n                      </button>\n                      <button \n                        className=\"btn-sm btn-danger\" \n                        onClick={() => handleResolveCheck(check.id, 'rejected', 'Rejected by admin')}\n                      >\n                        Reject\n                      </button>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n  \n  // Render reports tab\n  const renderReportsTab = () => (\n    <div className=\"reports-tab\">\n      <h3>Reward Reports</h3>\n      \n      <div className=\"report-controls\">\n        <div className=\"form-row\">\n          <div className=\"form-group\">\n            <label>Report Type</label>\n            <select \n              value={reportType} \n              onChange={(e) => setReportType(e.target.value as any)}\n            >\n              <option value=\"summary\">Summary Report</option>\n              <option value=\"advocates\">Advocate Report</option>\n              <option value=\"trends\">Monthly Trends</option>\n            </select>\n          </div>\n          \n          <div className=\"form-group\">\n            <label>Start Date</label>\n            <input \n              type=\"date\" \n              value={dateRange.start_date} \n              onChange={(e) => setDateRange({...dateRange, start_date: e.target.value})}\n            />\n          </div>\n          \n          <div className=\"form-group\">\n            <label>End Date</label>\n            <input \n              type=\"date\" \n              value={dateRange.end_date} \n              onChange={(e) => setDateRange({...dateRange, end_date: e.target.value})}\n            />\n          </div>\n        </div>\n        \n        <button \n          className=\"btn-primary\" \n          onClick={handleGenerateReport}\n          disabled={loading}\n        >\n          {loading ? 'Generating...' : 'Generate Report'}\n        </button>\n      </div>\n      \n      {reportData && (\n        <div className=\"report-results\">\n          {reportType === 'summary' && (\n            <div className=\"summary-report\">\n              <h4>Summary Report</h4>\n              <div className=\"summary-stats\">\n                <div className=\"stat-card\">\n                  <div className=\"stat-value\">{reportData.total_rewards}</div>\n                  <div className=\"stat-label\">Total Rewards</div>\n                </div>\n                <div className=\"stat-card\">\n                  <div className=\"stat-value\">{formatCurrency(reportData.total_amount)}</div>\n                  <div className=\"stat-label\">Total Amount</div>\n                </div>\n              </div>\n              \n              <div className=\"report-section\">\n                <h5>By Status</h5>\n                <table className=\"data-table\">\n                  <thead>\n                    <tr>\n                      <th>Status</th>\n                      <th>Count</th>\n                      <th>Amount</th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    {Object.entries(reportData.by_status).map(([status, data]: [string, any]) => (\n                      <tr key={status}>\n                        <td>{status}</td>\n                        <td>{data.count}</td>\n                        <td>{formatCurrency(data.amount)}</td>\n                      </tr>\n                    ))}\n                  </tbody>\n                </table>\n              </div>\n              \n              <div className=\"report-section\">\n                <h5>By Type</h5>\n                <table className=\"data-table\">\n                  <thead>\n                    <tr>\n                      <th>Type</th>\n                      <th>Count</th>\n                      <th>Amount</th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    {Object.entries(reportData.by_type).map(([type, data]: [string, any]) => (\n                      <tr key={type}>\n                        <td>{type.replace('_', ' ')}</td>\n                        <td>{data.count}</td>\n                        <td>{formatCurrency(data.amount)}</td>\n                      </tr>\n                    ))}\n                  </tbody>\n                </table>\n              </div>\n            </div>\n          )}\n          \n          {reportType === 'advocates' && (\n            <div className=\"advocates-report\">\n              <h4>Advocate Rewards Report</h4>\n              <table className=\"data-table\">\n                <thead>\n                  <tr>\n                    <th>Advocate</th>\n                    <th>Rewards</th>\n                    <th>Total Amount</th>\n                    <th>Details</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {reportData.map((advocate: any) => (\n                    <tr key={advocate.advocate_id}>\n                      <td>{advocate.advocate_name}</td>\n                      <td>{advocate.total_rewards}</td>\n                      <td>{formatCurrency(advocate.total_amount)}</td>\n                      <td>\n                        <div className=\"reward-breakdown\">\n                          {Object.entries(advocate.by_type).map(([type, data]: [string, any]) => (\n                            <div key={type} className=\"breakdown-item\">\n                              {type.replace('_', ' ')}: {formatCurrency((data as any).amount)} ({(data as any).count})\n                            </div>\n                          ))}\n                        </div>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          )}\n          \n          {reportType === 'trends' && (\n            <div className=\"trends-report\">\n              <h4>Monthly Trends Report</h4>\n              <table className=\"data-table\">\n                <thead>\n                  <tr>\n                    <th>Month</th>\n                    <th>Rewards</th>\n                    <th>Total Amount</th>\n                    <th>By Type</th>\n                  </tr>\n                </thead>\n                <tbody>\n                  {Object.entries(reportData).map(([month, data]: [string, any]) => (\n                    <tr key={month}>\n                      <td>{month}</td>\n                      <td>{data.count}</td>\n                      <td>{formatCurrency(data.amount)}</td>\n                      <td>\n                        <div className=\"reward-breakdown\">\n                          {Object.entries(data.by_type).map(([type, amount]: [string, any]) => (\n                            <div key={type} className=\"breakdown-item\">\n                              {type.replace('_', ' ')}: {formatCurrency(amount)}\n                            </div>\n                          ))}\n                        </div>\n                      </td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n  \n  return (\n    <div className=\"reward-management\">\n      <h2>Reward Management</h2>\n      \n      <div className=\"tabs\">\n        <button \n          className={`tab ${activeTab === 'options' ? 'active' : ''}`}\n          onClick={() => setActiveTab('options')}\n        >\n          Reward Options\n        </button>\n        <button \n          className={`tab ${activeTab === 'approvals' ? 'active' : ''}`}\n          onClick={() => setActiveTab('approvals')}\n        >\n          Approvals\n        </button>\n        <button \n          className={`tab ${activeTab === 'reports' ? 'active' : ''}`}\n          onClick={() => setActiveTab('reports')}\n        >\n          Reports\n        </button>\n      </div>\n      \n      <div className=\"tab-content\">\n        {activeTab === 'options' && renderRewardOptionsTab()}\n        {activeTab === 'approvals' && renderApprovalsTab()}\n        {activeTab === 'reports' && renderReportsTab()}\n      </div>\n    </div>\n  );\n};\n\nexport default RewardManagement;\n```",
            "status": "pending",
            "testStrategy": "Test the admin interface with various reward options and approval scenarios. Verify that reports generate correctly with different parameters. Test the reward option creation and toggling functionality."
          }
        ]
      },
      {
        "id": 14,
        "title": "Analytics Dashboard",
        "description": "Develop the program analytics dashboard for tracking reference program performance, including revenue influence, conversion rates, and advocate satisfaction.",
        "details": "1. Implement data collection and aggregation:\n   - Reference call metrics\n   - Opportunity conversion tracking\n   - Advocate participation metrics\n   - Program ROI calculations\n2. Create dashboard components:\n```typescript\n// components/dashboard/RevenueInfluenceChart.tsx\nconst RevenueInfluenceChart = ({ companyId, dateRange }: Props) => {\n  const [data, setData] = useState<ChartData>()\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      const revenueData = await getRevenueInfluenceData(companyId, dateRange)\n      setData(formatChartData(revenueData))\n    }\n    \n    fetchData()\n  }, [companyId, dateRange])\n  \n  return (\n    <div className=\"chart-container\">\n      <h3>Revenue Influence</h3>\n      {data ? <LineChart data={data} /> : <LoadingSpinner />}\n    </div>\n  )\n}\n```\n3. Build executive reporting templates:\n   - Program summary reports\n   - ROI analysis\n   - Advocate engagement metrics\n4. Implement data export functionality\n5. Create custom report builder\n6. Implement real-time dashboard updates",
        "testStrategy": "Test data collection and aggregation with sample datasets. Verify chart rendering with various data scenarios. Test report generation and export functionality. Ensure dashboard performance with large datasets. Verify real-time updates.",
        "priority": "medium",
        "dependencies": [
          7,
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Multi-Tenant Architecture Implementation",
        "description": "Enhance the application with robust multi-tenant architecture for enterprise security, including tenant isolation, role-based access control, and white-label options.",
        "details": "1. Implement tenant isolation:\n   - Database row-level security policies\n   - API request tenant validation\n   - Storage isolation\n2. Create tenant middleware:\n```typescript\n// middleware/tenantMiddleware.ts\nexport function withTenant(handler) {\n  return async (req, res) => {\n    // Extract tenant ID from request\n    const tenantId = extractTenantId(req)\n    \n    if (!tenantId) {\n      return res.status(401).json({ error: 'Tenant ID not provided' })\n    }\n    \n    // Validate tenant access\n    const hasAccess = await validateTenantAccess(req.user, tenantId)\n    \n    if (!hasAccess) {\n      return res.status(403).json({ error: 'Access denied to this tenant' })\n    }\n    \n    // Add tenant context to request\n    req.tenantId = tenantId\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n3. Implement role-based access control:\n   - Permission definitions\n   - Role assignments\n   - Access control checks\n4. Build white-label customization:\n   - Theme customization\n   - Logo and branding settings\n   - Custom domain support\n5. Implement tenant-specific settings\n6. Create tenant provisioning and management tools",
        "testStrategy": "Test tenant isolation with cross-tenant access attempts. Verify role-based access control with various permission scenarios. Test white-label customization with different branding settings. Ensure proper tenant provisioning and management.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "API Development for Custom Integrations",
        "description": "Develop a comprehensive API for custom integrations, including authentication, rate limiting, and documentation.",
        "details": "1. Design RESTful API endpoints:\n   - Advocates management\n   - Opportunities management\n   - Reference calls management\n   - Analytics data access\n2. Implement API authentication:\n   - API key generation and validation\n   - OAuth 2.0 flow for third-party apps\n3. Create API middleware:\n```typescript\n// middleware/apiMiddleware.ts\nexport function withApiAuth(handler) {\n  return async (req, res) => {\n    // Extract API key from request\n    const apiKey = req.headers['x-api-key']\n    \n    if (!apiKey) {\n      return res.status(401).json({ error: 'API key required' })\n    }\n    \n    // Validate API key\n    const apiKeyData = await validateApiKey(apiKey)\n    \n    if (!apiKeyData) {\n      return res.status(403).json({ error: 'Invalid API key' })\n    }\n    \n    // Add API context to request\n    req.apiClient = apiKeyData.client\n    req.tenantId = apiKeyData.tenantId\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n4. Implement rate limiting and quota management\n5. Create API documentation using OpenAPI/Swagger\n6. Build API usage dashboard\n7. Implement webhook delivery for event notifications",
        "testStrategy": "Test API endpoints with various request scenarios. Verify authentication and authorization mechanisms. Test rate limiting with high-frequency requests. Ensure proper documentation generation. Verify webhook delivery for different events.",
        "priority": "low",
        "dependencies": [
          2,
          3,
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design RESTful API endpoints and data models",
            "description": "Define the API endpoints structure, request/response formats, and data models for advocates, opportunities, reference calls, and analytics data access.",
            "dependencies": [],
            "details": "Create a comprehensive API design document that includes:\n1. Base URL structure (e.g., /api/v1/)\n2. Endpoint definitions for each resource:\n   - Advocates: GET /advocates, POST /advocates, GET /advocates/:id, etc.\n   - Opportunities: GET /opportunities, POST /opportunities, etc.\n   - Reference calls: GET /calls, POST /calls, etc.\n   - Analytics: GET /analytics/metrics, GET /analytics/reports, etc.\n3. Request/response schemas for each endpoint\n4. Query parameter options for filtering, sorting, and pagination\n5. Error response standardization\n6. Data models in TypeScript interfaces for each resource type",
            "status": "pending",
            "testStrategy": "Review API design against REST best practices. Validate endpoint naming consistency and resource hierarchy. Ensure all required operations are covered."
          },
          {
            "id": 2,
            "title": "Implement API key generation and management",
            "description": "Create the system for generating, storing, and managing API keys for authentication.",
            "dependencies": [
              "16.1"
            ],
            "details": "1. Create database schema for API keys with fields: id, key (hashed), client_name, tenant_id, scopes, created_at, expires_at, last_used_at, status\n2. Implement API key generation service:\n```typescript\n// services/apiKeyService.ts\nexport const generateApiKey = async (clientName: string, tenantId: string, scopes: string[]) => {\n  // Generate random key with sufficient entropy\n  const key = crypto.randomBytes(32).toString('hex')\n  \n  // Hash for storage\n  const hashedKey = await bcrypt.hash(key, 10)\n  \n  // Store in database\n  const apiKey = await prisma.apiKey.create({\n    data: {\n      key: hashedKey,\n      client_name: clientName,\n      tenant_id: tenantId,\n      scopes,\n      expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year expiry\n      status: 'active'\n    }\n  })\n  \n  return { originalKey: key, apiKey }\n}\n```\n3. Implement API key validation function\n4. Create admin UI for API key management (list, create, revoke)",
            "status": "pending",
            "testStrategy": "Test API key generation for uniqueness and entropy. Verify key validation works with valid and invalid keys. Test key revocation immediately prevents access."
          },
          {
            "id": 3,
            "title": "Implement OAuth 2.0 authentication flow",
            "description": "Set up OAuth 2.0 authentication for third-party applications to securely access the API.",
            "dependencies": [
              "16.1"
            ],
            "details": "1. Set up OAuth 2.0 server implementation using a library like 'oauth2-server'\n2. Implement the authorization code flow:\n   - Authorization endpoint (/api/oauth/authorize)\n   - Token endpoint (/api/oauth/token)\n   - Token refresh endpoint (/api/oauth/refresh)\n3. Create client application registration system:\n```typescript\n// services/oauthService.ts\nexport const registerOAuthClient = async (name: string, redirectUris: string[], tenantId: string) => {\n  const clientId = generateUniqueId()\n  const clientSecret = crypto.randomBytes(32).toString('hex')\n  \n  const client = await prisma.oauthClient.create({\n    data: {\n      client_id: clientId,\n      client_secret: await bcrypt.hash(clientSecret, 10),\n      name,\n      redirect_uris: redirectUris,\n      tenant_id: tenantId,\n      created_at: new Date(),\n      status: 'active'\n    }\n  })\n  \n  return { client, clientSecret }\n}\n```\n4. Implement token validation middleware\n5. Create admin UI for OAuth client management",
            "status": "pending",
            "testStrategy": "Test the full OAuth flow with mock client applications. Verify token issuance, validation, and refresh. Test with invalid credentials and expired tokens. Ensure proper scope enforcement."
          },
          {
            "id": 4,
            "title": "Create API authentication middleware",
            "description": "Develop middleware to authenticate API requests using either API keys or OAuth tokens.",
            "dependencies": [
              "16.2",
              "16.3"
            ],
            "details": "1. Refine and expand the existing middleware to handle both authentication methods:\n```typescript\n// middleware/apiMiddleware.ts\nexport function withApiAuth(handler) {\n  return async (req, res) => {\n    // Check for API key authentication\n    const apiKey = req.headers['x-api-key']\n    \n    // Check for OAuth token authentication\n    const authHeader = req.headers['authorization']\n    const bearerToken = authHeader?.startsWith('Bearer ') ? authHeader.substring(7) : null\n    \n    if (!apiKey && !bearerToken) {\n      return res.status(401).json({ error: 'Authentication required' })\n    }\n    \n    try {\n      if (apiKey) {\n        // Validate API key\n        const apiKeyData = await validateApiKey(apiKey)\n        if (!apiKeyData) {\n          return res.status(403).json({ error: 'Invalid API key' })\n        }\n        req.auth = {\n          type: 'apiKey',\n          clientId: apiKeyData.client_name,\n          tenantId: apiKeyData.tenant_id,\n          scopes: apiKeyData.scopes\n        }\n      } else if (bearerToken) {\n        // Validate OAuth token\n        const tokenData = await validateOAuthToken(bearerToken)\n        if (!tokenData) {\n          return res.status(403).json({ error: 'Invalid token' })\n        }\n        req.auth = {\n          type: 'oauth',\n          clientId: tokenData.client_id,\n          tenantId: tokenData.tenant_id,\n          userId: tokenData.user_id,\n          scopes: tokenData.scopes\n        }\n      }\n      \n      // Continue to handler\n      return handler(req, res)\n    } catch (error) {\n      console.error('Authentication error:', error)\n      return res.status(500).json({ error: 'Authentication error' })\n    }\n  }\n}\n```\n2. Implement scope-based authorization middleware:\n```typescript\nexport function withApiScope(requiredScope) {\n  return (handler) => {\n    return withApiAuth(async (req, res) => {\n      if (!req.auth?.scopes?.includes(requiredScope)) {\n        return res.status(403).json({ error: 'Insufficient permissions' })\n      }\n      return handler(req, res)\n    })\n  }\n}\n```",
            "status": "pending",
            "testStrategy": "Test middleware with valid and invalid API keys and OAuth tokens. Verify proper extraction of authentication data. Test scope-based authorization with various permission scenarios."
          },
          {
            "id": 5,
            "title": "Implement rate limiting middleware",
            "description": "Create middleware to enforce rate limits on API requests based on client identity and endpoint.",
            "dependencies": [
              "16.4"
            ],
            "details": "1. Set up Redis for rate limit tracking\n2. Implement rate limiting middleware using a sliding window algorithm:\n```typescript\n// middleware/rateLimitMiddleware.ts\nimport { Redis } from 'ioredis'\nimport { NextApiRequest, NextApiResponse } from 'next'\n\nconst redis = new Redis(process.env.REDIS_URL)\n\nexport function withRateLimit(options: {\n  windowMs: number,\n  max: number,\n  keyGenerator?: (req: NextApiRequest) => string\n}) {\n  return (handler) => {\n    return async (req: NextApiRequest, res: NextApiResponse) => {\n      // Generate rate limit key based on client ID or IP\n      const key = options.keyGenerator\n        ? options.keyGenerator(req)\n        : `ratelimit:${req.auth?.clientId || req.socket.remoteAddress}:${req.method}:${req.url}`\n      \n      // Get current count\n      const now = Date.now()\n      const windowStart = now - options.windowMs\n      \n      // Add current request timestamp to the window\n      await redis.zadd(key, now, `${now}`)\n      \n      // Remove old entries outside the current window\n      await redis.zremrangebyscore(key, 0, windowStart)\n      \n      // Set expiry on the set\n      await redis.expire(key, Math.ceil(options.windowMs / 1000))\n      \n      // Count requests in the current window\n      const count = await redis.zcard(key)\n      \n      // Set rate limit headers\n      res.setHeader('X-RateLimit-Limit', options.max)\n      res.setHeader('X-RateLimit-Remaining', Math.max(0, options.max - count))\n      \n      // If over limit, return 429\n      if (count > options.max) {\n        return res.status(429).json({\n          error: 'Too many requests',\n          retryAfter: Math.ceil(options.windowMs / 1000)\n        })\n      }\n      \n      // Continue to handler\n      return handler(req, res)\n    }\n  }\n}\n```\n3. Create configuration for different rate limits based on endpoint and client tier\n4. Implement quota tracking for daily/monthly API usage limits",
            "status": "pending",
            "testStrategy": "Test rate limiting with rapid sequential requests. Verify correct headers are returned. Test different rate limit tiers. Ensure limits reset after the window period. Test quota tracking over longer periods."
          },
          {
            "id": 6,
            "title": "Implement advocates API endpoints",
            "description": "Create the API endpoints for managing advocates, including listing, creating, updating, and retrieving advocate data.",
            "dependencies": [
              "16.1",
              "16.4",
              "16.5"
            ],
            "details": "1. Implement the following endpoints:\n   - GET /api/v1/advocates - List advocates with filtering and pagination\n   - GET /api/v1/advocates/:id - Get advocate details\n   - POST /api/v1/advocates - Create new advocate\n   - PUT /api/v1/advocates/:id - Update advocate\n   - DELETE /api/v1/advocates/:id - Delete/deactivate advocate\n   - GET /api/v1/advocates/:id/availability - Get advocate availability\n\n2. Example implementation for listing advocates:\n```typescript\n// pages/api/v1/advocates/index.ts\nimport { withApiAuth } from '@/middleware/apiMiddleware'\nimport { withRateLimit } from '@/middleware/rateLimitMiddleware'\nimport { prisma } from '@/lib/prisma'\n\nconst handler = async (req, res) => {\n  if (req.method === 'GET') {\n    // Extract query parameters\n    const { page = 1, limit = 20, industry, use_case, search } = req.query\n    const skip = (Number(page) - 1) * Number(limit)\n    \n    // Build filter conditions\n    const where = {\n      tenant_id: req.auth.tenantId,\n      ...(industry ? { industry: { equals: industry } } : {}),\n      ...(use_case ? { use_cases: { has: use_case } } : {}),\n      ...(search ? {\n        OR: [\n          { name: { contains: search, mode: 'insensitive' } },\n          { company_name: { contains: search, mode: 'insensitive' } },\n          { title: { contains: search, mode: 'insensitive' } }\n        ]\n      } : {})\n    }\n    \n    // Execute query with pagination\n    const [advocates, total] = await Promise.all([\n      prisma.advocate.findMany({\n        where,\n        skip,\n        take: Number(limit),\n        orderBy: { name: 'asc' }\n      }),\n      prisma.advocate.count({ where })\n    ])\n    \n    // Return paginated results\n    return res.status(200).json({\n      data: advocates,\n      pagination: {\n        total,\n        page: Number(page),\n        limit: Number(limit),\n        pages: Math.ceil(total / Number(limit))\n      }\n    })\n  } else if (req.method === 'POST') {\n    // Validate request body\n    // Create advocate\n    // Return created advocate\n  } else {\n    res.setHeader('Allow', ['GET', 'POST'])\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n}\n\nexport default withRateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 60\n})(withApiAuth(handler))\n```\n\n3. Implement similar patterns for other advocate endpoints",
            "status": "pending",
            "testStrategy": "Test each endpoint with valid and invalid requests. Verify filtering and pagination work correctly. Test authorization with different client permissions. Ensure proper error handling for invalid inputs."
          },
          {
            "id": 7,
            "title": "Implement opportunities API endpoints",
            "description": "Create the API endpoints for managing opportunities, including listing, creating, updating, and retrieving opportunity data.",
            "dependencies": [
              "16.1",
              "16.4",
              "16.5"
            ],
            "details": "1. Implement the following endpoints:\n   - GET /api/v1/opportunities - List opportunities with filtering and pagination\n   - GET /api/v1/opportunities/:id - Get opportunity details\n   - POST /api/v1/opportunities - Create new opportunity\n   - PUT /api/v1/opportunities/:id - Update opportunity\n   - DELETE /api/v1/opportunities/:id - Delete/archive opportunity\n   - GET /api/v1/opportunities/:id/matches - Get matching advocates\n\n2. Example implementation for creating an opportunity:\n```typescript\n// pages/api/v1/opportunities/index.ts\nimport { withApiAuth } from '@/middleware/apiMiddleware'\nimport { withRateLimit } from '@/middleware/rateLimitMiddleware'\nimport { prisma } from '@/lib/prisma'\n\nconst handler = async (req, res) => {\n  if (req.method === 'GET') {\n    // Similar to advocates listing with appropriate filters\n  } else if (req.method === 'POST') {\n    try {\n      // Validate request body\n      const { \n        prospect_name, \n        prospect_email, \n        prospect_company, \n        prospect_title, \n        use_case, \n        industry, \n        company_size, \n        notes,\n        status = 'open'\n      } = req.body\n      \n      // Required fields validation\n      if (!prospect_name || !prospect_email || !prospect_company) {\n        return res.status(400).json({ \n          error: 'Missing required fields', \n          required: ['prospect_name', 'prospect_email', 'prospect_company'] \n        })\n      }\n      \n      // Create opportunity\n      const opportunity = await prisma.opportunity.create({\n        data: {\n          tenant_id: req.auth.tenantId,\n          prospect_name,\n          prospect_email,\n          prospect_company,\n          prospect_title,\n          use_case,\n          industry,\n          company_size,\n          notes,\n          status,\n          created_by: req.auth.userId || 'api',\n          created_at: new Date()\n        }\n      })\n      \n      return res.status(201).json(opportunity)\n    } catch (error) {\n      console.error('Error creating opportunity:', error)\n      return res.status(500).json({ error: 'Failed to create opportunity' })\n    }\n  } else {\n    res.setHeader('Allow', ['GET', 'POST'])\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n}\n\nexport default withRateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 60\n})(withApiAuth(handler))\n```\n\n3. Implement similar patterns for other opportunity endpoints",
            "status": "pending",
            "testStrategy": "Test each endpoint with valid and invalid requests. Verify filtering and pagination work correctly. Test authorization with different client permissions. Ensure proper error handling for invalid inputs."
          },
          {
            "id": 8,
            "title": "Implement reference calls API endpoints",
            "description": "Create the API endpoints for managing reference calls, including listing, creating, updating, and retrieving call data.",
            "dependencies": [
              "16.1",
              "16.4",
              "16.5"
            ],
            "details": "1. Implement the following endpoints:\n   - GET /api/v1/calls - List reference calls with filtering and pagination\n   - GET /api/v1/calls/:id - Get call details\n   - POST /api/v1/calls - Schedule new call\n   - PUT /api/v1/calls/:id - Update call details\n   - DELETE /api/v1/calls/:id - Cancel call\n   - GET /api/v1/calls/:id/feedback - Get call feedback\n\n2. Example implementation for scheduling a call:\n```typescript\n// pages/api/v1/calls/index.ts\nimport { withApiAuth } from '@/middleware/apiMiddleware'\nimport { withRateLimit } from '@/middleware/rateLimitMiddleware'\nimport { prisma } from '@/lib/prisma'\nimport { scheduleCall } from '@/services/calendarService'\n\nconst handler = async (req, res) => {\n  if (req.method === 'GET') {\n    // Similar to other listing endpoints with appropriate filters\n  } else if (req.method === 'POST') {\n    try {\n      // Validate request body\n      const { \n        opportunity_id, \n        advocate_id, \n        scheduled_at, \n        duration = 30, // minutes\n        meeting_type = 'video',\n        notes\n      } = req.body\n      \n      // Required fields validation\n      if (!opportunity_id || !advocate_id || !scheduled_at) {\n        return res.status(400).json({ \n          error: 'Missing required fields', \n          required: ['opportunity_id', 'advocate_id', 'scheduled_at'] \n        })\n      }\n      \n      // Verify opportunity and advocate exist and belong to tenant\n      const [opportunity, advocate] = await Promise.all([\n        prisma.opportunity.findFirst({\n          where: { id: opportunity_id, tenant_id: req.auth.tenantId }\n        }),\n        prisma.advocate.findFirst({\n          where: { id: advocate_id, tenant_id: req.auth.tenantId }\n        })\n      ])\n      \n      if (!opportunity) {\n        return res.status(404).json({ error: 'Opportunity not found' })\n      }\n      \n      if (!advocate) {\n        return res.status(404).json({ error: 'Advocate not found' })\n      }\n      \n      // Schedule call in calendar service\n      const meetingDetails = await scheduleCall({\n        advocate,\n        opportunity,\n        scheduledAt: new Date(scheduled_at),\n        duration,\n        meetingType\n      })\n      \n      // Create call record\n      const call = await prisma.referenceCall.create({\n        data: {\n          tenant_id: req.auth.tenantId,\n          opportunity_id,\n          advocate_id,\n          scheduled_at: new Date(scheduled_at),\n          duration,\n          meeting_type: meeting_type,\n          meeting_link: meetingDetails.meetingLink,\n          calendar_event_id: meetingDetails.calendarEventId,\n          notes,\n          status: 'scheduled',\n          created_by: req.auth.userId || 'api',\n          created_at: new Date()\n        }\n      })\n      \n      return res.status(201).json(call)\n    } catch (error) {\n      console.error('Error scheduling call:', error)\n      return res.status(500).json({ error: 'Failed to schedule call' })\n    }\n  } else {\n    res.setHeader('Allow', ['GET', 'POST'])\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n}\n\nexport default withRateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 60\n})(withApiAuth(handler))\n```\n\n3. Implement similar patterns for other call endpoints",
            "status": "pending",
            "testStrategy": "Test each endpoint with valid and invalid requests. Verify filtering and pagination work correctly. Test authorization with different client permissions. Ensure proper error handling for invalid inputs. Test integration with calendar service."
          },
          {
            "id": 9,
            "title": "Implement analytics API endpoints",
            "description": "Create the API endpoints for accessing analytics data, including metrics, reports, and raw data exports.",
            "dependencies": [
              "16.1",
              "16.4",
              "16.5"
            ],
            "details": "1. Implement the following endpoints:\n   - GET /api/v1/analytics/metrics - Get key performance metrics\n   - GET /api/v1/analytics/reports - Get predefined reports\n   - GET /api/v1/analytics/reports/:id - Get specific report data\n   - GET /api/v1/analytics/exports - Generate data exports\n\n2. Example implementation for metrics endpoint:\n```typescript\n// pages/api/v1/analytics/metrics.ts\nimport { withApiAuth } from '@/middleware/apiMiddleware'\nimport { withRateLimit } from '@/middleware/rateLimitMiddleware'\nimport { prisma } from '@/lib/prisma'\n\nconst handler = async (req, res) => {\n  if (req.method === 'GET') {\n    try {\n      // Extract query parameters\n      const { period = '30d' } = req.query\n      \n      // Calculate date range based on period\n      const now = new Date()\n      let startDate = new Date()\n      \n      switch (period) {\n        case '7d':\n          startDate.setDate(now.getDate() - 7)\n          break\n        case '30d':\n          startDate.setDate(now.getDate() - 30)\n          break\n        case '90d':\n          startDate.setDate(now.getDate() - 90)\n          break\n        case 'ytd':\n          startDate = new Date(now.getFullYear(), 0, 1) // January 1st of current year\n          break\n        default:\n          startDate.setDate(now.getDate() - 30) // Default to 30 days\n      }\n      \n      // Run queries in parallel\n      const [callsCompleted, callsScheduled, advocatesActive, opportunitiesCreated] = await Promise.all([\n        // Count completed calls in period\n        prisma.referenceCall.count({\n          where: {\n            tenant_id: req.auth.tenantId,\n            status: 'completed',\n            scheduled_at: {\n              gte: startDate,\n              lte: now\n            }\n          }\n        }),\n        \n        // Count scheduled calls (future)\n        prisma.referenceCall.count({\n          where: {\n            tenant_id: req.auth.tenantId,\n            status: 'scheduled',\n            scheduled_at: {\n              gte: now\n            }\n          }\n        }),\n        \n        // Count active advocates\n        prisma.advocate.count({\n          where: {\n            tenant_id: req.auth.tenantId,\n            status: 'active'\n          }\n        }),\n        \n        // Count opportunities created in period\n        prisma.opportunity.count({\n          where: {\n            tenant_id: req.auth.tenantId,\n            created_at: {\n              gte: startDate,\n              lte: now\n            }\n          }\n        })\n      ])\n      \n      // Return metrics\n      return res.status(200).json({\n        period,\n        start_date: startDate.toISOString(),\n        end_date: now.toISOString(),\n        metrics: {\n          calls_completed: callsCompleted,\n          calls_scheduled: callsScheduled,\n          advocates_active: advocatesActive,\n          opportunities_created: opportunitiesCreated\n        }\n      })\n    } catch (error) {\n      console.error('Error fetching metrics:', error)\n      return res.status(500).json({ error: 'Failed to fetch metrics' })\n    }\n  } else {\n    res.setHeader('Allow', ['GET'])\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n}\n\nexport default withRateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 30 // Lower limit for analytics endpoints\n})(withApiAuth(handler))\n```\n\n3. Implement similar patterns for other analytics endpoints",
            "status": "pending",
            "testStrategy": "Test each endpoint with different time periods and filters. Verify metrics calculations are accurate. Test with large datasets to ensure performance. Verify export functionality generates correct file formats."
          },
          {
            "id": 10,
            "title": "Implement webhook delivery system",
            "description": "Create a system for delivering webhook notifications to clients when events occur in the system.",
            "dependencies": [
              "16.4"
            ],
            "details": "1. Create webhook subscription management:\n```typescript\n// services/webhookService.ts\nimport { prisma } from '@/lib/prisma'\n\nexport interface WebhookPayload {\n  event: string\n  data: any\n  tenant_id: string\n  timestamp: string\n}\n\nexport const registerWebhook = async ({\n  tenantId,\n  url,\n  secret,\n  events,\n  description = ''\n}: {\n  tenantId: string\n  url: string\n  secret: string\n  events: string[]\n  description?: string\n}) => {\n  return prisma.webhook.create({\n    data: {\n      tenant_id: tenantId,\n      url,\n      secret,\n      events,\n      description,\n      status: 'active',\n      created_at: new Date()\n    }\n  })\n}\n\nexport const getWebhooksForEvent = async (event: string, tenantId: string) => {\n  return prisma.webhook.findMany({\n    where: {\n      tenant_id: tenantId,\n      status: 'active',\n      events: {\n        has: event\n      }\n    }\n  })\n}\n\nexport const deliverWebhook = async (webhook, payload: WebhookPayload) => {\n  try {\n    // Create signature for webhook verification\n    const signature = createHmacSignature(webhook.secret, JSON.stringify(payload))\n    \n    // Send webhook with retry logic\n    const response = await fetch(webhook.url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Webhook-Signature': signature\n      },\n      body: JSON.stringify(payload)\n    })\n    \n    // Log delivery attempt\n    await prisma.webhookDelivery.create({\n      data: {\n        webhook_id: webhook.id,\n        event: payload.event,\n        payload: payload,\n        status_code: response.status,\n        success: response.ok,\n        delivered_at: new Date()\n      }\n    })\n    \n    return response.ok\n  } catch (error) {\n    // Log failed delivery\n    await prisma.webhookDelivery.create({\n      data: {\n        webhook_id: webhook.id,\n        event: payload.event,\n        payload: payload,\n        status_code: 0,\n        success: false,\n        error_message: error.message,\n        delivered_at: new Date()\n      }\n    })\n    \n    return false\n  }\n}\n\nfunction createHmacSignature(secret: string, payload: string) {\n  const crypto = require('crypto')\n  return crypto.createHmac('sha256', secret).update(payload).digest('hex')\n}\n```\n\n2. Create webhook trigger functions for different events:\n```typescript\n// services/webhookService.ts (continued)\nexport const triggerWebhook = async (event: string, data: any, tenantId: string) => {\n  // Get webhooks subscribed to this event\n  const webhooks = await getWebhooksForEvent(event, tenantId)\n  \n  if (webhooks.length === 0) {\n    return\n  }\n  \n  // Prepare payload\n  const payload: WebhookPayload = {\n    event,\n    data,\n    tenant_id: tenantId,\n    timestamp: new Date().toISOString()\n  }\n  \n  // Deliver to all webhooks in parallel\n  await Promise.allSettled(\n    webhooks.map(webhook => deliverWebhook(webhook, payload))\n  )\n}\n```\n\n3. Implement webhook management API endpoints:\n   - GET /api/v1/webhooks - List webhooks\n   - POST /api/v1/webhooks - Register webhook\n   - DELETE /api/v1/webhooks/:id - Delete webhook\n   - GET /api/v1/webhooks/:id/deliveries - View delivery history\n\n4. Create webhook documentation with example payloads for each event type",
            "status": "pending",
            "testStrategy": "Test webhook delivery with mock endpoints. Verify signature validation works correctly. Test retry logic for failed deliveries. Verify all event types trigger appropriate webhooks. Test with malformed URLs and timeout scenarios."
          },
          {
            "id": 11,
            "title": "Create OpenAPI/Swagger documentation",
            "description": "Generate comprehensive API documentation using OpenAPI/Swagger specification.",
            "dependencies": [
              "16.1",
              "16.6",
              "16.7",
              "16.8",
              "16.9"
            ],
            "details": "1. Set up Swagger UI for API documentation:\n```typescript\n// pages/api/docs.ts\nimport { withApiAuth } from '@/middleware/apiMiddleware'\nimport { createSwaggerSpec } from 'next-swagger-doc'\nimport SwaggerUI from 'swagger-ui-react'\nimport 'swagger-ui-react/swagger-ui.css'\n\nconst apiSpec = createSwaggerSpec({\n  title: 'Advocate Platform API',\n  version: '1.0.0',\n  apiFolder: 'pages/api/v1',\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'Advocate Platform API',\n      version: '1.0.0',\n      description: 'API for managing advocates, opportunities, and reference calls',\n      contact: {\n        name: 'API Support',\n        email: 'support@example.com'\n      }\n    },\n    servers: [\n      {\n        url: 'https://app.example.com/api/v1',\n        description: 'Production server'\n      },\n      {\n        url: 'https://staging.example.com/api/v1',\n        description: 'Staging server'\n      },\n      {\n        url: 'http://localhost:3000/api/v1',\n        description: 'Local development server'\n      }\n    ],\n    components: {\n      securitySchemes: {\n        ApiKeyAuth: {\n          type: 'apiKey',\n          in: 'header',\n          name: 'x-api-key'\n        },\n        OAuth2: {\n          type: 'oauth2',\n          flows: {\n            authorizationCode: {\n              authorizationUrl: '/api/oauth/authorize',\n              tokenUrl: '/api/oauth/token',\n              scopes: {\n                'advocates:read': 'Read advocates',\n                'advocates:write': 'Modify advocates',\n                'opportunities:read': 'Read opportunities',\n                'opportunities:write': 'Modify opportunities',\n                'calls:read': 'Read reference calls',\n                'calls:write': 'Schedule and modify calls',\n                'analytics:read': 'Access analytics data'\n              }\n            }\n          }\n        }\n      },\n      schemas: {\n        Advocate: {\n          type: 'object',\n          properties: {\n            id: { type: 'string' },\n            name: { type: 'string' },\n            title: { type: 'string' },\n            company_name: { type: 'string' },\n            // Add all advocate properties\n          }\n        },\n        Opportunity: {\n          // Define opportunity schema\n        },\n        ReferenceCall: {\n          // Define call schema\n        }\n        // Add other schemas\n      }\n    }\n  }\n})\n\nconst ApiDocs = () => <SwaggerUI spec={apiSpec} />\n\nexport default ApiDocs\n```\n\n2. Add JSDoc comments to all API endpoint handlers for automatic documentation:\n```typescript\n/**\n * @swagger\n * /advocates:\n *   get:\n *     summary: List advocates\n *     description: Retrieve a list of advocates with optional filtering\n *     tags: [Advocates]\n *     parameters:\n *       - in: query\n *         name: page\n *         schema:\n *           type: integer\n *           default: 1\n *         description: Page number\n *       - in: query\n *         name: limit\n *         schema:\n *           type: integer\n *           default: 20\n *         description: Items per page\n *       - in: query\n *         name: industry\n *         schema:\n *           type: string\n *         description: Filter by industry\n *     security:\n *       - ApiKeyAuth: []\n *       - OAuth2: [advocates:read]\n *     responses:\n *       200:\n *         description: A paginated list of advocates\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/Advocate'\n *                 pagination:\n *                   type: object\n *                   properties:\n *                     total:\n *                       type: integer\n *                     page:\n *                       type: integer\n *                     limit:\n *                       type: integer\n *                     pages:\n *                       type: integer\n */\n```\n\n3. Create a static API documentation page that's accessible without authentication\n4. Generate downloadable OpenAPI specification file",
            "status": "pending",
            "testStrategy": "Verify documentation is generated correctly for all endpoints. Test the Swagger UI interface for usability. Ensure all models and parameters are documented. Validate the OpenAPI specification against the standard."
          },
          {
            "id": 12,
            "title": "Build API usage dashboard",
            "description": "Create a dashboard for clients to monitor their API usage, rate limits, and webhook deliveries.",
            "dependencies": [
              "16.5",
              "16.10"
            ],
            "details": "1. Create API usage tracking service:\n```typescript\n// services/apiUsageService.ts\nimport { prisma } from '@/lib/prisma'\n\nexport const trackApiRequest = async ({\n  clientId,\n  tenantId,\n  endpoint,\n  method,\n  statusCode,\n  responseTime\n}: {\n  clientId: string\n  tenantId: string\n  endpoint: string\n  method: string\n  statusCode: number\n  responseTime: number\n}) => {\n  // Store hourly aggregated data\n  const date = new Date()\n  const hour = date.getHours()\n  const day = date.getDate()\n  const month = date.getMonth() + 1\n  const year = date.getFullYear()\n  \n  // Create unique key for this hour\n  const hourlyKey = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}-${hour.toString().padStart(2, '0')}`\n  \n  // Update or create hourly stats\n  await prisma.apiUsageStat.upsert({\n    where: {\n      tenant_id_client_id_endpoint_method_hourly_key: {\n        tenant_id: tenantId,\n        client_id: clientId,\n        endpoint,\n        method,\n        hourly_key: hourlyKey\n      }\n    },\n    update: {\n      request_count: { increment: 1 },\n      error_count: statusCode >= 400 ? { increment: 1 } : undefined,\n      total_response_time: { increment: responseTime }\n    },\n    create: {\n      tenant_id: tenantId,\n      client_id: clientId,\n      endpoint,\n      method,\n      hourly_key: hourlyKey,\n      request_count: 1,\n      error_count: statusCode >= 400 ? 1 : 0,\n      total_response_time: responseTime,\n      year,\n      month,\n      day,\n      hour\n    }\n  })\n}\n\nexport const getApiUsage = async ({\n  tenantId,\n  clientId,\n  startDate,\n  endDate\n}: {\n  tenantId: string\n  clientId?: string\n  startDate: Date\n  endDate: Date\n}) => {\n  // Query aggregated usage data\n  const where = {\n    tenant_id: tenantId,\n    ...(clientId ? { client_id: clientId } : {}),\n    // Convert to date range condition\n    OR: [\n      {\n        year: { gt: startDate.getFullYear() },\n        year: { lt: endDate.getFullYear() }\n      },\n      {\n        year: startDate.getFullYear(),\n        month: { gte: startDate.getMonth() + 1 }\n      },\n      {\n        year: endDate.getFullYear(),\n        month: { lte: endDate.getMonth() + 1 }\n      }\n    ]\n  }\n  \n  return prisma.apiUsageStat.findMany({\n    where,\n    orderBy: [\n      { year: 'asc' },\n      { month: 'asc' },\n      { day: 'asc' },\n      { hour: 'asc' }\n    ]\n  })\n}\n```\n\n2. Implement API usage tracking middleware:\n```typescript\n// middleware/apiTrackingMiddleware.ts\nimport { trackApiRequest } from '@/services/apiUsageService'\n\nexport function withApiTracking(handler) {\n  return async (req, res) => {\n    const startTime = Date.now()\n    \n    // Create a proxy of the res object to capture the status code\n    const originalEnd = res.end\n    let statusCode = 200\n    \n    res.end = function(chunk, encoding) {\n      // Capture status code before ending response\n      statusCode = res.statusCode\n      \n      // Track API request asynchronously (don't await)\n      trackApiRequest({\n        clientId: req.auth?.clientId || 'anonymous',\n        tenantId: req.auth?.tenantId || 'anonymous',\n        endpoint: req.url.split('?')[0], // Remove query params\n        method: req.method,\n        statusCode,\n        responseTime: Date.now() - startTime\n      }).catch(err => console.error('Error tracking API usage:', err))\n      \n      // Call original end method\n      return originalEnd.call(this, chunk, encoding)\n    }\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n\n3. Create API usage dashboard endpoints:\n   - GET /api/v1/usage - Get usage statistics\n   - GET /api/v1/usage/rate-limits - Get current rate limit status\n   - GET /api/v1/usage/webhooks - Get webhook delivery statistics\n\n4. Build frontend dashboard with charts and tables for API usage visualization",
            "status": "pending",
            "testStrategy": "Test usage tracking with various API requests. Verify aggregation works correctly. Test dashboard with different date ranges and filters. Ensure rate limit information is accurate."
          },
          {
            "id": 13,
            "title": "Implement API versioning strategy",
            "description": "Set up a versioning strategy for the API to allow for future changes without breaking existing integrations.",
            "dependencies": [
              "16.1"
            ],
            "details": "1. Implement URL-based versioning:\n   - Structure all endpoints under /api/v1/...\n   - Create infrastructure for future versions (/api/v2/...)\n\n2. Create version routing middleware:\n```typescript\n// middleware/versionMiddleware.ts\nimport { NextApiRequest, NextApiResponse } from 'next'\n\nexport function withVersionRouting(handlers: {\n  v1?: (req: NextApiRequest, res: NextApiResponse) => Promise<void>\n  v2?: (req: NextApiRequest, res: NextApiResponse) => Promise<void>\n}) {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    // Extract version from URL path\n    const path = req.url.split('?')[0]\n    const versionMatch = path.match(/\\/api\\/(v\\d+)\\//)\n    const version = versionMatch ? versionMatch[1] : 'v1' // Default to v1\n    \n    // Check if handler exists for this version\n    if (handlers[version]) {\n      return handlers[version](req, res)\n    }\n    \n    // If no handler for this version, return 404\n    return res.status(404).json({\n      error: 'API version not found',\n      message: `The requested API version '${version}' is not supported.`\n    })\n  }\n}\n```\n\n3. Implement version header support:\n```typescript\n// middleware/versionHeaderMiddleware.ts\nexport function withVersionHeader(handler) {\n  return async (req, res) => {\n    // Add API version header to response\n    res.setHeader('X-API-Version', 'v1')\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n\n4. Create documentation for versioning policy:\n   - How long versions will be supported\n   - Deprecation process and timeline\n   - How breaking vs. non-breaking changes are handled",
            "status": "pending",
            "testStrategy": "Test routing to different API versions. Verify version headers are included in responses. Test with invalid version numbers. Ensure documentation clearly explains the versioning strategy."
          },
          {
            "id": 14,
            "title": "Implement comprehensive error handling",
            "description": "Create a standardized error handling system for the API with consistent error codes, messages, and documentation.",
            "dependencies": [
              "16.1"
            ],
            "details": "1. Create API error classes:\n```typescript\n// lib/errors.ts\nexport class ApiError extends Error {\n  statusCode: number\n  code: string\n  details?: any\n  \n  constructor(statusCode: number, code: string, message: string, details?: any) {\n    super(message)\n    this.statusCode = statusCode\n    this.code = code\n    this.details = details\n    this.name = 'ApiError'\n  }\n  \n  toJSON() {\n    return {\n      error: {\n        code: this.code,\n        message: this.message,\n        ...(this.details ? { details: this.details } : {})\n      }\n    }\n  }\n}\n\n// Common error types\nexport class BadRequestError extends ApiError {\n  constructor(message: string, details?: any) {\n    super(400, 'BAD_REQUEST', message, details)\n    this.name = 'BadRequestError'\n  }\n}\n\nexport class UnauthorizedError extends ApiError {\n  constructor(message: string = 'Authentication required') {\n    super(401, 'UNAUTHORIZED', message)\n    this.name = 'UnauthorizedError'\n  }\n}\n\nexport class ForbiddenError extends ApiError {\n  constructor(message: string = 'Insufficient permissions') {\n    super(403, 'FORBIDDEN', message)\n    this.name = 'ForbiddenError'\n  }\n}\n\nexport class NotFoundError extends ApiError {\n  constructor(resource: string) {\n    super(404, 'NOT_FOUND', `${resource} not found`)\n    this.name = 'NotFoundError'\n  }\n}\n\nexport class RateLimitError extends ApiError {\n  constructor(retryAfter: number) {\n    super(429, 'RATE_LIMIT_EXCEEDED', 'Rate limit exceeded', { retryAfter })\n    this.name = 'RateLimitError'\n  }\n}\n\nexport class ServerError extends ApiError {\n  constructor(message: string = 'Internal server error') {\n    super(500, 'SERVER_ERROR', message)\n    this.name = 'ServerError'\n  }\n}\n```\n\n2. Create error handling middleware:\n```typescript\n// middleware/errorHandlingMiddleware.ts\nimport { ApiError, ServerError } from '@/lib/errors'\n\nexport function withErrorHandling(handler) {\n  return async (req, res) => {\n    try {\n      return await handler(req, res)\n    } catch (error) {\n      console.error('API Error:', error)\n      \n      // If it's already an ApiError, use it directly\n      if (error instanceof ApiError) {\n        return res.status(error.statusCode).json(error.toJSON())\n      }\n      \n      // For validation errors from a validation library\n      if (error.name === 'ValidationError') {\n        return res.status(400).json({\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: 'Validation failed',\n            details: error.details || error.errors || error.message\n          }\n        })\n      }\n      \n      // For database unique constraint errors\n      if (error.code === 'P2002') { // Prisma unique constraint error\n        return res.status(409).json({\n          error: {\n            code: 'CONFLICT',\n            message: 'Resource already exists',\n            details: {\n              fields: error.meta?.target || []\n            }\n          }\n        })\n      }\n      \n      // For unknown errors, return a generic server error\n      const serverError = new ServerError()\n      return res.status(serverError.statusCode).json(serverError.toJSON())\n    }\n  }\n}\n```\n\n3. Create comprehensive error documentation with all possible error codes, their meanings, and how to resolve them\n\n4. Update all API endpoints to use the standardized error handling",
            "status": "pending",
            "testStrategy": "Test all error scenarios to ensure proper error responses. Verify error format is consistent across all endpoints. Test with various error types including validation errors, database errors, and custom API errors."
          },
          {
            "id": 15,
            "title": "Implement API integration tests",
            "description": "Create comprehensive integration tests for all API endpoints to ensure they work correctly.",
            "dependencies": [
              "16.6",
              "16.7",
              "16.8",
              "16.9",
              "16.10",
              "16.14"
            ],
            "details": "1. Set up testing infrastructure:\n```typescript\n// tests/api/setup.ts\nimport { createServer } from 'http'\nimport { apiResolver } from 'next/dist/server/api-utils/node'\nimport supertest from 'supertest'\nimport { prisma } from '@/lib/prisma'\n\n// Create a test client for API requests\nexport const createTestClient = (handler, path) => {\n  const server = createServer((req, res) => {\n    return apiResolver(\n      req,\n      res,\n      undefined,\n      handler,\n      {\n        previewModeId: '',\n        previewModeEncryptionKey: '',\n        previewModeSigningKey: ''\n      },\n      false\n    )\n  })\n  \n  return supertest(server)\n}\n\n// Setup and teardown helpers\nexport const setupTestDb = async () => {\n  // Create test data\n  const testTenant = await prisma.tenant.create({\n    data: {\n      name: 'Test Tenant',\n      domain: 'test.example.com'\n    }\n  })\n  \n  const testApiKey = await prisma.apiKey.create({\n    data: {\n      key: 'test-api-key-hashed', // Pre-hashed for testing\n      client_name: 'Test Client',\n      tenant_id: testTenant.id,\n      scopes: ['advocates:read', 'advocates:write', 'opportunities:read'],\n      status: 'active'\n    }\n  })\n  \n  return { testTenant, testApiKey }\n}\n\nexport const teardownTestDb = async () => {\n  // Clean up test data\n  await prisma.apiKey.deleteMany({\n    where: { client_name: 'Test Client' }\n  })\n  \n  await prisma.tenant.deleteMany({\n    where: { domain: 'test.example.com' }\n  })\n}\n```\n\n2. Create test helpers for authentication:\n```typescript\n// tests/api/helpers.ts\nimport { withApiAuth } from '@/middleware/apiMiddleware'\n\n// Mock the authentication middleware for testing\nexport const mockApiAuth = (handler, auth) => {\n  const mockedAuthMiddleware = (req, res) => {\n    req.auth = auth\n    return handler(req, res)\n  }\n  \n  return mockedAuthMiddleware\n}\n\n// Create a test handler with authentication\nexport const createAuthenticatedHandler = (handler, auth = {\n  type: 'apiKey',\n  clientId: 'test-client',\n  tenantId: 'test-tenant',\n  scopes: ['advocates:read', 'advocates:write', 'opportunities:read']\n}) => {\n  return mockApiAuth(handler, auth)\n}\n```\n\n3. Write integration tests for each endpoint group:\n```typescript\n// tests/api/advocates.test.ts\nimport { createTestClient, setupTestDb, teardownTestDb } from './setup'\nimport { createAuthenticatedHandler } from './helpers'\nimport advocatesHandler from '@/pages/api/v1/advocates'\n\ndescribe('Advocates API', () => {\n  let testData\n  \n  beforeAll(async () => {\n    testData = await setupTestDb()\n  })\n  \n  afterAll(async () => {\n    await teardownTestDb()\n  })\n  \n  describe('GET /api/v1/advocates', () => {\n    it('should return a list of advocates', async () => {\n      const handler = createAuthenticatedHandler(advocatesHandler, {\n        type: 'apiKey',\n        clientId: 'Test Client',\n        tenantId: testData.testTenant.id,\n        scopes: ['advocates:read']\n      })\n      \n      const client = createTestClient(handler, '/api/v1/advocates')\n      \n      const response = await client.get('/')\n      \n      expect(response.status).toBe(200)\n      expect(response.body).toHaveProperty('data')\n      expect(response.body).toHaveProperty('pagination')\n    })\n    \n    it('should return 403 when missing required scope', async () => {\n      const handler = createAuthenticatedHandler(advocatesHandler, {\n        type: 'apiKey',\n        clientId: 'Test Client',\n        tenantId: testData.testTenant.id,\n        scopes: ['opportunities:read'] // Missing advocates:read\n      })\n      \n      const client = createTestClient(handler, '/api/v1/advocates')\n      \n      const response = await client.get('/')\n      \n      expect(response.status).toBe(403)\n    })\n  })\n  \n  // Add tests for other advocate endpoints\n})\n```\n\n4. Create similar test files for other API endpoint groups (opportunities, calls, analytics, etc.)\n\n5. Set up CI/CD pipeline to run API tests automatically",
            "status": "pending",
            "testStrategy": "Run tests against a test database. Test all endpoints with valid and invalid inputs. Test authentication and authorization scenarios. Verify rate limiting behavior. Test error handling for various error conditions."
          }
        ]
      },
      {
        "id": 17,
        "title": "Mobile Responsive Implementation",
        "description": "Ensure the application is fully responsive on mobile devices, implementing a Progressive Web App (PWA) for improved mobile experience.",
        "details": "1. Implement responsive design for all components:\n   - Flexible layouts with CSS Grid and Flexbox\n   - Mobile-first media queries\n   - Touch-friendly UI elements\n2. Create mobile-specific components when needed:\n   - Mobile navigation\n   - Touch-optimized forms\n   - Mobile calendar view\n3. Implement PWA features:\n```typescript\n// next.config.js\nconst withPWA = require('next-pwa');\n\nmodule.exports = withPWA({\n  pwa: {\n    dest: 'public',\n    register: true,\n    skipWaiting: true,\n  },\n  // other Next.js config\n});\n```\n4. Create service worker for offline functionality\n5. Implement app manifest for home screen installation\n6. Optimize performance for mobile devices:\n   - Image optimization\n   - Code splitting\n   - Lazy loading",
        "testStrategy": "Test responsive design across various device sizes and orientations. Verify PWA functionality including offline access and installation. Test touch interactions on mobile devices. Measure performance metrics on mobile devices.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up responsive CSS foundation",
            "description": "Establish the core CSS foundation for responsive design using mobile-first approach with CSS Grid and Flexbox",
            "dependencies": [],
            "details": "Create a responsive design system with the following components:\n1. Set up global CSS variables for breakpoints (mobile, tablet, desktop)\n2. Implement a mobile-first media query system\n3. Create utility classes for responsive layouts using CSS Grid and Flexbox\n4. Establish responsive typography with relative units (rem/em)\n5. Implement responsive spacing system with consistent margins and padding",
            "status": "pending",
            "testStrategy": "Test the responsive foundation across various viewport sizes using browser dev tools. Verify that layouts adjust properly at defined breakpoints."
          },
          {
            "id": 2,
            "title": "Implement responsive navigation component",
            "description": "Create a mobile-optimized navigation component that transforms between mobile and desktop views",
            "dependencies": [
              "17.1"
            ],
            "details": "Implement a responsive navigation component that:\n1. Shows a hamburger menu on mobile devices\n2. Expands to full navigation bar on desktop\n3. Includes smooth transitions between states\n4. Supports touch interactions on mobile\n5. Maintains accessibility across all viewport sizes\n\nExample implementation:\n```tsx\nconst Navigation = () => {\n  const [isOpen, setIsOpen] = useState(false);\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  \n  return (\n    <nav className=\"responsive-nav\">\n      {isMobile ? (\n        <>\n          <button onClick={() => setIsOpen(!isOpen)} aria-label=\"Menu\">\n            <MenuIcon />\n          </button>\n          {isOpen && (\n            <div className=\"mobile-menu\">\n              {/* Navigation items */}\n            </div>\n          )}\n        </>\n      ) : (\n        <div className=\"desktop-nav\">\n          {/* Navigation items */}\n        </div>\n      )}\n    </nav>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "Test navigation functionality across different device sizes. Verify that the mobile menu opens/closes correctly and that all navigation items are accessible in both mobile and desktop views."
          },
          {
            "id": 3,
            "title": "Optimize form components for mobile",
            "description": "Enhance form components to be touch-friendly and responsive on mobile devices",
            "dependencies": [
              "17.1"
            ],
            "details": "Update form components to be mobile-optimized:\n1. Increase touch target sizes for inputs (min 44x44px)\n2. Implement mobile-friendly form layouts that stack vertically on small screens\n3. Use appropriate mobile keyboard types (email, number, tel, etc.)\n4. Add responsive validation messages that don't obstruct the form\n5. Implement touch-friendly custom form controls (dropdowns, date pickers)\n\nExample implementation for a responsive input:\n```tsx\nconst ResponsiveInput = ({ label, type, ...props }) => {\n  return (\n    <div className=\"form-field responsive-field\">\n      <label className=\"form-label\">{label}</label>\n      <input \n        type={type} \n        className=\"form-input\"\n        inputMode={type === 'number' ? 'numeric' : undefined}\n        {...props} \n      />\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "Test form components on various mobile devices to ensure touch targets are appropriately sized. Verify that form layouts adjust properly on small screens and that mobile keyboards are appropriate for input types."
          },
          {
            "id": 4,
            "title": "Create responsive calendar view",
            "description": "Implement a mobile-optimized calendar view that adapts to different screen sizes",
            "dependencies": [
              "17.1"
            ],
            "details": "Develop a responsive calendar component that:\n1. Shows a compact day/week view on mobile devices\n2. Expands to full month view on larger screens\n3. Supports touch gestures for navigation (swipe between days/months)\n4. Maintains all functionality across viewport sizes\n5. Optimizes event display for small screens\n\nImplement responsive layout switching based on screen size:\n```tsx\nconst CalendarView = () => {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  const [currentDate, setCurrentDate] = useState(new Date());\n  \n  return (\n    <div className=\"calendar-container\">\n      <CalendarNavigation date={currentDate} onChange={setCurrentDate} />\n      {isMobile ? (\n        <MobileDayView date={currentDate} events={events} />\n      ) : (\n        <DesktopMonthView date={currentDate} events={events} />\n      )}\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "Test calendar view across different device sizes to verify appropriate layout changes. Test touch gestures on mobile devices. Verify that all calendar functionality works correctly in both mobile and desktop views."
          },
          {
            "id": 5,
            "title": "Implement responsive data tables",
            "description": "Create mobile-friendly data table components that adapt to small screens",
            "dependencies": [
              "17.1"
            ],
            "details": "Implement responsive data tables that:\n1. Transform from tabular layout on desktop to card-based layout on mobile\n2. Allow horizontal scrolling for wide tables when necessary\n3. Prioritize important columns on small screens\n4. Maintain sorting and filtering capabilities across viewport sizes\n\nExample implementation:\n```tsx\nconst ResponsiveTable = ({ columns, data }) => {\n  const isMobile = useMediaQuery('(max-width: 768px)');\n  \n  if (isMobile) {\n    return (\n      <div className=\"mobile-table\">\n        {data.map((row, i) => (\n          <div key={i} className=\"mobile-table-card\">\n            {columns.map((column) => (\n              <div key={column.key} className=\"mobile-table-row\">\n                <div className=\"mobile-table-label\">{column.label}</div>\n                <div className=\"mobile-table-value\">{row[column.key]}</div>\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    );\n  }\n  \n  return (\n    <table className=\"desktop-table\">\n      {/* Standard table implementation */}\n    </table>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "Test data tables with various datasets to ensure they display correctly on different screen sizes. Verify that all functionality (sorting, filtering, pagination) works in both mobile and desktop views."
          },
          {
            "id": 6,
            "title": "Set up Next-PWA configuration",
            "description": "Configure Next.js with next-pwa to enable Progressive Web App functionality",
            "dependencies": [],
            "details": "Set up the PWA configuration for the Next.js application:\n1. Install the next-pwa package: `npm install next-pwa`\n2. Configure next.config.js to enable PWA features:\n```javascript\nconst withPWA = require('next-pwa');\n\nmodule.exports = withPWA({\n  pwa: {\n    dest: 'public',\n    register: true,\n    skipWaiting: true,\n    disable: process.env.NODE_ENV === 'development'\n  },\n  // other Next.js config\n});\n```\n3. Create a custom _document.js file if not already present to include necessary meta tags for PWA support\n4. Test the initial PWA configuration to ensure it's properly registered",
            "status": "pending",
            "testStrategy": "Verify that the service worker is registered in production build. Check Lighthouse PWA score to ensure basic PWA configuration is working correctly."
          },
          {
            "id": 7,
            "title": "Create Web App Manifest",
            "description": "Implement the web app manifest for home screen installation",
            "dependencies": [
              "17.6"
            ],
            "details": "Create a complete web app manifest file:\n1. Create manifest.json in the public directory with the following properties:\n```json\n{\n  \"name\": \"Application Name\",\n  \"short_name\": \"App\",\n  \"description\": \"Application description\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#4285f4\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\",\n      \"purpose\": \"any maskable\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n2. Generate appropriate app icons in multiple sizes (at minimum 192x192 and 512x512)\n3. Update _document.js to include the manifest link\n4. Test installation on various devices",
            "status": "pending",
            "testStrategy": "Test the app installation flow on both Android and iOS devices. Verify that the correct app name, icons, and colors are displayed during installation and after the app is installed."
          },
          {
            "id": 8,
            "title": "Implement offline functionality",
            "description": "Create service worker configuration for offline access and caching strategies",
            "dependencies": [
              "17.6",
              "17.7"
            ],
            "details": "Implement offline functionality using service workers:\n1. Configure caching strategies in next-pwa:\n```javascript\n// public/worker.js (custom worker configuration)\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('static-cache').then((cache) => {\n      return cache.addAll([\n        '/offline.html',\n        '/images/offline-image.png'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      return response || fetch(event.request).catch(() => {\n        return caches.match('/offline.html');\n      });\n    })\n  );\n});\n```\n2. Create an offline fallback page (offline.html)\n3. Implement data synchronization for offline data entry\n4. Add offline indicators in the UI when network is unavailable\n5. Test offline functionality in various network conditions",
            "status": "pending",
            "testStrategy": "Test the application with network connection disabled to verify offline functionality. Check that cached resources are served correctly and that the offline fallback page appears when appropriate."
          },
          {
            "id": 9,
            "title": "Implement mobile performance optimizations",
            "description": "Optimize application performance specifically for mobile devices",
            "dependencies": [
              "17.1",
              "17.6"
            ],
            "details": "Implement performance optimizations for mobile devices:\n1. Configure image optimization using Next.js Image component:\n```tsx\nimport Image from 'next/image';\n\nconst OptimizedImage = ({ src, alt, ...props }) => {\n  return (\n    <div className=\"optimized-image-container\">\n      <Image\n        src={src}\n        alt={alt}\n        layout=\"responsive\"\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n        {...props}\n      />\n    </div>\n  );\n};\n```\n2. Implement code splitting for route-based components\n3. Add lazy loading for below-the-fold content:\n```tsx\nimport dynamic from 'next/dynamic';\n\nconst LazyComponent = dynamic(() => import('../components/HeavyComponent'), {\n  loading: () => <LoadingPlaceholder />,\n  ssr: false\n});\n```\n4. Optimize font loading with font-display: swap\n5. Implement resource hints (preconnect, prefetch) for critical resources\n6. Minimize main thread work with web workers for heavy computations",
            "status": "pending",
            "testStrategy": "Measure performance metrics (FCP, LCP, TTI, CLS) on mobile devices using Lighthouse and WebPageTest. Compare before and after optimization to verify improvements."
          },
          {
            "id": 10,
            "title": "Implement push notifications",
            "description": "Add push notification support for mobile engagement",
            "dependencies": [
              "17.6",
              "17.8"
            ],
            "details": "Implement push notifications for the PWA:\n1. Set up push notification subscription flow:\n```tsx\nconst subscribeToPushNotifications = async () => {\n  try {\n    const registration = await navigator.serviceWorker.ready;\n    const subscription = await registration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: urlBase64ToUint8Array(process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY)\n    });\n    \n    // Send subscription to server\n    await fetch('/api/push/subscribe', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ subscription })\n    });\n    \n    return true;\n  } catch (error) {\n    console.error('Error subscribing to push notifications:', error);\n    return false;\n  }\n};\n```\n2. Create notification permission request UI\n3. Implement server-side notification sending API\n4. Configure service worker to handle incoming push events\n5. Add notification action handlers\n6. Implement notification preferences in user settings",
            "status": "pending",
            "testStrategy": "Test push notification subscription flow and delivery on both Android and iOS devices. Verify that notification actions work correctly and that notifications appear appropriately in different application states."
          },
          {
            "id": 11,
            "title": "Implement app install promotion",
            "description": "Create UI components to encourage PWA installation",
            "dependencies": [
              "17.7"
            ],
            "details": "Implement app installation promotion:\n1. Create an install banner component that detects installation eligibility:\n```tsx\nconst InstallBanner = () => {\n  const [showInstallBanner, setShowInstallBanner] = useState(false);\n  const [deferredPrompt, setDeferredPrompt] = useState(null);\n  \n  useEffect(() => {\n    const handleBeforeInstallPrompt = (e) => {\n      // Prevent Chrome 76+ from automatically showing the prompt\n      e.preventDefault();\n      // Stash the event so it can be triggered later\n      setDeferredPrompt(e);\n      // Show the install banner\n      setShowInstallBanner(true);\n    };\n    \n    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);\n    return () => {\n      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);\n    };\n  }, []);\n  \n  const handleInstallClick = async () => {\n    if (!deferredPrompt) return;\n    \n    // Show the install prompt\n    deferredPrompt.prompt();\n    \n    // Wait for the user to respond to the prompt\n    const { outcome } = await deferredPrompt.userChoice;\n    \n    // We no longer need the prompt regardless of outcome\n    setDeferredPrompt(null);\n    setShowInstallBanner(false);\n  };\n  \n  if (!showInstallBanner) return null;\n  \n  return (\n    <div className=\"install-banner\">\n      <p>Install our app for a better experience!</p>\n      <button onClick={handleInstallClick}>Install</button>\n      <button onClick={() => setShowInstallBanner(false)}>Dismiss</button>\n    </div>\n  );\n};\n```\n2. Implement install instructions for different platforms\n3. Add periodic reminders for installation\n4. Track installation analytics\n5. Create A/B tests for different installation prompts",
            "status": "pending",
            "testStrategy": "Test the install banner on various devices to ensure it appears correctly when the app is eligible for installation. Verify that the installation flow works properly when the user clicks the install button."
          },
          {
            "id": 12,
            "title": "Implement mobile-specific gestures",
            "description": "Add touch gesture support for improved mobile interaction",
            "dependencies": [
              "17.1"
            ],
            "details": "Implement touch gestures for mobile interaction:\n1. Add swipe gestures for navigation and actions:\n```tsx\nimport { useSwipeable } from 'react-swipeable';\n\nconst SwipeableComponent = () => {\n  const handlers = useSwipeable({\n    onSwipedLeft: () => handleNextItem(),\n    onSwipedRight: () => handlePreviousItem(),\n    preventDefaultTouchmoveEvent: true,\n    trackMouse: false\n  });\n  \n  return (\n    <div {...handlers} className=\"swipeable-container\">\n      {/* Content */}\n    </div>\n  );\n};\n```\n2. Implement pull-to-refresh for content updates\n3. Add pinch-to-zoom for images and documents\n4. Create custom touch feedback effects\n5. Ensure all gesture interactions have accessible alternatives\n6. Test gesture performance on various mobile devices",
            "status": "pending",
            "testStrategy": "Test gesture interactions on various mobile devices to ensure they work smoothly and provide appropriate feedback. Verify that all gesture-based interactions have accessible alternatives."
          },
          {
            "id": 13,
            "title": "Implement mobile-specific UI adaptations",
            "description": "Create UI adaptations for specific mobile device features and constraints",
            "dependencies": [
              "17.1",
              "17.2",
              "17.3",
              "17.4",
              "17.5"
            ],
            "details": "Implement mobile-specific UI adaptations:\n1. Handle notches and safe areas on modern devices:\n```css\n.safe-area-container {\n  padding-left: env(safe-area-inset-left);\n  padding-right: env(safe-area-inset-right);\n  padding-top: env(safe-area-inset-top);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n```\n2. Create a bottom sheet component for mobile interactions\n3. Implement a floating action button (FAB) for primary actions on mobile\n4. Add mobile-specific tooltips and help elements\n5. Create compact versions of data visualizations for small screens\n6. Implement mobile-specific error and empty states",
            "status": "pending",
            "testStrategy": "Test UI adaptations on various mobile devices with different screen sizes, notches, and form factors. Verify that the UI properly respects safe areas and device constraints."
          },
          {
            "id": 14,
            "title": "Conduct comprehensive responsive testing",
            "description": "Perform thorough testing of responsive design and PWA functionality across devices",
            "dependencies": [
              "17.1",
              "17.2",
              "17.3",
              "17.4",
              "17.5",
              "17.6",
              "17.7",
              "17.8",
              "17.9",
              "17.10",
              "17.11",
              "17.12",
              "17.13"
            ],
            "details": "Conduct comprehensive testing of responsive design and PWA functionality:\n1. Create a testing matrix covering:\n   - Different device types (phone, tablet, desktop)\n   - Various screen sizes and orientations\n   - Different browsers (Chrome, Safari, Firefox)\n   - Operating systems (iOS, Android, Windows, macOS)\n2. Test PWA installation flow on all supported platforms\n3. Verify offline functionality in various network conditions\n4. Test performance metrics using Lighthouse and WebPageTest\n5. Conduct usability testing with real users on mobile devices\n6. Create automated tests for responsive breakpoints:\n```typescript\ndescribe('Responsive Design Tests', () => {\n  const breakpoints = {\n    mobile: 375,\n    tablet: 768,\n    desktop: 1024\n  };\n  \n  Object.entries(breakpoints).forEach(([device, width]) => {\n    it(`should display correct layout on ${device}`, async () => {\n      await page.setViewport({ width, height: 800 });\n      await page.goto('/');\n      \n      const screenshot = await page.screenshot();\n      expect(screenshot).toMatchImageSnapshot({\n        customSnapshotIdentifier: `homepage-${device}`\n      });\n    });\n  });\n});\n```",
            "status": "pending",
            "testStrategy": "Use a combination of manual testing on physical devices, automated visual regression testing, Lighthouse audits, and user testing sessions to verify responsive design and PWA functionality."
          }
        ]
      },
      {
        "id": 18,
        "title": "Email Notification System",
        "description": "Implement a comprehensive email notification system for various events, including booking confirmations, reminders, and system notifications.",
        "details": "1. Set up SendGrid integration:\n   - API configuration\n   - Email templates\n   - Tracking and analytics\n2. Create email service:\n```typescript\n// services/emailService.ts\nexport const sendEmail = async (options: EmailOptions) => {\n  const { to, templateId, dynamicData } = options\n  \n  const msg = {\n    to,\n    from: process.env.SENDGRID_FROM_EMAIL,\n    templateId,\n    dynamicTemplateData: dynamicData,\n  }\n  \n  try {\n    await sendgrid.send(msg)\n    await logEmailSent(options)\n    return true\n  } catch (error) {\n    console.error('Email sending failed:', error)\n    await logEmailError(options, error)\n    return false\n  }\n}\n\nexport const sendBookingConfirmation = async (booking) => {\n  return sendEmail({\n    to: booking.prospect_email,\n    templateId: 'd-booking-confirmation-template-id',\n    dynamicData: {\n      advocate_name: booking.advocate.name,\n      meeting_time: formatDateTime(booking.scheduled_at),\n      meeting_link: booking.meeting_link,\n      // Other dynamic data\n    }\n  })\n}\n```\n3. Implement email templates for various events:\n   - Welcome emails\n   - Booking confirmations\n   - Meeting reminders\n   - Call follow-ups\n   - System notifications\n4. Create email preference management\n5. Implement email delivery tracking and reporting\n6. Build email template management interface",
        "testStrategy": "Test email sending with various templates and dynamic data. Verify email delivery tracking. Test email preference management. Ensure proper error handling for failed deliveries. Verify template rendering across email clients.",
        "priority": "high",
        "dependencies": [
          3,
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up SendGrid API Integration",
            "description": "Configure SendGrid API integration for email sending capabilities",
            "dependencies": [],
            "details": "1. Create a SendGrid account if not already available\n2. Generate API keys with appropriate permissions\n3. Set up environment variables for API keys and sender email\n4. Install SendGrid SDK: `npm install @sendgrid/mail`\n5. Create a basic configuration file to initialize the SendGrid client\n6. Implement a simple test function to verify connectivity",
            "status": "pending",
            "testStrategy": "Create a test that sends a simple email to verify API connectivity. Use a test API key and mock responses for unit tests."
          },
          {
            "id": 2,
            "title": "Implement Core Email Service",
            "description": "Create the core email service with base functionality for sending emails",
            "dependencies": [
              "18.1"
            ],
            "details": "1. Create `services/emailService.ts` with the following:\n   - Define EmailOptions interface with to, templateId, dynamicData fields\n   - Implement sendEmail function that takes EmailOptions\n   - Add proper error handling and logging\n   - Create utility functions for email logging (logEmailSent, logEmailError)\n2. Set up email queue mechanism for retry capability\n3. Implement rate limiting to comply with SendGrid limits",
            "status": "pending",
            "testStrategy": "Unit test the email service with mocked SendGrid responses. Test error handling paths and verify logging functions are called correctly."
          },
          {
            "id": 3,
            "title": "Create Email Templates in SendGrid",
            "description": "Set up the required email templates in SendGrid for various notification types",
            "dependencies": [
              "18.1"
            ],
            "details": "1. Design and create the following templates in SendGrid:\n   - Welcome email template\n   - Booking confirmation template\n   - Meeting reminder template\n   - Call follow-up template\n   - System notification template\n2. Use SendGrid's dynamic template system with handlebars syntax\n3. Record template IDs for use in the application\n4. Ensure templates are responsive and work across email clients\n5. Include appropriate branding elements",
            "status": "pending",
            "testStrategy": "Send test emails using each template to verify rendering. Check on multiple email clients (Gmail, Outlook, mobile)."
          },
          {
            "id": 4,
            "title": "Implement Email Type-Specific Sender Functions",
            "description": "Create specialized functions for sending different types of notification emails",
            "dependencies": [
              "18.2",
              "18.3"
            ],
            "details": "1. Extend emailService.ts with the following functions:\n   - sendWelcomeEmail(user)\n   - sendBookingConfirmation(booking)\n   - sendMeetingReminder(booking)\n   - sendCallFollowUp(booking)\n   - sendSystemNotification(user, message)\n2. Each function should prepare the appropriate dynamic data for its template\n3. Implement proper type checking for parameters\n4. Add appropriate error handling for each function",
            "status": "pending",
            "testStrategy": "Unit test each specialized function to ensure it calls sendEmail with correct parameters. Test with various input scenarios including edge cases."
          },
          {
            "id": 5,
            "title": "Implement Email Delivery Tracking",
            "description": "Create a system to track email delivery status and user interactions",
            "dependencies": [
              "18.2"
            ],
            "details": "1. Create database schema for email tracking:\n   - Email ID\n   - Recipient\n   - Template used\n   - Sent timestamp\n   - Delivery status\n   - Open tracking\n   - Click tracking\n2. Set up SendGrid webhooks to receive delivery events\n3. Create API endpoint to receive webhook data\n4. Implement handlers for different event types (delivered, opened, clicked, bounced)\n5. Update email records based on webhook data",
            "status": "pending",
            "testStrategy": "Test webhook endpoint with sample SendGrid event payloads. Verify database records are updated correctly. Test handling of different event types."
          },
          {
            "id": 6,
            "title": "Create Email Preference Management",
            "description": "Implement a system for users to manage their email notification preferences",
            "dependencies": [
              "18.2"
            ],
            "details": "1. Create database schema for email preferences:\n   - User ID\n   - Preference categories (booking notifications, reminders, marketing, etc.)\n   - Opt-in/opt-out status for each category\n2. Create API endpoints for getting and updating preferences\n3. Implement UI components for preference management\n4. Modify email sending functions to check preferences before sending\n5. Add unsubscribe links to email templates\n6. Implement unsubscribe handling",
            "status": "pending",
            "testStrategy": "Test preference saving and retrieval. Verify emails are not sent when users have opted out. Test unsubscribe link functionality."
          },
          {
            "id": 7,
            "title": "Implement Email Queuing and Retry Mechanism",
            "description": "Create a robust queuing system for emails with retry capability for failed deliveries",
            "dependencies": [
              "18.2"
            ],
            "details": "1. Set up a queue system (can use database or message queue like Redis)\n2. Modify sendEmail to queue emails instead of sending immediately\n3. Create a worker process to process the email queue\n4. Implement exponential backoff for retries\n5. Set maximum retry attempts\n6. Add status tracking for queued emails\n7. Implement cleanup for successfully sent emails",
            "status": "pending",
            "testStrategy": "Test queue processing with simulated failures. Verify retry mechanism works with appropriate backoff. Test queue cleanup after successful sending."
          },
          {
            "id": 8,
            "title": "Create Email Analytics Dashboard",
            "description": "Build a dashboard to display email delivery metrics and engagement statistics",
            "dependencies": [
              "18.5"
            ],
            "details": "1. Design analytics dashboard UI\n2. Implement API endpoints to retrieve email statistics:\n   - Delivery rate\n   - Open rate\n   - Click rate\n   - Bounce rate\n   - Statistics by template type\n3. Create data visualization components\n4. Add filtering capabilities by date range and email type\n5. Implement export functionality for reports",
            "status": "pending",
            "testStrategy": "Test dashboard with sample data. Verify calculations are correct. Test filters and export functionality."
          },
          {
            "id": 9,
            "title": "Implement Email Template Management Interface",
            "description": "Create an admin interface for managing email templates and content",
            "dependencies": [
              "18.3"
            ],
            "details": "1. Design template management UI\n2. Create API endpoints for:\n   - Listing available templates\n   - Viewing template details\n   - Updating template content (via SendGrid API)\n   - Testing templates with sample data\n3. Implement preview functionality\n4. Add version history tracking\n5. Create approval workflow for template changes",
            "status": "pending",
            "testStrategy": "Test template management operations. Verify changes are correctly applied in SendGrid. Test preview functionality with various data inputs."
          },
          {
            "id": 10,
            "title": "Integrate Email System with Booking Flow",
            "description": "Connect the email notification system with the booking process",
            "dependencies": [
              "18.4"
            ],
            "details": "1. Identify all points in the booking flow that require email notifications:\n   - Initial booking request\n   - Booking confirmation\n   - Booking updates/changes\n   - Booking cancellation\n   - Pre-meeting reminders\n   - Post-meeting follow-ups\n2. Integrate appropriate email functions at each point\n3. Ensure all necessary data is available for email templates\n4. Add appropriate error handling",
            "status": "pending",
            "testStrategy": "Test the entire booking flow and verify emails are sent at appropriate points. Test with various booking scenarios including changes and cancellations."
          },
          {
            "id": 11,
            "title": "Implement System Notification Emails",
            "description": "Create email notifications for system events and administrative alerts",
            "dependencies": [
              "18.4"
            ],
            "details": "1. Identify system events requiring notifications:\n   - New user registrations\n   - Account changes\n   - Security alerts\n   - System maintenance\n   - Error reports\n2. Create templates for each notification type\n3. Implement triggering mechanisms for each event\n4. Add recipient configuration for admin notifications\n5. Implement priority levels for notifications",
            "status": "pending",
            "testStrategy": "Test each system event to verify it triggers appropriate notifications. Test priority handling and recipient configuration."
          },
          {
            "id": 12,
            "title": "Add Email Localization Support",
            "description": "Implement support for localized email content in multiple languages",
            "dependencies": [
              "18.3",
              "18.4"
            ],
            "details": "1. Modify email templates to support localization\n2. Create translation files for supported languages\n3. Update EmailOptions interface to include locale parameter\n4. Modify sendEmail function to select appropriate template based on locale\n5. Implement fallback to default language\n6. Add date/time formatting based on locale",
            "status": "pending",
            "testStrategy": "Test email sending with different locales. Verify correct templates are used. Test fallback behavior when translations are missing."
          }
        ]
      },
      {
        "id": 19,
        "title": "Security Implementation and Compliance",
        "description": "Implement comprehensive security measures and compliance features, including SOC 2 compliance, GDPR/CCPA compliance, and data encryption.",
        "details": "1. Implement security best practices:\n   - HTTPS enforcement\n   - Content Security Policy\n   - CSRF protection\n   - XSS prevention\n2. Set up data encryption:\n   - Encryption at rest\n   - Encryption in transit\n   - Sensitive data handling\n3. Implement compliance features:\n   - Data retention policies\n   - Data export functionality\n   - Consent management\n   - Privacy policy implementation\n4. Create security monitoring and logging:\n```typescript\n// middleware/securityMiddleware.ts\nexport function withSecurityHeaders(handler) {\n  return (req, res) => {\n    // Set security headers\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n    res.setHeader('X-Frame-Options', 'DENY')\n    res.setHeader('X-XSS-Protection', '1; mode=block')\n    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin')\n    res.setHeader('Content-Security-Policy', \"default-src 'self'; script-src 'self' 'unsafe-inline';\")\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n\nexport function withAuditLogging(handler) {\n  return async (req, res) => {\n    // Log request details\n    const requestId = generateRequestId()\n    const startTime = Date.now()\n    \n    // Create response wrapper to capture status\n    const originalEnd = res.end\n    res.end = function(...args) {\n      const duration = Date.now() - startTime\n      logAuditEvent({\n        requestId,\n        userId: req.user?.id,\n        tenantId: req.tenantId,\n        method: req.method,\n        path: req.url,\n        statusCode: res.statusCode,\n        duration,\n        userAgent: req.headers['user-agent']\n      })\n      originalEnd.apply(res, args)\n    }\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n5. Implement authentication security:\n   - Multi-factor authentication\n   - Password policies\n   - Session management\n6. Create security documentation and compliance reports",
        "testStrategy": "Conduct security testing including penetration testing and vulnerability scanning. Verify compliance features with regulatory requirements. Test data encryption and access controls. Ensure proper audit logging and monitoring. Verify authentication security measures.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement HTTPS enforcement and security headers",
            "description": "Configure the application to enforce HTTPS connections and implement security headers to protect against common web vulnerabilities.",
            "dependencies": [],
            "details": "Create a middleware that enforces HTTPS in production environments using Next.js config. Enhance the existing security headers middleware to include HSTS headers. Implement redirects from HTTP to HTTPS. Configure security headers in Next.js config file and ensure they're applied globally. Test headers using security scanning tools.",
            "status": "pending",
            "testStrategy": "Verify HTTPS enforcement by attempting HTTP connections. Use tools like SecurityHeaders.com to validate header implementation. Test redirects from HTTP to HTTPS in staging environment."
          },
          {
            "id": 2,
            "title": "Implement CSRF protection",
            "description": "Add Cross-Site Request Forgery protection to all forms and API endpoints that modify data.",
            "dependencies": [
              "19.1"
            ],
            "details": "Implement CSRF token generation and validation using a library compatible with Next.js (like next-csrf). Add CSRF token to all forms in the application. Create middleware to validate CSRF tokens on all POST/PUT/DELETE API routes. Update API client to automatically include CSRF tokens in requests. Document CSRF implementation for developers.",
            "status": "pending",
            "testStrategy": "Test form submissions with valid and invalid CSRF tokens. Verify API requests are rejected when CSRF token is missing or invalid. Test token rotation and expiration."
          },
          {
            "id": 3,
            "title": "Implement XSS prevention measures",
            "description": "Add protection against Cross-Site Scripting attacks by implementing content sanitization and proper output encoding.",
            "dependencies": [
              "19.1"
            ],
            "details": "Implement input validation and sanitization for all user inputs using a library like DOMPurify. Configure React to use proper escaping for dynamic content. Update Content-Security-Policy to restrict inline scripts and use nonces where necessary. Create helpers for safely displaying user-generated content. Audit existing code for potential XSS vulnerabilities.",
            "status": "pending",
            "testStrategy": "Test with payloads designed to trigger XSS. Verify sanitization works correctly for different input types. Validate CSP blocks unauthorized script execution."
          },
          {
            "id": 4,
            "title": "Implement encryption at rest",
            "description": "Set up encryption for sensitive data stored in the database and file storage systems.",
            "dependencies": [],
            "details": "Identify all sensitive data fields requiring encryption. Implement field-level encryption for sensitive database columns using a library like node-crypto. Create encryption/decryption utilities with proper key management. Set up encrypted volumes for file storage. Document encryption implementation and key management procedures.",
            "status": "pending",
            "testStrategy": "Verify sensitive data is stored in encrypted format in the database. Test encryption/decryption functionality with various data types. Validate key rotation procedures."
          },
          {
            "id": 5,
            "title": "Implement encryption in transit",
            "description": "Ensure all data transmitted between systems is properly encrypted using TLS and secure communication channels.",
            "dependencies": [
              "19.1"
            ],
            "details": "Configure TLS 1.2+ for all services. Implement secure WebSocket connections. Ensure all API clients use HTTPS. Configure secure cookies with httpOnly and secure flags. Implement proper certificate management and validation. Test and document secure communication channels.",
            "status": "pending",
            "testStrategy": "Verify all connections use TLS 1.2+. Test certificate validation. Check for insecure mixed content. Validate secure cookie implementation."
          },
          {
            "id": 6,
            "title": "Implement sensitive data handling procedures",
            "description": "Create secure processes for handling sensitive data including masking, tokenization, and secure transmission.",
            "dependencies": [
              "19.4",
              "19.5"
            ],
            "details": "Implement data masking for PII in logs and UI. Create tokenization service for sensitive data like payment information. Develop secure data transmission protocols between services. Implement secure data viewing with audit logging. Create utilities for securely handling sensitive data in memory.",
            "status": "pending",
            "testStrategy": "Verify PII is properly masked in logs and UI. Test tokenization and detokenization processes. Validate secure transmission between services."
          },
          {
            "id": 7,
            "title": "Implement data retention policies",
            "description": "Create and enforce data retention policies that comply with relevant regulations and allow for proper data lifecycle management.",
            "dependencies": [
              "19.4"
            ],
            "details": "Define data retention periods for different data categories. Implement automated data purging for expired data. Create data archiving functionality for historical data. Develop admin interfaces for managing retention policies. Implement audit logging for data deletion and archiving actions.",
            "status": "pending",
            "testStrategy": "Test automated purging of expired data. Verify archiving functionality preserves required data. Validate admin controls for retention policy management."
          },
          {
            "id": 8,
            "title": "Implement data export functionality",
            "description": "Create functionality for users to export their personal data in compliance with data portability requirements.",
            "dependencies": [],
            "details": "Develop API endpoints for data export requests. Create background job processing for generating export packages. Implement secure download mechanisms for exported data. Add user interface for requesting and accessing exports. Include all relevant user data in exports in machine-readable format.",
            "status": "pending",
            "testStrategy": "Test data export functionality with various user profiles. Verify all relevant data is included in exports. Test secure download mechanisms."
          },
          {
            "id": 9,
            "title": "Implement consent management system",
            "description": "Create a system to collect, store, and manage user consent for data processing activities.",
            "dependencies": [],
            "details": "Develop consent collection UI components. Create database schema for storing consent records with timestamps. Implement API for recording consent changes. Create admin interface for managing consent options. Develop utilities to check consent before processing data. Implement consent version tracking for policy updates.",
            "status": "pending",
            "testStrategy": "Test consent collection UI. Verify consent records are properly stored with timestamps. Validate consent checking functionality prevents unauthorized processing."
          },
          {
            "id": 10,
            "title": "Implement privacy policy and terms management",
            "description": "Create a system to manage privacy policies, terms of service, and track user acceptance.",
            "dependencies": [
              "19.9"
            ],
            "details": "Develop versioned storage for legal documents. Create UI for displaying policies and collecting acceptance. Implement tracking of user acceptance with timestamps. Develop notification system for policy updates. Create admin interface for managing policy documents.",
            "status": "pending",
            "testStrategy": "Test policy display and acceptance UI. Verify acceptance records are properly stored. Validate notification system for policy updates."
          },
          {
            "id": 11,
            "title": "Enhance security monitoring and audit logging",
            "description": "Expand the existing audit logging system to capture security-relevant events and implement monitoring for security incidents.",
            "dependencies": [],
            "details": "Enhance the existing withAuditLogging middleware to capture additional security events. Implement structured logging for security events. Create dashboard for security monitoring. Set up alerts for suspicious activities. Implement log retention and protection. Develop API for querying security logs.",
            "status": "pending",
            "testStrategy": "Verify all security-relevant events are properly logged. Test alerting functionality with simulated security incidents. Validate log retention and protection mechanisms."
          },
          {
            "id": 12,
            "title": "Implement multi-factor authentication",
            "description": "Add multi-factor authentication options to enhance account security.",
            "dependencies": [],
            "details": "Integrate with authentication provider supporting MFA (Auth0, Firebase, etc.). Implement TOTP-based authentication option. Add SMS verification as alternative method. Create user interface for MFA setup and management. Implement backup codes for account recovery. Add admin controls for requiring MFA for specific user roles.",
            "status": "pending",
            "testStrategy": "Test MFA setup and verification flow. Verify backup code functionality. Test admin controls for requiring MFA. Validate account recovery process."
          },
          {
            "id": 13,
            "title": "Implement password policies and account security",
            "description": "Enforce strong password policies and implement account security features.",
            "dependencies": [],
            "details": "Implement password strength requirements. Create password expiration policies. Add account lockout after failed attempts. Implement secure password reset flow. Create notification system for account security events. Add session management with device tracking.",
            "status": "pending",
            "testStrategy": "Test password policy enforcement. Verify account lockout functionality. Test password reset flow for security. Validate notification system for security events."
          },
          {
            "id": 14,
            "title": "Implement session management and secure authentication",
            "description": "Create secure session handling with proper timeout, rotation, and invalidation capabilities.",
            "dependencies": [
              "19.12",
              "19.13"
            ],
            "details": "Implement secure session storage with encryption. Create session timeout and automatic logout. Add session rotation on privilege change. Implement forced logout capability for admins. Create session listing and management UI for users. Add device fingerprinting for suspicious login detection.",
            "status": "pending",
            "testStrategy": "Test session timeout functionality. Verify session rotation on privilege change. Test forced logout capability. Validate suspicious login detection."
          },
          {
            "id": 15,
            "title": "Create security documentation and compliance reports",
            "description": "Develop comprehensive security documentation and automated compliance reporting.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3",
              "19.4",
              "19.5",
              "19.6",
              "19.7",
              "19.8",
              "19.9",
              "19.10",
              "19.11",
              "19.12",
              "19.13",
              "19.14"
            ],
            "details": "Create security architecture documentation. Develop compliance mapping to SOC 2, GDPR, and CCPA requirements. Implement automated compliance reporting. Create security incident response procedures. Develop security training materials for developers. Create data processing documentation.",
            "status": "pending",
            "testStrategy": "Review documentation for completeness and accuracy. Validate compliance reports against regulatory requirements. Test incident response procedures with simulated incidents."
          },
          {
            "id": 16,
            "title": "Implement vulnerability scanning and security testing",
            "description": "Set up automated vulnerability scanning and security testing processes.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3"
            ],
            "details": "Integrate dependency scanning in CI/CD pipeline. Implement static code analysis for security issues. Set up dynamic application security testing. Create process for vulnerability management and remediation. Implement regular penetration testing schedule. Develop security regression testing.",
            "status": "pending",
            "testStrategy": "Verify vulnerability scanning identifies known issues. Test remediation workflow with sample vulnerabilities. Validate security regression tests prevent reintroduction of fixed issues."
          }
        ]
      },
      {
        "id": 20,
        "title": "Performance Optimization and Scalability",
        "description": "Optimize application performance and implement scalability measures to handle growing user base and data volume.",
        "details": "1. Implement frontend performance optimizations:\n   - Code splitting and lazy loading\n   - Image optimization\n   - Bundle size reduction\n   - Caching strategies\n2. Optimize database performance:\n   - Index optimization\n   - Query optimization\n   - Connection pooling\n   - Read/write separation for scaling\n3. Implement API performance enhancements:\n```typescript\n// middleware/cacheMiddleware.ts\nexport function withCaching(ttlSeconds = 60) {\n  return (handler) => {\n    return async (req, res) => {\n      // Only cache GET requests\n      if (req.method !== 'GET') {\n        return handler(req, res)\n      }\n      \n      // Generate cache key\n      const cacheKey = generateCacheKey(req)\n      \n      // Try to get from cache\n      const cachedResponse = await getFromCache(cacheKey)\n      \n      if (cachedResponse) {\n        return res.status(200).json(cachedResponse)\n      }\n      \n      // Create response wrapper to capture data\n      const originalJson = res.json\n      res.json = function(data) {\n        // Only cache successful responses\n        if (res.statusCode === 200) {\n          setInCache(cacheKey, data, ttlSeconds)\n        }\n        return originalJson.call(res, data)\n      }\n      \n      // Continue to handler\n      return handler(req, res)\n    }\n  }\n}\n```\n4. Set up CDN for static assets\n5. Implement horizontal scaling:\n   - Stateless application design\n   - Distributed caching\n   - Load balancing configuration\n6. Create performance monitoring and alerting\n7. Implement database sharding strategy for future growth",
        "testStrategy": "Conduct load testing to verify performance under high load. Measure and optimize page load times. Test database performance with large datasets. Verify caching effectiveness. Ensure horizontal scaling works correctly.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Code Splitting and Lazy Loading",
            "description": "Implement code splitting and lazy loading for the frontend application to reduce initial bundle size and improve load times.",
            "dependencies": [],
            "details": "1. Identify key components for lazy loading (routes, large components, etc.)\n2. Use dynamic imports for code splitting\n3. Implement React.lazy() and Suspense for component loading\n4. Add loading indicators for lazy-loaded components\n5. Configure webpack/bundler for optimal chunk sizes\n\nExample implementation:\n```typescript\nimport React, { lazy, Suspense } from 'react';\n\n// Lazy load component\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <HeavyComponent />\n      </Suspense>\n    </div>\n  );\n}\n```",
            "status": "pending",
            "testStrategy": "Measure bundle size before and after implementation. Test load times on various network conditions. Verify components load correctly when needed."
          },
          {
            "id": 2,
            "title": "Optimize Images and Static Assets",
            "description": "Implement image optimization techniques and static asset management to reduce payload size and improve loading performance.",
            "dependencies": [],
            "details": "1. Implement responsive images with srcset and sizes attributes\n2. Convert images to modern formats (WebP, AVIF) with fallbacks\n3. Set up image compression pipeline\n4. Implement lazy loading for images\n5. Optimize SVGs and other static assets\n\nExample implementation:\n```typescript\n// Image component with optimization\nconst OptimizedImage = ({ src, alt, sizes }) => {\n  const webpSrc = src.replace(/\\.(png|jpg|jpeg)$/, '.webp');\n  \n  return (\n    <img \n      src={src}\n      srcSet={`${webpSrc} 1x, ${webpSrc.replace('.webp', '@2x.webp')} 2x`}\n      alt={alt}\n      sizes={sizes}\n      loading=\"lazy\"\n    />\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "Compare image sizes before and after optimization. Test loading performance with various image sizes. Verify browser compatibility for image formats."
          },
          {
            "id": 3,
            "title": "Implement Bundle Size Reduction Techniques",
            "description": "Reduce JavaScript bundle size through tree shaking, dependency optimization, and code minification.",
            "dependencies": [],
            "details": "1. Analyze current bundle size with tools like webpack-bundle-analyzer\n2. Implement tree shaking to eliminate unused code\n3. Replace large dependencies with smaller alternatives\n4. Configure code splitting for routes and features\n5. Optimize build process for production\n\nImplementation steps:\n1. Install analysis tools: `npm install --save-dev webpack-bundle-analyzer`\n2. Configure webpack for tree shaking and code splitting\n3. Review and optimize import statements\n4. Set up proper minification for production builds",
            "status": "pending",
            "testStrategy": "Compare bundle sizes before and after optimization. Verify functionality after dependency changes. Test load times with optimized bundles."
          },
          {
            "id": 4,
            "title": "Implement Frontend Caching Strategies",
            "description": "Implement comprehensive caching strategies for the frontend to improve repeat visit performance.",
            "dependencies": [
              "20.1",
              "20.2",
              "20.3"
            ],
            "details": "1. Configure proper cache headers for static assets\n2. Implement service worker for offline capabilities\n3. Set up local storage caching for appropriate data\n4. Implement memory caching for frequently accessed data\n5. Configure HTTP caching headers\n\nExample service worker implementation:\n```typescript\n// service-worker.js\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open('static-assets-v1').then((cache) => {\n      return cache.addAll([\n        '/',\n        '/index.html',\n        '/main.js',\n        '/styles.css'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request).then((response) => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```",
            "status": "pending",
            "testStrategy": "Test caching behavior with network throttling. Verify offline functionality with service worker. Measure repeat visit performance improvements."
          },
          {
            "id": 5,
            "title": "Optimize Database Indexes",
            "description": "Analyze and optimize database indexes to improve query performance and reduce database load.",
            "dependencies": [],
            "details": "1. Analyze current database schema and identify frequently used queries\n2. Profile slow queries using database monitoring tools\n3. Create appropriate indexes for frequently filtered and sorted fields\n4. Remove redundant or unused indexes\n5. Implement compound indexes for multi-column queries\n\nExample index creation:\n```sql\n-- Add index for frequently filtered field\nCREATE INDEX idx_user_email ON users(email);\n\n-- Create compound index for common query pattern\nCREATE INDEX idx_opportunity_company_status ON opportunities(company_id, status);\n\n-- Add index with included columns to cover queries\nCREATE INDEX idx_calls_with_data ON calls(user_id, date) INCLUDE (duration, status);\n```",
            "status": "pending",
            "testStrategy": "Benchmark query performance before and after index changes. Test with large datasets to verify scaling. Monitor database load during peak usage."
          },
          {
            "id": 6,
            "title": "Implement Query Optimization",
            "description": "Optimize database queries to improve performance and reduce database load.",
            "dependencies": [
              "20.5"
            ],
            "details": "1. Identify slow or inefficient queries through profiling\n2. Rewrite queries to use proper indexes\n3. Implement pagination for large result sets\n4. Use appropriate JOIN strategies\n5. Implement query caching where appropriate\n\nExample optimized query:\n```typescript\n// Before optimization\nconst results = await prisma.opportunities.findMany({\n  where: { status: 'active' },\n  include: { company: true, contacts: true }\n});\n\n// After optimization\nconst results = await prisma.opportunities.findMany({\n  where: { status: 'active' },\n  include: { \n    company: { select: { id: true, name: true } },\n    contacts: { \n      take: 5,\n      select: { id: true, name: true, email: true }\n    }\n  },\n  take: 20,\n  skip: (page - 1) * 20,\n  orderBy: { updatedAt: 'desc' }\n});\n```",
            "status": "pending",
            "testStrategy": "Compare query execution times before and after optimization. Test with various data volumes. Verify correct results after optimization."
          },
          {
            "id": 7,
            "title": "Implement Database Connection Pooling",
            "description": "Set up and configure database connection pooling to efficiently manage database connections and improve performance under load.",
            "dependencies": [],
            "details": "1. Configure connection pooling in database client\n2. Set appropriate pool size based on server resources\n3. Implement connection timeout and retry logic\n4. Add monitoring for connection pool health\n5. Configure connection recycling for long-running processes\n\nExample implementation:\n```typescript\n// database.ts\nimport { Pool } from 'pg';\n\nconst pool = new Pool({\n  user: process.env.DB_USER,\n  host: process.env.DB_HOST,\n  database: process.env.DB_NAME,\n  password: process.env.DB_PASSWORD,\n  port: parseInt(process.env.DB_PORT || '5432'),\n  max: 20, // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000, // Close idle clients after 30 seconds\n  connectionTimeoutMillis: 2000, // Return an error after 2 seconds if connection not established\n});\n\n// Add event listeners for pool\npool.on('error', (err) => {\n  console.error('Unexpected error on idle client', err);\n});\n\nexport default pool;\n```",
            "status": "pending",
            "testStrategy": "Test database performance under concurrent load. Monitor connection usage patterns. Verify connection reuse is working correctly."
          },
          {
            "id": 8,
            "title": "Implement Read/Write Separation for Database Scaling",
            "description": "Set up database read/write separation to distribute database load and improve scalability.",
            "dependencies": [
              "20.7"
            ],
            "details": "1. Configure primary database for write operations\n2. Set up read replicas for read operations\n3. Implement logic to route queries to appropriate database\n4. Handle replication lag in application logic\n5. Configure failover mechanisms\n\nExample implementation:\n```typescript\n// db/index.ts\nimport { Pool } from 'pg';\n\nconst writePool = new Pool({\n  host: process.env.DB_WRITE_HOST,\n  // Other connection parameters\n  max: 10,\n});\n\nconst readPool = new Pool({\n  host: process.env.DB_READ_HOST,\n  // Other connection parameters\n  max: 20,\n});\n\nexport const db = {\n  query: async (text, params, isWrite = false) => {\n    const pool = isWrite ? writePool : readPool;\n    return pool.query(text, params);\n  },\n  write: async (text, params) => {\n    return writePool.query(text, params);\n  },\n  read: async (text, params) => {\n    return readPool.query(text, params);\n  }\n};\n```",
            "status": "pending",
            "testStrategy": "Test write operations on primary database. Verify read operations use replicas. Simulate replication lag to test handling. Measure performance improvement under load."
          },
          {
            "id": 9,
            "title": "Enhance API Caching Implementation",
            "description": "Extend and optimize the API caching middleware to improve response times and reduce server load.",
            "dependencies": [],
            "details": "1. Enhance the existing cacheMiddleware.ts implementation\n2. Add cache key generation based on query parameters and headers\n3. Implement cache invalidation strategies\n4. Add cache headers to responses\n5. Configure varying TTL based on endpoint characteristics\n\nEnhanced implementation:\n```typescript\n// middleware/cacheMiddleware.ts\nimport { createClient } from 'redis';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nredisClient.connect().catch(console.error);\n\nexport function withCaching(options = { ttlSeconds: 60, varyByHeaders: [] }) {\n  return (handler) => {\n    return async (req, res) => {\n      // Only cache GET requests\n      if (req.method !== 'GET') {\n        return handler(req, res);\n      }\n      \n      // Generate cache key with more context\n      const cacheKey = generateCacheKey(req, options.varyByHeaders);\n      \n      // Try to get from cache\n      const cachedResponse = await getFromCache(cacheKey);\n      \n      if (cachedResponse) {\n        // Add cache header\n        res.setHeader('X-Cache', 'HIT');\n        return res.status(200).json(JSON.parse(cachedResponse));\n      }\n      \n      // Add cache miss header\n      res.setHeader('X-Cache', 'MISS');\n      \n      // Create response wrapper to capture data\n      const originalJson = res.json;\n      res.json = function(data) {\n        // Only cache successful responses\n        if (res.statusCode === 200) {\n          setInCache(cacheKey, JSON.stringify(data), options.ttlSeconds);\n        }\n        return originalJson.call(res, data);\n      };\n      \n      // Continue to handler\n      return handler(req, res);\n    };\n  };\n}\n\nfunction generateCacheKey(req, varyByHeaders = []) {\n  const url = req.url;\n  const queryString = JSON.stringify(req.query);\n  const headerValues = varyByHeaders.map(header => req.headers[header] || '');\n  \n  return `api:${url}:${queryString}:${headerValues.join(':')}`;\n}\n\nasync function getFromCache(key) {\n  return await redisClient.get(key);\n}\n\nasync function setInCache(key, value, ttlSeconds) {\n  await redisClient.set(key, value, { EX: ttlSeconds });\n}\n```",
            "status": "pending",
            "testStrategy": "Test cache hit/miss rates for various endpoints. Measure response time improvements with caching. Verify cache invalidation works correctly. Test with concurrent requests."
          },
          {
            "id": 10,
            "title": "Implement API Rate Limiting and Throttling",
            "description": "Implement rate limiting and throttling for API endpoints to prevent abuse and ensure fair resource allocation.",
            "dependencies": [
              "20.9"
            ],
            "details": "1. Design rate limiting strategy (per user, per IP, global)\n2. Implement rate limiting middleware\n3. Configure different limits for different endpoints\n4. Add appropriate response headers for rate limit information\n5. Implement graceful degradation for rate-limited requests\n\nExample implementation:\n```typescript\n// middleware/rateLimitMiddleware.ts\nimport { createClient } from 'redis';\nimport { RateLimiterRedis } from 'rate-limiter-flexible';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nredisClient.connect().catch(console.error);\n\nconst rateLimiter = new RateLimiterRedis({\n  storeClient: redisClient,\n  keyPrefix: 'ratelimit',\n  points: 100, // Number of points\n  duration: 60, // Per 60 seconds\n});\n\nexport function withRateLimit(customPoints) {\n  return async (req, res, next) => {\n    try {\n      // Use IP or user ID as identifier\n      const identifier = req.user?.id || req.ip;\n      \n      // Use custom points if provided\n      const points = customPoints || 1;\n      \n      // Check rate limit\n      const rateLimiterRes = await rateLimiter.consume(identifier, points);\n      \n      // Set rate limit headers\n      res.setHeader('X-RateLimit-Limit', rateLimiter.points);\n      res.setHeader('X-RateLimit-Remaining', rateLimiterRes.remainingPoints);\n      res.setHeader('X-RateLimit-Reset', new Date(Date.now() + rateLimiterRes.msBeforeNext).toISOString());\n      \n      next();\n    } catch (error) {\n      if (error.remainingPoints !== undefined) {\n        // Rate limit exceeded\n        res.setHeader('Retry-After', Math.round(error.msBeforeNext / 1000));\n        res.status(429).json({ error: 'Too Many Requests' });\n      } else {\n        // Other error\n        res.status(500).json({ error: 'Internal Server Error' });\n      }\n    }\n  };\n}\n```",
            "status": "pending",
            "testStrategy": "Test rate limiting with rapid sequential requests. Verify correct headers are returned. Test different rate limit configurations. Verify rate limit reset works correctly."
          },
          {
            "id": 11,
            "title": "Set Up CDN for Static Assets",
            "description": "Configure a Content Delivery Network (CDN) for static assets to improve global performance and reduce origin server load.",
            "dependencies": [],
            "details": "1. Select appropriate CDN provider (e.g., Cloudflare, AWS CloudFront, Akamai)\n2. Configure CDN for static assets (images, JS, CSS, etc.)\n3. Set up proper cache control headers\n4. Implement cache invalidation strategy\n5. Configure custom domain and SSL\n\nImplementation steps:\n1. Create CDN distribution pointing to origin server/storage\n2. Configure cache behaviors for different asset types\n3. Set up proper TTLs based on asset type\n4. Update application to use CDN URLs for assets\n5. Implement versioning or cache busting for assets\n\nExample frontend configuration:\n```typescript\n// config.ts\nexport const config = {\n  cdnUrl: process.env.NODE_ENV === 'production' \n    ? 'https://cdn.yourdomain.com' \n    : '',\n};\n\n// Usage in components\nimport { config } from '../config';\n\nfunction ImageComponent({ src, alt }) {\n  const cdnSrc = `${config.cdnUrl}${src}`;\n  return <img src={cdnSrc} alt={alt} />;\n}\n```",
            "status": "pending",
            "testStrategy": "Test asset loading from CDN. Verify caching behavior with cache headers. Test CDN performance from different geographic locations. Verify cache invalidation works correctly."
          },
          {
            "id": 12,
            "title": "Implement Stateless Application Design",
            "description": "Refactor application components to be stateless to enable horizontal scaling and improve reliability.",
            "dependencies": [],
            "details": "1. Identify and eliminate server-side session state\n2. Move session data to distributed storage (Redis, etc.)\n3. Ensure authentication is stateless (JWT, etc.)\n4. Implement idempotent API endpoints\n5. Use distributed locking for critical operations\n\nExample session store implementation:\n```typescript\n// lib/session.ts\nimport { createClient } from 'redis';\nimport { serialize, deserialize } from 'superjson';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nredisClient.connect().catch(console.error);\n\nexport async function getSession(sessionId) {\n  const data = await redisClient.get(`session:${sessionId}`);\n  return data ? deserialize(data) : null;\n}\n\nexport async function setSession(sessionId, data, ttlSeconds = 3600) {\n  await redisClient.set(\n    `session:${sessionId}`, \n    serialize(data), \n    { EX: ttlSeconds }\n  );\n}\n\nexport async function deleteSession(sessionId) {\n  await redisClient.del(`session:${sessionId}`);\n}\n```",
            "status": "pending",
            "testStrategy": "Test application behavior with multiple server instances. Verify session persistence across server restarts. Test authentication with stateless tokens. Verify idempotent operations work correctly."
          },
          {
            "id": 13,
            "title": "Implement Distributed Caching",
            "description": "Set up a distributed caching system to share cache data across multiple application instances.",
            "dependencies": [
              "20.9",
              "20.12"
            ],
            "details": "1. Set up Redis or other distributed cache\n2. Implement cache service abstraction\n3. Configure cache regions for different data types\n4. Implement cache invalidation patterns\n5. Add monitoring for cache performance\n\nExample distributed cache implementation:\n```typescript\n// services/cacheService.ts\nimport { createClient } from 'redis';\n\nconst redisClient = createClient({\n  url: process.env.REDIS_URL\n});\n\nredisClient.connect().catch(console.error);\n\nexport class CacheService {\n  async get(key, region = 'default') {\n    const fullKey = `${region}:${key}`;\n    const data = await redisClient.get(fullKey);\n    return data ? JSON.parse(data) : null;\n  }\n  \n  async set(key, value, options = { ttl: 3600, region: 'default' }) {\n    const { ttl, region } = options;\n    const fullKey = `${region}:${key}`;\n    await redisClient.set(fullKey, JSON.stringify(value), { EX: ttl });\n  }\n  \n  async delete(key, region = 'default') {\n    const fullKey = `${region}:${key}`;\n    await redisClient.del(fullKey);\n  }\n  \n  async invalidateRegion(region) {\n    // Get all keys in region\n    const keys = await redisClient.keys(`${region}:*`);\n    if (keys.length > 0) {\n      await redisClient.del(keys);\n    }\n  }\n}\n\nexport const cacheService = new CacheService();\n```",
            "status": "pending",
            "testStrategy": "Test cache sharing between multiple application instances. Measure cache hit rates. Test cache invalidation across instances. Verify performance under load."
          },
          {
            "id": 14,
            "title": "Configure Load Balancing",
            "description": "Set up and configure load balancing to distribute traffic across multiple application instances.",
            "dependencies": [
              "20.12",
              "20.13"
            ],
            "details": "1. Select appropriate load balancer (e.g., NGINX, HAProxy, cloud provider LB)\n2. Configure health checks for backend instances\n3. Implement session affinity if needed\n4. Set up SSL termination at load balancer\n5. Configure proper timeout and retry policies\n\nExample NGINX load balancer configuration:\n```nginx\nupstream app_servers {\n    least_conn;  # Use least connections algorithm\n    server app1.internal:3000 max_fails=3 fail_timeout=30s;\n    server app2.internal:3000 max_fails=3 fail_timeout=30s;\n    server app3.internal:3000 max_fails=3 fail_timeout=30s;\n}\n\nserver {\n    listen 80;\n    listen 443 ssl;\n    server_name api.yourdomain.com;\n    \n    # SSL configuration\n    ssl_certificate /etc/nginx/ssl/yourdomain.crt;\n    ssl_certificate_key /etc/nginx/ssl/yourdomain.key;\n    \n    # Redirect HTTP to HTTPS\n    if ($scheme != \"https\") {\n        return 301 https://$host$request_uri;\n    }\n    \n    location / {\n        proxy_pass http://app_servers;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        # Timeouts\n        proxy_connect_timeout 10s;\n        proxy_send_timeout 30s;\n        proxy_read_timeout 30s;\n    }\n}\n```",
            "status": "pending",
            "testStrategy": "Test load distribution across multiple instances. Verify health check functionality. Test failover when an instance goes down. Measure response times under distributed load."
          },
          {
            "id": 15,
            "title": "Implement Performance Monitoring",
            "description": "Set up comprehensive performance monitoring to track application performance metrics and identify bottlenecks.",
            "dependencies": [],
            "details": "1. Implement server-side performance monitoring\n2. Set up client-side performance tracking\n3. Configure real user monitoring (RUM)\n4. Create performance dashboards\n5. Set up alerting for performance degradation\n\nExample implementation with New Relic:\n```typescript\n// monitoring/newrelic.ts\nimport newrelic from 'newrelic';\n\nexport function trackPerformance(name, fn) {\n  return newrelic.startSegment(name, true, async () => {\n    return await fn();\n  });\n}\n\nexport function recordMetric(name, value) {\n  newrelic.recordMetric(name, value);\n}\n\nexport function noticeError(error, customAttributes = {}) {\n  newrelic.noticeError(error, customAttributes);\n}\n\n// Client-side RUM script in _document.js\n// <script type=\"text/javascript\">\n//   window.NREUM||(NREUM={});\n//   NREUM.init = { /* configuration */ };\n// </script>\n// <script src=\"https://js-agent.newrelic.com/nr-spa.min.js\"></script>\n```",
            "status": "pending",
            "testStrategy": "Verify metrics collection for server and client performance. Test alerting with simulated performance issues. Validate dashboard data accuracy. Test custom performance tracking for critical paths."
          },
          {
            "id": 16,
            "title": "Implement Database Sharding Strategy",
            "description": "Design and implement a database sharding strategy to horizontally scale the database for future growth.",
            "dependencies": [
              "20.5",
              "20.6",
              "20.7",
              "20.8"
            ],
            "details": "1. Identify sharding key(s) based on data access patterns\n2. Design shard allocation strategy\n3. Implement shard routing logic\n4. Create data migration plan for sharding\n5. Implement cross-shard query capability\n\nExample sharding implementation:\n```typescript\n// db/shardManager.ts\nclass ShardManager {\n  private shardMap: Map<string, Pool>;\n  \n  constructor() {\n    this.shardMap = new Map();\n    \n    // Initialize connection pools for each shard\n    for (let i = 0; i < SHARD_COUNT; i++) {\n      const shardId = `shard${i}`;\n      this.shardMap.set(shardId, new Pool({\n        host: process.env[`DB_HOST_${shardId.toUpperCase()}`],\n        // Other connection parameters\n      }));\n    }\n  }\n  \n  getShardForTenant(tenantId: string): Pool {\n    // Consistent hashing to determine shard\n    const shardIndex = this.calculateShardIndex(tenantId);\n    const shardId = `shard${shardIndex}`;\n    return this.shardMap.get(shardId);\n  }\n  \n  private calculateShardIndex(tenantId: string): number {\n    // Simple hash function for demonstration\n    let hash = 0;\n    for (let i = 0; i < tenantId.length; i++) {\n      hash = (hash + tenantId.charCodeAt(i)) % SHARD_COUNT;\n    }\n    return hash;\n  }\n  \n  async executeQuery(tenantId: string, query: string, params: any[] = []) {\n    const shard = this.getShardForTenant(tenantId);\n    return shard.query(query, params);\n  }\n  \n  async executeAcrossAllShards(query: string, params: any[] = []) {\n    const results = [];\n    for (const shard of this.shardMap.values()) {\n      const result = await shard.query(query, params);\n      results.push(result);\n    }\n    return results.flat();\n  }\n}\n\nexport const shardManager = new ShardManager();\n```",
            "status": "pending",
            "testStrategy": "Test shard routing logic with various tenant IDs. Verify cross-shard queries return correct results. Test performance with increasing data volumes. Validate data integrity across shards."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-09T14:08:57.331Z",
      "updated": "2025-09-10T03:10:22.223Z",
      "description": "Tasks for master context"
    }
  }
}