{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Repository Configuration",
        "description": "Initialize the Next.js project with TypeScript, Tailwind CSS, and configure the repository structure according to the PRD guidelines.",
        "details": "1. Create a new Next.js project with TypeScript support:\n```bash\nnpx create-next-app@latest peerchamp --typescript --tailwind --eslint\n```\n2. Set up the folder structure as specified in the PRD:\n   - components/\n   - pages/\n   - lib/\n   - hooks/\n   - types/\n   - styles/\n   - public/\n   - tests/\n3. Configure ESLint and Prettier for code quality\n4. Set up Jest and React Testing Library for unit testing\n5. Configure Cypress for end-to-end testing\n6. Set up GitHub Actions for CI/CD pipeline\n7. Configure Vercel deployment",
        "testStrategy": "Verify the project structure is correctly set up by running the development server and ensuring it starts without errors. Run linting checks to confirm ESLint configuration is working. Execute a sample test to verify the testing framework is properly configured.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js project with TypeScript and Tailwind CSS",
            "description": "Create a new Next.js project with TypeScript and Tailwind CSS support using the create-next-app command.",
            "dependencies": [],
            "details": "Run the following command in the terminal to create a new Next.js project with TypeScript, Tailwind CSS, and ESLint:\n\nnpx create-next-app@latest peerchamp --typescript --tailwind --eslint\n\nAfter initialization, navigate to the project directory:\n\ncd peerchamp\n\nVerify the project structure and ensure the basic Next.js application is running with:\n\nnpm run dev",
            "status": "done",
            "testStrategy": "Verify the project is correctly set up by ensuring the development server starts without errors and the default Next.js page loads in the browser."
          },
          {
            "id": 2,
            "title": "Set up project folder structure",
            "description": "Create the required folder structure according to the PRD guidelines to organize the codebase properly.",
            "dependencies": [],
            "details": "Create the following directory structure in the project root:\n\n- components/ (for reusable UI components)\n- pages/ (already created by Next.js)\n- lib/ (for utility functions and services)\n- hooks/ (for custom React hooks)\n- types/ (for TypeScript type definitions)\n- styles/ (for global styles and CSS modules)\n- public/ (already created by Next.js)\n- tests/ (for test files)\n\nAdd a .gitkeep file in each empty directory to ensure they're tracked by Git.",
            "status": "done",
            "testStrategy": "Verify all directories exist and follow the structure defined in the PRD."
          },
          {
            "id": 3,
            "title": "Configure ESLint and Prettier",
            "description": "Set up ESLint and Prettier for code quality and consistent formatting across the project.",
            "dependencies": [],
            "details": "1. Install Prettier and ESLint plugins:\n\nnpm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier\n\n2. Create a .prettierrc file in the root directory:\n\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"es5\"\n}\n\n3. Update the .eslintrc.json file to include Prettier:\n\n{\n  \"extends\": [\n    \"next/core-web-vitals\",\n    \"prettier\"\n  ],\n  \"plugins\": [\"prettier\"],\n  \"rules\": {\n    \"prettier/prettier\": \"error\",\n    \"react/react-in-jsx-scope\": \"off\"\n  }\n}\n\n4. Add scripts to package.json:\n\n\"scripts\": {\n  // existing scripts\n  \"lint\": \"next lint\",\n  \"format\": \"prettier --write .\"\n}",
            "status": "done",
            "testStrategy": "Run 'npm run lint' and 'npm run format' to verify ESLint and Prettier configurations are working correctly."
          },
          {
            "id": 4,
            "title": "Set up Jest and React Testing Library",
            "description": "Configure Jest and React Testing Library for unit testing components and utilities.",
            "dependencies": [],
            "details": "1. Install Jest and React Testing Library:\n\nnpm install --save-dev jest @testing-library/react @testing-library/jest-dom @testing-library/user-event jest-environment-jsdom\n\n2. Create a jest.config.js file in the root directory:\n\nconst nextJest = require('next/jest')\n\nconst createJestConfig = nextJest({\n  dir: './'\n})\n\nconst customJestConfig = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  testEnvironment: 'jest-environment-jsdom',\n  moduleDirectories: ['node_modules', '<rootDir>/'],\n  testPathIgnorePatterns: ['<rootDir>/cypress/']\n}\n\nmodule.exports = createJestConfig(customJestConfig)\n\n3. Create a jest.setup.js file:\n\nimport '@testing-library/jest-dom'\n\n4. Add test script to package.json:\n\n\"scripts\": {\n  // existing scripts\n  \"test\": \"jest\",\n  \"test:watch\": \"jest --watch\"\n}\n\n5. Create a sample test file in tests/example.test.tsx to verify setup:\n\nimport { render, screen } from '@testing-library/react'\nimport Home from '../pages/index'\n\ndescribe('Home', () => {\n  it('renders a heading', () => {\n    render(<Home />)\n    const heading = screen.getByRole('heading', { level: 1 })\n    expect(heading).toBeInTheDocument()\n  })\n})",
            "status": "done",
            "testStrategy": "Run 'npm test' to verify Jest and React Testing Library are correctly configured and the sample test passes."
          },
          {
            "id": 5,
            "title": "Configure Cypress for end-to-end testing",
            "description": "Set up Cypress for end-to-end testing of the application.",
            "dependencies": [],
            "details": "1. Install Cypress:\n\nnpm install --save-dev cypress\n\n2. Add Cypress scripts to package.json:\n\n\"scripts\": {\n  // existing scripts\n  \"cypress\": \"cypress open\",\n  \"cypress:run\": \"cypress run\"\n}\n\n3. Initialize Cypress by running:\n\nnpx cypress open\n\n4. Create a basic test in cypress/e2e/home.cy.js:\n\ndescribe('Home Page', () => {\n  it('should navigate to the home page', () => {\n    cy.visit('http://localhost:3000')\n    cy.get('h1').should('exist')\n  })\n})\n\n5. Configure Cypress in cypress.config.js:\n\nconst { defineConfig } = require('cypress')\n\nmodule.exports = defineConfig({\n  e2e: {\n    baseUrl: 'http://localhost:3000',\n    setupNodeEvents(on, config) {},\n  },\n})",
            "status": "done",
            "testStrategy": "Run 'npm run cypress' to open the Cypress test runner and execute the sample test to verify the setup."
          },
          {
            "id": 6,
            "title": "Set up GitHub Actions for CI/CD",
            "description": "Configure GitHub Actions workflow for continuous integration and deployment.",
            "dependencies": [],
            "details": "1. Create a .github/workflows directory in the project root\n\n2. Create a ci.yml file in the workflows directory:\n\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run build\n      - run: npm test\n\n  e2e-tests:\n    runs-on: ubuntu-latest\n    needs: build-and-test\n    steps:\n      - uses: actions/checkout@v3\n      - name: Use Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18.x'\n          cache: 'npm'\n      - run: npm ci\n      - name: Cypress run\n        uses: cypress-io/github-action@v5\n        with:\n          build: npm run build\n          start: npm start\n          wait-on: 'http://localhost:3000'",
            "status": "done",
            "testStrategy": "Verify the GitHub Actions workflow by pushing to the repository and checking that the CI workflow runs successfully."
          },
          {
            "id": 7,
            "title": "Configure Vercel deployment",
            "description": "Set up Vercel for automatic deployments of the Next.js application.",
            "dependencies": [],
            "details": "1. Install Vercel CLI:\n\nnpm install -g vercel\n\n2. Create a vercel.json configuration file in the project root:\n\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"package.json\",\n      \"use\": \"@vercel/next\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"/\"\n    }\n  ],\n  \"env\": {\n    \"NEXT_PUBLIC_APP_URL\": \"@app_url\"\n  }\n}\n\n3. Link the project to Vercel:\n\nvercel login\nvercel link\n\n4. Set up environment variables in Vercel dashboard or using the CLI:\n\nvercel env add NEXT_PUBLIC_APP_URL\n\n5. Deploy the project:\n\nvercel --prod",
            "status": "done",
            "testStrategy": "Verify the deployment by checking that the application is accessible at the Vercel URL and functions correctly."
          },
          {
            "id": 8,
            "title": "Create environment configuration",
            "description": "Set up environment variables and configuration for different environments (development, testing, production).",
            "dependencies": [],
            "details": "1. Create a .env.local file for local development:\n\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n\n2. Create a .env.example file as a template:\n\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n\n3. Add .env.local to .gitignore to prevent committing sensitive information:\n\n# Add to .gitignore\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\n4. Create a config.ts file in the lib directory to centralize configuration:\n\n// lib/config.ts\nexport const config = {\n  appUrl: process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n  environment: process.env.NODE_ENV || 'development',\n  isProduction: process.env.NODE_ENV === 'production',\n  isDevelopment: process.env.NODE_ENV === 'development',\n  isTest: process.env.NODE_ENV === 'test',\n}",
            "status": "done",
            "testStrategy": "Verify environment variables are correctly loaded by creating a test that checks the config object contains the expected values."
          },
          {
            "id": 9,
            "title": "Document project setup and contribution guidelines",
            "description": "Create documentation for project setup, development workflow, and contribution guidelines.",
            "dependencies": [],
            "details": "1. Create a README.md file in the project root with the following sections:\n\n- Project overview\n- Prerequisites\n- Installation and setup\n- Development workflow\n- Testing\n- Deployment\n- Project structure\n- Contributing guidelines\n\n2. Create a CONTRIBUTING.md file with detailed contribution guidelines:\n\n- Code style and standards\n- Pull request process\n- Issue reporting\n- Branch naming conventions\n- Commit message format\n\n3. Create a docs/ directory for additional documentation:\n\n- docs/architecture.md - Overview of the application architecture\n- docs/testing.md - Detailed testing guidelines\n- docs/deployment.md - Deployment process documentation",
            "status": "done",
            "testStrategy": "Review documentation for completeness and accuracy. Verify that a new team member can follow the setup instructions successfully."
          }
        ]
      },
      {
        "id": 2,
        "title": "Supabase Integration and Database Schema Setup",
        "description": "Set up Supabase project and implement the database schema as defined in the PRD, including tables for companies, users, advocates, opportunities, and reference calls.",
        "details": "1. Create a new Supabase project\n2. Configure environment variables for Supabase connection\n3. Implement the database schema using SQL migrations:\n```sql\n-- Companies (Tenants)\nCREATE TABLE companies (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name TEXT NOT NULL,\n  domain TEXT UNIQUE,\n  subscription_tier TEXT DEFAULT 'professional',\n  settings JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Users (Sales Reps, Advocates, Admins)\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  email TEXT UNIQUE NOT NULL,\n  role TEXT NOT NULL, -- 'sales_rep', 'advocate', 'admin'\n  profile JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Advocates table\nCREATE TABLE advocates (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id),\n  company_id UUID REFERENCES companies(id),\n  name TEXT NOT NULL,\n  title TEXT,\n  company_name TEXT,\n  industry TEXT,\n  company_size TEXT,\n  use_cases TEXT[],\n  geographic_region TEXT,\n  expertise_areas TEXT[],\n  availability_score INTEGER DEFAULT 100,\n  total_calls_completed INTEGER DEFAULT 0,\n  last_call_date TIMESTAMP,\n  max_calls_per_month INTEGER DEFAULT 4,\n  status TEXT DEFAULT 'active',\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Opportunities table  \nCREATE TABLE opportunities (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_company TEXT NOT NULL,\n  prospect_industry TEXT,\n  prospect_size TEXT,\n  use_case TEXT,\n  deal_value DECIMAL,\n  stage TEXT,\n  urgency TEXT DEFAULT 'medium',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Reference Calls\nCREATE TABLE reference_calls (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  opportunity_id UUID REFERENCES opportunities(id),\n  advocate_id UUID REFERENCES advocates(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_email TEXT,\n  prospect_name TEXT,\n  scheduled_at TIMESTAMP,\n  status TEXT DEFAULT 'scheduled', -- 'scheduled', 'completed', 'cancelled'\n  meeting_link TEXT,\n  call_intelligence JSONB,\n  advocate_feedback JSONB,\n  reward_amount DECIMAL,\n  reward_type TEXT,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```\n4. Create TypeScript types for database entities\n5. Set up Supabase client in the application\n6. Configure Row Level Security (RLS) policies for multi-tenant isolation",
        "testStrategy": "Write SQL queries to test the schema integrity, relationships, and constraints. Create unit tests for the Supabase client configuration. Verify RLS policies by attempting cross-tenant data access.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create and configure Supabase project",
            "description": "Set up a new Supabase project and configure the necessary environment variables for connecting to it from the application",
            "dependencies": [],
            "details": "1. Create a new Supabase project from the Supabase dashboard\n2. Note the project URL and anon key from the API settings\n3. Create a .env.local file in the project root\n4. Add the following environment variables:\n   ```\n   NEXT_PUBLIC_SUPABASE_URL=your-project-url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key\n   SUPABASE_SERVICE_ROLE_KEY=your-service-role-key\n   ```\n5. Add these variables to .gitignore to prevent committing secrets",
            "status": "done",
            "testStrategy": "Verify environment variables are correctly loaded in the application by creating a simple test that checks if the variables are defined"
          },
          {
            "id": 2,
            "title": "Create companies and users tables",
            "description": "Implement the database schema for the companies and users tables using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Companies (Tenants)\nCREATE TABLE companies (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name TEXT NOT NULL,\n  domain TEXT UNIQUE,\n  subscription_tier TEXT DEFAULT 'professional',\n  settings JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Users (Sales Reps, Advocates, Admins)\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  email TEXT UNIQUE NOT NULL,\n  role TEXT NOT NULL, -- 'sales_rep', 'advocate', 'admin'\n  profile JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Run SQL queries to verify table creation, check constraints, and test inserting sample data to ensure the schema works as expected"
          },
          {
            "id": 3,
            "title": "Create advocates table",
            "description": "Implement the database schema for the advocates table using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Advocates table\nCREATE TABLE advocates (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID REFERENCES auth.users(id),\n  company_id UUID REFERENCES companies(id),\n  name TEXT NOT NULL,\n  title TEXT,\n  company_name TEXT,\n  industry TEXT,\n  company_size TEXT,\n  use_cases TEXT[],\n  geographic_region TEXT,\n  expertise_areas TEXT[],\n  availability_score INTEGER DEFAULT 100,\n  total_calls_completed INTEGER DEFAULT 0,\n  last_call_date TIMESTAMP,\n  max_calls_per_month INTEGER DEFAULT 4,\n  status TEXT DEFAULT 'active',\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Verify the table creation with SQL queries, test foreign key constraints by attempting to insert records with invalid references"
          },
          {
            "id": 4,
            "title": "Create opportunities table",
            "description": "Implement the database schema for the opportunities table using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Opportunities table  \nCREATE TABLE opportunities (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  company_id UUID REFERENCES companies(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_company TEXT NOT NULL,\n  prospect_industry TEXT,\n  prospect_size TEXT,\n  use_case TEXT,\n  deal_value DECIMAL,\n  stage TEXT,\n  urgency TEXT DEFAULT 'medium',\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Test the table creation and constraints with SQL queries, verify foreign key relationships work correctly"
          },
          {
            "id": 5,
            "title": "Create reference_calls table",
            "description": "Implement the database schema for the reference_calls table using SQL migrations",
            "dependencies": [],
            "details": "Create a migration file in the project's migration directory with the following SQL:\n```sql\n-- Reference Calls\nCREATE TABLE reference_calls (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  opportunity_id UUID REFERENCES opportunities(id),\n  advocate_id UUID REFERENCES advocates(id),\n  sales_rep_id UUID REFERENCES users(id),\n  prospect_email TEXT,\n  prospect_name TEXT,\n  scheduled_at TIMESTAMP,\n  status TEXT DEFAULT 'scheduled', -- 'scheduled', 'completed', 'cancelled'\n  meeting_link TEXT,\n  call_intelligence JSONB,\n  advocate_feedback JSONB,\n  reward_amount DECIMAL,\n  reward_type TEXT,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n```",
            "status": "done",
            "testStrategy": "Verify the table creation with SQL queries, test the foreign key constraints by attempting to insert records with invalid references to opportunities, advocates, and users"
          },
          {
            "id": 6,
            "title": "Set up Supabase client in the application",
            "description": "Configure the Supabase client for use throughout the application",
            "dependencies": [],
            "details": "1. Install the Supabase client library:\n```bash\nnpm install @supabase/supabase-js\n```\n2. Create a lib/supabase.ts file with the following content:\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase environment variables');\n}\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n```\n3. Create a utility function to get the service role client for admin operations:\n```typescript\n// Only use server-side\nexport const getServiceSupabase = () => {\n  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;\n  return createClient(supabaseUrl, supabaseServiceKey);\n};\n```",
            "status": "done",
            "testStrategy": "Create a simple test that imports the Supabase client and verifies it's properly initialized. Test basic operations like querying a public table"
          },
          {
            "id": 7,
            "title": "Create TypeScript types for database entities",
            "description": "Define TypeScript interfaces for all database entities to ensure type safety throughout the application",
            "dependencies": [],
            "details": "Create a types/database.ts file with the following content:\n```typescript\nexport interface Company {\n  id: string;\n  name: string;\n  domain: string | null;\n  subscription_tier: string;\n  settings: Record<string, any>;\n  created_at: string;\n}\n\nexport interface User {\n  id: string;\n  company_id: string;\n  email: string;\n  role: 'sales_rep' | 'advocate' | 'admin';\n  profile: Record<string, any>;\n  created_at: string;\n}\n\nexport interface Advocate {\n  id: string;\n  user_id: string;\n  company_id: string;\n  name: string;\n  title: string | null;\n  company_name: string | null;\n  industry: string | null;\n  company_size: string | null;\n  use_cases: string[] | null;\n  geographic_region: string | null;\n  expertise_areas: string[] | null;\n  availability_score: number;\n  total_calls_completed: number;\n  last_call_date: string | null;\n  max_calls_per_month: number;\n  status: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface Opportunity {\n  id: string;\n  company_id: string;\n  sales_rep_id: string;\n  prospect_company: string;\n  prospect_industry: string | null;\n  prospect_size: string | null;\n  use_case: string | null;\n  deal_value: number | null;\n  stage: string | null;\n  urgency: string;\n  created_at: string;\n}\n\nexport interface ReferenceCall {\n  id: string;\n  opportunity_id: string;\n  advocate_id: string;\n  sales_rep_id: string;\n  prospect_email: string | null;\n  prospect_name: string | null;\n  scheduled_at: string | null;\n  status: 'scheduled' | 'completed' | 'cancelled';\n  meeting_link: string | null;\n  call_intelligence: Record<string, any> | null;\n  advocate_feedback: Record<string, any> | null;\n  reward_amount: number | null;\n  reward_type: string | null;\n  created_at: string;\n}\n```",
            "status": "done",
            "testStrategy": "Verify type definitions by creating sample objects and checking for type errors. Ensure all database fields are properly represented in the TypeScript interfaces"
          },
          {
            "id": 8,
            "title": "Configure Row Level Security (RLS) policies",
            "description": "Implement Row Level Security policies in Supabase to ensure multi-tenant isolation and proper access control",
            "dependencies": [],
            "details": "Create a migration file with the following SQL to implement RLS policies:\n```sql\n-- Enable RLS on all tables\nALTER TABLE companies ENABLE ROW LEVEL SECURITY;\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\nALTER TABLE advocates ENABLE ROW LEVEL SECURITY;\nALTER TABLE opportunities ENABLE ROW LEVEL SECURITY;\nALTER TABLE reference_calls ENABLE ROW LEVEL SECURITY;\n\n-- Companies policies\nCREATE POLICY \"Users can view their own company\"\n  ON companies FOR SELECT\n  USING (id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Users policies\nCREATE POLICY \"Users can view users in their company\"\n  ON users FOR SELECT\n  USING (company_id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Advocates policies\nCREATE POLICY \"Users can view advocates in their company\"\n  ON advocates FOR SELECT\n  USING (company_id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Opportunities policies\nCREATE POLICY \"Users can view opportunities in their company\"\n  ON opportunities FOR SELECT\n  USING (company_id IN (\n    SELECT company_id FROM users WHERE auth.uid() = id\n  ));\n\n-- Reference calls policies\nCREATE POLICY \"Users can view reference calls in their company\"\n  ON reference_calls FOR SELECT\n  USING (opportunity_id IN (\n    SELECT o.id FROM opportunities o\n    JOIN users u ON u.company_id = o.company_id\n    WHERE auth.uid() = u.id\n  ));\n```",
            "status": "done",
            "testStrategy": "Test RLS policies by creating multiple tenants and verifying that users from one tenant cannot access data from another tenant. Test with different user roles to ensure appropriate access levels"
          },
          {
            "id": 9,
            "title": "Create database access utility functions",
            "description": "Implement utility functions to simplify database operations and enforce type safety",
            "dependencies": [],
            "details": "Create a lib/db.ts file with the following content:\n```typescript\nimport { supabase } from './supabase';\nimport type { Company, User, Advocate, Opportunity, ReferenceCall } from '../types/database';\n\n// Companies\nexport const getCompany = async (id: string): Promise<Company | null> => {\n  const { data, error } = await supabase\n    .from('companies')\n    .select('*')\n    .eq('id', id)\n    .single();\n  \n  if (error) {\n    console.error('Error fetching company:', error);\n    return null;\n  }\n  \n  return data;\n};\n\n// Users\nexport const getUsersByCompany = async (companyId: string): Promise<User[]> => {\n  const { data, error } = await supabase\n    .from('users')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (error) {\n    console.error('Error fetching users:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n\n// Advocates\nexport const getAdvocatesByCompany = async (companyId: string): Promise<Advocate[]> => {\n  const { data, error } = await supabase\n    .from('advocates')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (error) {\n    console.error('Error fetching advocates:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n\n// Opportunities\nexport const getOpportunitiesByCompany = async (companyId: string): Promise<Opportunity[]> => {\n  const { data, error } = await supabase\n    .from('opportunities')\n    .select('*')\n    .eq('company_id', companyId);\n  \n  if (error) {\n    console.error('Error fetching opportunities:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n\n// Reference Calls\nexport const getReferenceCallsByOpportunity = async (opportunityId: string): Promise<ReferenceCall[]> => {\n  const { data, error } = await supabase\n    .from('reference_calls')\n    .select('*')\n    .eq('opportunity_id', opportunityId);\n  \n  if (error) {\n    console.error('Error fetching reference calls:', error);\n    return [];\n  }\n  \n  return data || [];\n};\n```",
            "status": "done",
            "testStrategy": "Create unit tests for each database utility function, mocking the Supabase client responses. Test error handling by simulating database errors"
          },
          {
            "id": 10,
            "title": "Create seed data script for development",
            "description": "Implement a script to populate the database with sample data for development and testing purposes",
            "dependencies": [],
            "details": "Create a scripts/seed.ts file with the following content:\n```typescript\nimport { getServiceSupabase } from '../lib/supabase';\n\nconst supabase = getServiceSupabase();\n\nasync function seedDatabase() {\n  console.log('Seeding database...');\n  \n  // Create sample company\n  const { data: company, error: companyError } = await supabase\n    .from('companies')\n    .insert({\n      name: 'Demo Company',\n      domain: 'democompany.com',\n      subscription_tier: 'professional'\n    })\n    .select()\n    .single();\n  \n  if (companyError) {\n    console.error('Error creating company:', companyError);\n    return;\n  }\n  \n  console.log('Created company:', company);\n  \n  // Create sample users\n  const { data: users, error: usersError } = await supabase\n    .from('users')\n    .insert([\n      {\n        company_id: company.id,\n        email: 'admin@democompany.com',\n        role: 'admin'\n      },\n      {\n        company_id: company.id,\n        email: 'sales@democompany.com',\n        role: 'sales_rep'\n      }\n    ])\n    .select();\n  \n  if (usersError) {\n    console.error('Error creating users:', usersError);\n    return;\n  }\n  \n  console.log('Created users:', users);\n  \n  // Create sample advocates\n  const { data: advocates, error: advocatesError } = await supabase\n    .from('advocates')\n    .insert([\n      {\n        company_id: company.id,\n        user_id: users[0].id,\n        name: 'John Advocate',\n        title: 'CTO',\n        company_name: 'Tech Solutions',\n        industry: 'Software',\n        company_size: '51-200',\n        use_cases: ['API Integration', 'Data Analysis'],\n        geographic_region: 'North America',\n        expertise_areas: ['Technical Implementation', 'Enterprise Architecture']\n      }\n    ])\n    .select();\n  \n  if (advocatesError) {\n    console.error('Error creating advocates:', advocatesError);\n    return;\n  }\n  \n  console.log('Created advocates:', advocates);\n  \n  // Create sample opportunities\n  const { data: opportunities, error: opportunitiesError } = await supabase\n    .from('opportunities')\n    .insert([\n      {\n        company_id: company.id,\n        sales_rep_id: users[1].id,\n        prospect_company: 'Acme Corp',\n        prospect_industry: 'Manufacturing',\n        prospect_size: '201-500',\n        use_case: 'Process Automation',\n        deal_value: 50000,\n        stage: 'Proposal'\n      }\n    ])\n    .select();\n  \n  if (opportunitiesError) {\n    console.error('Error creating opportunities:', opportunitiesError);\n    return;\n  }\n  \n  console.log('Created opportunities:', opportunities);\n  \n  // Create sample reference calls\n  const { data: calls, error: callsError } = await supabase\n    .from('reference_calls')\n    .insert([\n      {\n        opportunity_id: opportunities[0].id,\n        advocate_id: advocates[0].id,\n        sales_rep_id: users[1].id,\n        prospect_email: 'prospect@acmecorp.com',\n        prospect_name: 'Jane Prospect',\n        scheduled_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),\n        status: 'scheduled'\n      }\n    ])\n    .select();\n  \n  if (callsError) {\n    console.error('Error creating reference calls:', callsError);\n    return;\n  }\n  \n  console.log('Created reference calls:', calls);\n  console.log('Database seeding completed!');\n}\n\nseedDatabase();\n```\n\nAdd a script to package.json:\n```json\n\"scripts\": {\n  \"seed\": \"ts-node scripts/seed.ts\"\n}\n```",
            "status": "done",
            "testStrategy": "Run the seed script in a development environment and verify that all tables are populated with the expected data. Check for any constraint violations or errors during the seeding process"
          }
        ]
      },
      {
        "id": 3,
        "title": "Authentication and User Management System",
        "description": "Implement authentication using Supabase Auth with role-based access control for different user types (sales reps, advocates, admins) and company-based tenant isolation.",
        "details": "1. Configure Supabase Auth with email/password and SSO options\n2. Create authentication hooks and context:\n```typescript\n// hooks/useAuth.ts\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { User } from '@supabase/supabase-js'\n\ntype AuthContextType = {\n  user: User | null\n  loading: boolean\n  signIn: (email: string, password: string) => Promise<void>\n  signOut: () => Promise<void>\n  // Additional auth methods\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null)\n  const [loading, setLoading] = useState(true)\n  \n  // Auth implementation\n  \n  return (\n    <AuthContext.Provider value={{ user, loading, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n```\n3. Implement sign-up, sign-in, and sign-out flows\n4. Create protected route components\n5. Implement role-based access control middleware\n6. Set up user profile management\n7. Configure company/tenant isolation logic\n8. Implement SSO integration for enterprise customers",
        "testStrategy": "Create unit tests for authentication hooks and components. Test protected routes with different user roles. Verify tenant isolation by attempting to access data from different companies. Test SSO integration with mock identity providers.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Auth with Email/Password Authentication",
            "description": "Set up Supabase Auth with email/password authentication method and configure the necessary settings in the Supabase dashboard.",
            "dependencies": [],
            "details": "1. Configure Supabase project settings for Auth\n2. Enable email/password authentication in Supabase dashboard\n3. Set up email templates for verification and password reset\n4. Configure security settings (session duration, password policies)\n5. Create the supabaseClient.ts file to initialize the Supabase client:\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey)\n```\n<info added on 2025-09-10T03:49:07.241Z>\n6. Enhanced Supabase client configuration with improved auth options:\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey, {\n  auth: {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true\n  }\n})\n```\n\n7. Environment variables have been verified:\n   - .env.example file created with required Supabase variables\n   - .env.local file configured with actual project credentials\n\n8. Supabase client has been tested and confirmed working for authentication flows\n</info added on 2025-09-10T03:49:07.241Z>",
            "status": "done",
            "testStrategy": "Verify Supabase Auth configuration by testing sign-up and sign-in flows manually. Ensure email templates are properly configured by testing the verification and password reset flows."
          },
          {
            "id": 2,
            "title": "Implement SSO Integration for Enterprise Customers",
            "description": "Configure Supabase Auth to support Single Sign-On (SSO) options for enterprise customers using OAuth providers.",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Enable OAuth providers in Supabase dashboard (Google, Microsoft, etc.)\n2. Configure OAuth provider settings (client IDs, secrets, redirect URLs)\n3. Implement provider-specific authentication methods in the auth service\n4. Create utility functions for handling OAuth flows:\n```typescript\n// services/ssoService.ts\nexport const initiateOAuthFlow = async (provider: 'google' | 'microsoft') => {\n  return await supabase.auth.signInWithOAuth({\n    provider,\n    options: {\n      redirectTo: `${window.location.origin}/auth/callback`\n    }\n  })\n}\n\nexport const handleOAuthCallback = async () => {\n  const { data, error } = await supabase.auth.getSession()\n  return { session: data.session, error }\n}\n```",
            "status": "done",
            "testStrategy": "Test SSO integration with each configured provider. Verify redirect flows and session creation. Test with both new and existing users to ensure proper account linking."
          },
          {
            "id": 3,
            "title": "Create Authentication Context and Hooks",
            "description": "Implement the React context and hooks for authentication to provide user state and authentication methods throughout the application.",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "1. Complete the AuthContext implementation with user state management\n2. Implement authentication methods (signIn, signOut, etc.)\n3. Add session persistence and auto-refresh logic\n4. Handle auth state changes with Supabase listeners\n5. Complete the implementation of the useAuth hook:\n```typescript\n// hooks/useAuth.ts\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { User, Session } from '@supabase/supabase-js'\n\ntype AuthContextType = {\n  user: User | null\n  session: Session | null\n  loading: boolean\n  signIn: (email: string, password: string) => Promise<{ error: any }>\n  signOut: () => Promise<void>\n  signUp: (email: string, password: string) => Promise<{ error: any }>\n  resetPassword: (email: string) => Promise<{ error: any }>\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport const AuthProvider = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null)\n  const [session, setSession] = useState<Session | null>(null)\n  const [loading, setLoading] = useState(true)\n  \n  useEffect(() => {\n    // Get initial session\n    supabase.auth.getSession().then(({ data: { session } }) => {\n      setSession(session)\n      setUser(session?.user ?? null)\n      setLoading(false)\n    })\n\n    // Listen for auth changes\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (_event, session) => {\n        setSession(session)\n        setUser(session?.user ?? null)\n        setLoading(false)\n      }\n    )\n\n    return () => subscription.unsubscribe()\n  }, [])\n  \n  const signIn = async (email: string, password: string) => {\n    const { error } = await supabase.auth.signInWithPassword({ email, password })\n    return { error }\n  }\n\n  const signUp = async (email: string, password: string) => {\n    const { error } = await supabase.auth.signUp({ email, password })\n    return { error }\n  }\n\n  const signOut = async () => {\n    await supabase.auth.signOut()\n  }\n\n  const resetPassword = async (email: string) => {\n    const { error } = await supabase.auth.resetPasswordForEmail(email, {\n      redirectTo: `${window.location.origin}/reset-password`,\n    })\n    return { error }\n  }\n  \n  return (\n    <AuthContext.Provider value={{ \n      user, \n      session,\n      loading, \n      signIn, \n      signOut,\n      signUp,\n      resetPassword\n    }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n```",
            "status": "done",
            "testStrategy": "Write unit tests for the auth hooks using React Testing Library. Test all authentication methods with mock responses from Supabase. Verify context state updates correctly on auth events."
          },
          {
            "id": 4,
            "title": "Implement Sign-Up, Sign-In, and Sign-Out Flows",
            "description": "Create the UI components and forms for user authentication flows including sign-up, sign-in, sign-out, and password reset.",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Create sign-in form component with email/password fields and validation\n2. Implement sign-up form with necessary user information fields\n3. Add password reset request and confirmation forms\n4. Create SSO login buttons for configured providers\n5. Implement form validation using a form library (e.g., Formik, React Hook Form)\n6. Add error handling and user feedback\n7. Example sign-in component:\n```typescript\n// components/auth/SignInForm.tsx\nimport { useState } from 'react'\nimport { useAuth } from '../../hooks/useAuth'\nimport { useForm } from 'react-hook-form'\n\ntype SignInFormData = {\n  email: string\n  password: string\n}\n\nexport const SignInForm = () => {\n  const { signIn } = useAuth()\n  const [authError, setAuthError] = useState<string | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  \n  const { register, handleSubmit, formState: { errors } } = useForm<SignInFormData>()\n  \n  const onSubmit = async (data: SignInFormData) => {\n    setIsLoading(true)\n    setAuthError(null)\n    \n    const { error } = await signIn(data.email, data.password)\n    \n    if (error) {\n      setAuthError(error.message)\n    }\n    \n    setIsLoading(false)\n  }\n  \n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          type=\"email\"\n          {...register('email', { required: 'Email is required' })}\n        />\n        {errors.email && <p>{errors.email.message}</p>}\n      </div>\n      \n      <div>\n        <label htmlFor=\"password\">Password</label>\n        <input\n          id=\"password\"\n          type=\"password\"\n          {...register('password', { required: 'Password is required' })}\n        />\n        {errors.password && <p>{errors.password.message}</p>}\n      </div>\n      \n      {authError && <div className=\"error\">{authError}</div>}\n      \n      <button type=\"submit\" disabled={isLoading}>\n        {isLoading ? 'Signing in...' : 'Sign In'}\n      </button>\n    </form>\n  )\n}\n```",
            "status": "done",
            "testStrategy": "Test form validation for all authentication forms. Verify error handling and user feedback for various error scenarios. Test form submission with mock auth service responses."
          },
          {
            "id": 5,
            "title": "Create Protected Route Components",
            "description": "Implement protected route components to restrict access to authenticated users and handle redirects for unauthenticated users.",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Create a ProtectedRoute component that wraps routes requiring authentication\n2. Implement loading states for auth state resolution\n3. Add redirect logic for unauthenticated users\n4. Handle route access based on authentication state\n```typescript\n// components/auth/ProtectedRoute.tsx\nimport { useRouter } from 'next/router'\nimport { useAuth } from '../../hooks/useAuth'\nimport { ReactNode, useEffect } from 'react'\n\ntype ProtectedRouteProps = {\n  children: ReactNode\n}\n\nexport const ProtectedRoute = ({ children }: ProtectedRouteProps) => {\n  const { user, loading } = useAuth()\n  const router = useRouter()\n  \n  useEffect(() => {\n    if (!loading && !user) {\n      router.push('/auth/signin?redirect=' + router.asPath)\n    }\n  }, [user, loading, router])\n  \n  if (loading) {\n    return <div>Loading...</div>\n  }\n  \n  return user ? <>{children}</> : null\n}\n```\n5. Create a higher-order component for Next.js pages:\n```typescript\n// hoc/withAuth.tsx\nimport { NextPage } from 'next'\nimport { ProtectedRoute } from '../components/auth/ProtectedRoute'\n\nexport const withAuth = (Component: NextPage) => {\n  const AuthenticatedComponent = (props: any) => {\n    return (\n      <ProtectedRoute>\n        <Component {...props} />\n      </ProtectedRoute>\n    )\n  }\n  \n  return AuthenticatedComponent\n}\n```",
            "status": "done",
            "testStrategy": "Test protected routes with authenticated and unauthenticated user states. Verify redirects to login page with correct return URLs. Test loading states during authentication checks."
          },
          {
            "id": 6,
            "title": "Implement Role-Based Access Control",
            "description": "Create a role-based access control system to manage permissions for different user types (sales reps, advocates, admins).",
            "dependencies": [
              "3.3",
              "3.5"
            ],
            "details": "1. Define role types and permission structures\n2. Create database tables for roles and permissions\n3. Implement role assignment and verification logic\n4. Create a useRBAC hook for permission checking\n5. Implement role-based UI components\n```typescript\n// types/roles.ts\nexport type UserRole = 'admin' | 'sales_rep' | 'advocate'\n\nexport interface Permission {\n  action: string\n  resource: string\n}\n\nexport interface RolePermissions {\n  [role: string]: Permission[]\n}\n\n// hooks/useRBAC.ts\nimport { useAuth } from './useAuth'\nimport { useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { UserRole, Permission, RolePermissions } from '../types/roles'\n\nconst defaultPermissions: RolePermissions = {\n  admin: [\n    { action: '*', resource: '*' }\n  ],\n  sales_rep: [\n    { action: 'read', resource: 'advocates' },\n    { action: 'create', resource: 'calls' },\n    { action: '*', resource: 'opportunities' }\n  ],\n  advocate: [\n    { action: 'read', resource: 'calls' },\n    { action: 'update', resource: 'profile' },\n    { action: 'update', resource: 'availability' }\n  ]\n}\n\nexport const useRBAC = () => {\n  const { user } = useAuth()\n  const [userRole, setUserRole] = useState<UserRole | null>(null)\n  const [loading, setLoading] = useState(true)\n  \n  useEffect(() => {\n    const fetchUserRole = async () => {\n      if (!user) {\n        setUserRole(null)\n        setLoading(false)\n        return\n      }\n      \n      const { data, error } = await supabase\n        .from('user_roles')\n        .select('role')\n        .eq('user_id', user.id)\n        .single()\n      \n      if (error || !data) {\n        console.error('Error fetching user role:', error)\n        setUserRole(null)\n      } else {\n        setUserRole(data.role as UserRole)\n      }\n      \n      setLoading(false)\n    }\n    \n    fetchUserRole()\n  }, [user])\n  \n  const hasPermission = (action: string, resource: string): boolean => {\n    if (!userRole) return false\n    \n    const permissions = defaultPermissions[userRole] || []\n    \n    return permissions.some(permission => \n      (permission.action === '*' || permission.action === action) &&\n      (permission.resource === '*' || permission.resource === resource)\n    )\n  }\n  \n  return { userRole, loading, hasPermission }\n}\n\n// components/auth/PermissionGate.tsx\nimport { ReactNode } from 'react'\nimport { useRBAC } from '../../hooks/useRBAC'\n\ntype PermissionGateProps = {\n  action: string\n  resource: string\n  children: ReactNode\n  fallback?: ReactNode\n}\n\nexport const PermissionGate = ({\n  action,\n  resource,\n  children,\n  fallback = null\n}: PermissionGateProps) => {\n  const { hasPermission, loading } = useRBAC()\n  \n  if (loading) return null\n  \n  return hasPermission(action, resource) ? <>{children}</> : <>{fallback}</>\n}\n```",
            "status": "done",
            "testStrategy": "Test permission checks for different user roles. Verify UI components correctly show/hide based on permissions. Test role assignment and changes. Create test cases for each defined role and permission combination."
          },
          {
            "id": 7,
            "title": "Set Up User Profile Management",
            "description": "Implement user profile management functionality to allow users to view and update their profile information.",
            "dependencies": [
              "3.3",
              "3.6"
            ],
            "details": "1. Create user profile database schema with necessary fields\n2. Implement profile data fetching and update services\n3. Create profile edit form components\n4. Add profile image upload functionality\n5. Implement profile settings page\n```typescript\n// types/user.ts\nexport interface UserProfile {\n  id: string\n  user_id: string\n  first_name: string\n  last_name: string\n  email: string\n  phone?: string\n  job_title?: string\n  company_id?: string\n  avatar_url?: string\n  created_at: string\n  updated_at: string\n}\n\n// services/userService.ts\nimport { supabase } from '../lib/supabaseClient'\nimport { UserProfile } from '../types/user'\n\nexport const getUserProfile = async (userId: string): Promise<UserProfile | null> => {\n  const { data, error } = await supabase\n    .from('profiles')\n    .select('*')\n    .eq('user_id', userId)\n    .single()\n  \n  if (error) {\n    console.error('Error fetching user profile:', error)\n    return null\n  }\n  \n  return data as UserProfile\n}\n\nexport const updateUserProfile = async (profile: Partial<UserProfile>): Promise<{ data: UserProfile | null, error: any }> => {\n  const { data, error } = await supabase\n    .from('profiles')\n    .update({\n      ...profile,\n      updated_at: new Date().toISOString()\n    })\n    .eq('user_id', profile.user_id)\n    .select()\n    .single()\n  \n  return { data: data as UserProfile, error }\n}\n\nexport const uploadProfileImage = async (userId: string, file: File): Promise<{ url: string | null, error: any }> => {\n  const fileExt = file.name.split('.').pop()\n  const fileName = `${userId}-${Math.random().toString(36).substring(2)}.${fileExt}`\n  const filePath = `avatars/${fileName}`\n  \n  const { error: uploadError } = await supabase.storage\n    .from('profiles')\n    .upload(filePath, file)\n  \n  if (uploadError) {\n    return { url: null, error: uploadError }\n  }\n  \n  const { data } = supabase.storage.from('profiles').getPublicUrl(filePath)\n  \n  // Update profile with new avatar URL\n  await updateUserProfile({\n    user_id: userId,\n    avatar_url: data.publicUrl\n  })\n  \n  return { url: data.publicUrl, error: null }\n}\n```",
            "status": "done",
            "testStrategy": "Test profile data fetching and updates with mock data. Verify image upload functionality with test files. Test form validation and error handling for profile updates."
          },
          {
            "id": 8,
            "title": "Implement Company/Tenant Isolation Logic",
            "description": "Create a multi-tenant system that isolates data by company, ensuring users can only access data from their own company.",
            "dependencies": [
              "3.3",
              "3.6"
            ],
            "details": "1. Design database schema with company_id foreign keys\n2. Create Row Level Security (RLS) policies in Supabase\n3. Implement company context and hooks for accessing company data\n4. Create middleware for enforcing tenant isolation\n5. Add company management interfaces for admins\n```typescript\n// hooks/useCompany.ts\nimport { createContext, useContext, useState, useEffect } from 'react'\nimport { supabase } from '../lib/supabaseClient'\nimport { useAuth } from './useAuth'\n\ninterface Company {\n  id: string\n  name: string\n  domain: string\n  logo_url?: string\n  settings?: Record<string, any>\n}\n\ntype CompanyContextType = {\n  company: Company | null\n  loading: boolean\n  error: any\n}\n\nconst CompanyContext = createContext<CompanyContextType | undefined>(undefined)\n\nexport const CompanyProvider = ({ children }) => {\n  const { user } = useAuth()\n  const [company, setCompany] = useState<Company | null>(null)\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<any>(null)\n  \n  useEffect(() => {\n    const fetchCompany = async () => {\n      if (!user) {\n        setCompany(null)\n        setLoading(false)\n        return\n      }\n      \n      try {\n        // First get the user's company_id from their profile\n        const { data: profileData, error: profileError } = await supabase\n          .from('profiles')\n          .select('company_id')\n          .eq('user_id', user.id)\n          .single()\n        \n        if (profileError) throw profileError\n        \n        if (profileData?.company_id) {\n          // Then fetch the company details\n          const { data: companyData, error: companyError } = await supabase\n            .from('companies')\n            .select('*')\n            .eq('id', profileData.company_id)\n            .single()\n          \n          if (companyError) throw companyError\n          \n          setCompany(companyData as Company)\n        }\n      } catch (err) {\n        console.error('Error fetching company:', err)\n        setError(err)\n      } finally {\n        setLoading(false)\n      }\n    }\n    \n    fetchCompany()\n  }, [user])\n  \n  return (\n    <CompanyContext.Provider value={{ company, loading, error }}>\n      {children}\n    </CompanyContext.Provider>\n  )\n}\n\nexport const useCompany = () => {\n  const context = useContext(CompanyContext)\n  if (context === undefined) {\n    throw new Error('useCompany must be used within a CompanyProvider')\n  }\n  return context\n}\n\n// middleware/withTenantIsolation.ts\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport { supabase } from '../lib/supabaseClient'\n\nexport const withTenantIsolation = (handler: any) => {\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    // Get the authorization header\n    const authHeader = req.headers.authorization\n    \n    if (!authHeader) {\n      return res.status(401).json({ error: 'Missing authorization header' })\n    }\n    \n    // Extract the token\n    const token = authHeader.split(' ')[1]\n    \n    // Verify the token and get the user\n    const { data: { user }, error } = await supabase.auth.getUser(token)\n    \n    if (error || !user) {\n      return res.status(401).json({ error: 'Invalid or expired token' })\n    }\n    \n    // Get the user's company_id\n    const { data: profile } = await supabase\n      .from('profiles')\n      .select('company_id')\n      .eq('user_id', user.id)\n      .single()\n    \n    if (!profile?.company_id) {\n      return res.status(403).json({ error: 'User not associated with a company' })\n    }\n    \n    // Add company_id to the request context\n    req.companyId = profile.company_id\n    req.userId = user.id\n    \n    // Call the original handler\n    return handler(req, res)\n  }\n}\n```\n6. Create SQL for Row Level Security policies in Supabase:\n```sql\n-- Enable RLS on tables\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nALTER TABLE companies ENABLE ROW LEVEL SECURITY;\nALTER TABLE advocates ENABLE ROW LEVEL SECURITY;\n\n-- Create policies for profiles table\nCREATE POLICY \"Users can view their own profile\"\n  ON profiles FOR SELECT\n  USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own profile\"\n  ON profiles FOR UPDATE\n  USING (auth.uid() = user_id);\n\n-- Create policies for company-based isolation\nCREATE POLICY \"Users can view data from their company\"\n  ON advocates FOR SELECT\n  USING (\n    company_id IN (\n      SELECT company_id FROM profiles\n      WHERE user_id = auth.uid()\n    )\n  );\n\nCREATE POLICY \"Users can insert data for their company\"\n  ON advocates FOR INSERT\n  WITH CHECK (\n    company_id IN (\n      SELECT company_id FROM profiles\n      WHERE user_id = auth.uid()\n    )\n  );\n\nCREATE POLICY \"Users can update data for their company\"\n  ON advocates FOR UPDATE\n  USING (\n    company_id IN (\n      SELECT company_id FROM profiles\n      WHERE user_id = auth.uid()\n    )\n  );\n```",
            "status": "done",
            "testStrategy": "Test tenant isolation by attempting to access data from different companies. Verify RLS policies work correctly with different user roles. Test company context with mock data for different scenarios."
          }
        ]
      },
      {
        "id": 4,
        "title": "Core UI Components and Layout System",
        "description": "Develop the core UI components and layout system that will be used throughout the application, ensuring mobile responsiveness and a consistent design language.",
        "details": "1. Create a design system with Tailwind CSS:\n```typescript\n// tailwind.config.js\nmodule.exports = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#f0f9ff',\n          // ... other shades\n          900: '#0c4a6e',\n        },\n        // Other color definitions\n      },\n      // Other theme extensions\n    },\n  },\n  plugins: [require('@tailwindcss/forms')],\n}\n```\n2. Implement layout components:\n   - MainLayout (with navigation, header, footer)\n   - DashboardLayout\n   - AuthLayout\n3. Create reusable UI components:\n   - Button (primary, secondary, tertiary variants)\n   - Input fields and form elements\n   - Card components\n   - Modal/dialog components\n   - Table components\n   - Navigation components\n   - Alert/notification components\n4. Implement responsive design patterns\n5. Create loading and error state components\n6. Implement dark/light mode support",
        "testStrategy": "Create Storybook stories for each component to visually test appearance and behavior. Write unit tests for component functionality. Test responsive behavior using viewport simulation. Verify accessibility compliance using automated tools.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Tailwind CSS Design System",
            "description": "Set up and configure Tailwind CSS with custom theme extensions for colors, typography, spacing, and other design tokens to establish a consistent design language.",
            "dependencies": [],
            "details": "1. Install Tailwind CSS and required dependencies\n2. Create tailwind.config.js with proper content paths\n3. Define custom color palette including primary, secondary, success, warning, error colors with appropriate shade variations\n4. Configure typography scales and font families\n5. Set up spacing and breakpoint systems\n6. Add required plugins like @tailwindcss/forms\n7. Create a theme.ts file to export type-safe theme constants",
            "status": "done",
            "testStrategy": "Verify custom classes are generated correctly by creating a simple test component that uses various theme values. Check compiled CSS output for expected values."
          },
          {
            "id": 2,
            "title": "Create Button Component System",
            "description": "Implement a comprehensive button component with variants (primary, secondary, tertiary), sizes, states (default, hover, focus, disabled), and loading state.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create components/ui/Button.tsx with appropriate props interface\n2. Implement size variants (sm, md, lg)\n3. Create style variants using Tailwind classes (primary, secondary, tertiary)\n4. Add support for icon-only and icon+text buttons\n5. Implement loading state with spinner\n6. Add disabled state styling\n7. Ensure proper focus states for accessibility\n8. Add proper aria attributes for accessibility",
            "status": "done",
            "testStrategy": "Create Storybook stories for each button variant and state. Write unit tests to verify prop handling and class application. Test keyboard accessibility."
          },
          {
            "id": 3,
            "title": "Implement Form Input Components",
            "description": "Create a set of form input components including text inputs, textareas, select dropdowns, checkboxes, radio buttons, and toggle switches with validation states.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create base Input component with validation states\n2. Implement TextArea component\n3. Create Select dropdown with options support\n4. Build Checkbox and Radio components\n5. Implement Toggle/Switch component\n6. Add support for labels, help text, and error messages\n7. Ensure all components handle disabled states\n8. Add proper aria attributes for accessibility",
            "status": "done",
            "testStrategy": "Create Storybook stories for each input type and state. Test form validation integration. Verify keyboard navigation and screen reader accessibility."
          },
          {
            "id": 4,
            "title": "Build Card and Container Components",
            "description": "Create flexible card and container components with various style options for content grouping and layout organization.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create a base Card component with header, body, and footer sections\n2. Implement style variants (default, outlined, elevated)\n3. Add support for interactive cards (clickable, hoverable)\n4. Create specialized card types (stat cards, profile cards)\n5. Implement Container component for page section wrapping\n6. Add responsive padding and margin utilities",
            "status": "done",
            "testStrategy": "Create Storybook stories for different card configurations. Test responsive behavior at various breakpoints. Verify proper nesting of content."
          },
          {
            "id": 5,
            "title": "Develop Modal and Dialog Components",
            "description": "Create modal and dialog components for displaying content that requires user attention or interaction, with various sizes and configurations.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Implement Modal component with backdrop\n2. Create size variants (sm, md, lg, full)\n3. Add support for header, body, and footer sections\n4. Implement focus trapping for accessibility\n5. Add keyboard support (Escape to close)\n6. Create specialized dialog types (confirmation, alert)\n7. Implement animations for opening/closing\n8. Ensure proper stacking when multiple modals are open",
            "status": "done",
            "testStrategy": "Test modal opening/closing with various triggers. Verify focus management and keyboard accessibility. Test screen reader announcements. Ensure body scroll locking works correctly."
          },
          {
            "id": 6,
            "title": "Create Table Components",
            "description": "Build a comprehensive table system with sorting, pagination, and responsive behavior for displaying structured data.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Create base Table component with header and body\n2. Implement column configuration system\n3. Add support for row selection\n4. Create sortable columns with indicators\n5. Implement pagination controls\n6. Add empty state handling\n7. Create mobile-responsive table alternatives (cards, lists)\n8. Add support for custom cell renderers",
            "status": "done",
            "testStrategy": "Test table rendering with various data sets. Verify sorting functionality. Test pagination with different page sizes. Ensure responsive behavior works at mobile breakpoints."
          },
          {
            "id": 7,
            "title": "Implement Navigation Components",
            "description": "Create navigation components including navbar, sidebar, tabs, breadcrumbs, and pagination for application navigation.",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "1. Create Navbar component with responsive mobile menu\n2. Implement Sidebar with collapsible sections\n3. Build Tab component with horizontal and vertical variants\n4. Create Breadcrumb component\n5. Implement Pagination component\n6. Add active state styling for all navigation elements\n7. Ensure keyboard navigation support\n8. Create dropdown menu component for nested navigation",
            "status": "done",
            "testStrategy": "Test navigation state management. Verify responsive behavior of navbar and sidebar. Test keyboard navigation through all components. Ensure proper ARIA roles and attributes."
          },
          {
            "id": 8,
            "title": "Build Alert and Notification Components",
            "description": "Create alert and notification components for displaying system messages, errors, warnings, and success states.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create Alert component with variants (info, success, warning, error)\n2. Implement dismissible alerts with animation\n3. Build Toast notification system\n4. Create inline notification component\n5. Add support for icons in alerts\n6. Implement auto-dismissing functionality for toasts\n7. Create toast container for managing multiple notifications\n8. Add support for actions within alerts",
            "status": "done",
            "testStrategy": "Test alert rendering with different variants. Verify toast notification system with multiple simultaneous notifications. Test auto-dismiss functionality and manual dismissal."
          },
          {
            "id": 9,
            "title": "Implement Loading and Error State Components",
            "description": "Create components for handling loading states, empty states, and error states throughout the application.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create Spinner component with size variants\n2. Implement Skeleton loading components for various content types\n3. Build LoadingOverlay for blocking interactions\n4. Create EmptyState component with illustration support\n5. Implement ErrorState component for displaying errors\n6. Add retry functionality to error states\n7. Create inline loading indicators for buttons and forms",
            "status": "done",
            "testStrategy": "Test loading state transitions. Verify skeleton loading appearance. Test error state recovery flows. Ensure loading states are accessible to screen readers."
          },
          {
            "id": 10,
            "title": "Create MainLayout Component",
            "description": "Implement the main application layout with header, navigation, content area, and footer, supporting responsive behavior.",
            "dependencies": [
              "4.1",
              "4.7"
            ],
            "details": "1. Create components/layouts/MainLayout.tsx\n2. Implement responsive header with navigation\n3. Add sidebar navigation with collapsible functionality\n4. Create main content area with proper padding\n5. Implement footer with configurable content\n6. Add responsive breakpoints for mobile/tablet/desktop\n7. Implement navigation state management (open/closed sidebar)\n8. Create smooth transitions for layout changes",
            "status": "done",
            "testStrategy": "Test layout rendering at various screen sizes. Verify sidebar collapse/expand functionality. Test navigation state persistence. Ensure content area properly adapts to navigation states."
          },
          {
            "id": 11,
            "title": "Implement DashboardLayout Component",
            "description": "Create a specialized layout for dashboard pages with support for header, sidebar, and configurable content areas.",
            "dependencies": [
              "4.1",
              "4.10"
            ],
            "details": "1. Create components/layouts/DashboardLayout.tsx extending MainLayout\n2. Implement dashboard header with actions area\n3. Add support for dashboard sidebar with filters\n4. Create grid layout for dashboard widgets\n5. Implement responsive behavior for dashboard components\n6. Add support for fullscreen dashboard mode\n7. Create dashboard widget container component",
            "status": "done",
            "testStrategy": "Test dashboard layout with various widget configurations. Verify responsive behavior of widget grid. Test filter sidebar functionality. Ensure proper spacing and alignment of dashboard elements."
          },
          {
            "id": 12,
            "title": "Build AuthLayout Component",
            "description": "Create a layout for authentication pages with centered content, branding, and responsive behavior.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create components/layouts/AuthLayout.tsx\n2. Implement centered card container for auth forms\n3. Add branding area with logo\n4. Create background styling options\n5. Implement responsive behavior for mobile devices\n6. Add support for additional information sections\n7. Create navigation for auth flows (login, register, forgot password)",
            "status": "done",
            "testStrategy": "Test auth layout rendering at various screen sizes. Verify proper centering and spacing of auth forms. Test navigation between different auth pages."
          },
          {
            "id": 13,
            "title": "Implement Responsive Design Utilities",
            "description": "Create utility components and hooks for managing responsive behavior across the application.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Create useMediaQuery hook for responsive logic\n2. Implement ResponsiveContainer component\n3. Create responsive visibility utilities (HideOnMobile, ShowOnDesktop)\n4. Add responsive spacing utilities\n5. Implement responsive typography scaling\n6. Create responsive grid system utilities\n7. Add documentation for responsive design patterns",
            "status": "done",
            "testStrategy": "Test media query hook with various breakpoints. Verify responsive container behavior. Test visibility utilities at different screen sizes."
          },
          {
            "id": 14,
            "title": "Implement Dark/Light Mode Support",
            "description": "Add support for dark and light mode themes with user preference detection and manual toggle.",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Configure Tailwind for dark mode support\n2. Create ThemeProvider context for theme state management\n3. Implement useTheme hook for accessing theme state\n4. Add system preference detection\n5. Create theme toggle component\n6. Implement theme persistence in local storage\n7. Add smooth transition between themes\n8. Update all components to support both themes",
            "status": "done",
            "testStrategy": "Test theme switching functionality. Verify system preference detection. Test theme persistence across page reloads. Ensure all components render correctly in both themes."
          }
        ]
      },
      {
        "id": 5,
        "title": "Company and User Management Interfaces",
        "description": "Build the administrative interfaces for managing companies (tenants) and users, including creation, editing, and role assignment.",
        "details": "1. Create company management pages:\n   - Company list view\n   - Company creation form\n   - Company details/edit view\n   - Company settings page\n2. Implement user management interfaces:\n   - User list with filtering and search\n   - User creation/invitation form\n   - User role assignment\n   - User profile editing\n3. Implement the data fetching logic:\n```typescript\n// Example user fetching hook\nexport const useUsers = (companyId: string) => {\n  const [users, setUsers] = useState<User[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<Error | null>(null)\n\n  useEffect(() => {\n    const fetchUsers = async () => {\n      try {\n        setLoading(true)\n        const { data, error } = await supabase\n          .from('users')\n          .select('*')\n          .eq('company_id', companyId)\n        \n        if (error) throw error\n        setUsers(data || [])\n      } catch (err) {\n        setError(err as Error)\n      } finally {\n        setLoading(false)\n      }\n    }\n    \n    fetchUsers()\n  }, [companyId])\n\n  return { users, loading, error }\n}\n```\n4. Create form validation logic\n5. Implement role-based access control UI\n6. Add bulk user import functionality",
        "testStrategy": "Test CRUD operations for companies and users with different permission levels. Verify form validation for required fields and data formats. Test bulk import functionality with various data formats. Ensure proper error handling and user feedback.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Company List View Component",
            "description": "Implement the company list view component that displays all companies with pagination, sorting, and basic filtering capabilities.",
            "dependencies": [],
            "details": "Create a React component for the company list view. Use a table or card layout to display company information including name, status, number of users, and creation date. Implement pagination with limit/offset pattern. Add sorting functionality for relevant columns. Include a search bar for filtering companies by name. Use the Supabase client to fetch company data with proper error handling and loading states.",
            "status": "in-progress",
            "testStrategy": "Test rendering with mock data. Verify pagination controls work correctly. Test sorting functionality for each column. Ensure search filtering returns correct results."
          },
          {
            "id": 2,
            "title": "Implement Company Data Fetching Hook",
            "description": "Create a custom React hook for fetching and managing company data from the Supabase backend.",
            "dependencies": [],
            "details": "Implement a useCompanies hook similar to the provided useUsers example. The hook should handle fetching companies with pagination, sorting, and filtering parameters. Include state management for loading, error handling, and the companies array. Add functions for refreshing data and handling pagination changes. Implement proper TypeScript interfaces for company data structure.",
            "status": "in-progress",
            "testStrategy": "Test hook behavior with mock Supabase responses. Verify error handling works correctly. Test pagination parameter changes. Ensure proper state management during loading and after data is fetched."
          },
          {
            "id": 3,
            "title": "Build Company Creation Form",
            "description": "Create a form component for adding new companies with validation and submission handling.",
            "dependencies": [
              "5.2"
            ],
            "details": "Implement a form component with fields for company name, description, industry, size, and other relevant details. Use a form library like Formik or React Hook Form for state management and validation. Add client-side validation for required fields and data formats. Implement submission handling that uses the Supabase client to create new company records. Include success and error notifications for user feedback.",
            "status": "in-progress",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify submission handling with mock API responses. Test error scenarios and ensure proper user feedback. Verify form reset functionality after successful submission."
          },
          {
            "id": 4,
            "title": "Develop Company Details/Edit View",
            "description": "Create a detailed view for individual companies with the ability to edit company information.",
            "dependencies": [
              "5.2"
            ],
            "details": "Implement a company details page that displays comprehensive information about a selected company. Create an edit mode that transforms the view into an editable form. Reuse validation logic from the company creation form. Implement save functionality that updates the company record in Supabase. Add confirmation dialogs for important changes. Include a section showing basic usage statistics and user counts.",
            "status": "in-progress",
            "testStrategy": "Test view/edit mode toggle functionality. Verify form validation in edit mode. Test update functionality with mock API responses. Ensure proper handling of concurrent edit scenarios."
          },
          {
            "id": 5,
            "title": "Create Company Settings Page",
            "description": "Implement a settings page for company-specific configurations including branding, integrations, and preferences.",
            "dependencies": [
              "5.4"
            ],
            "details": "Build a settings page with tabs or sections for different configuration categories. Include branding settings (logo, colors, custom domain), notification preferences, integration settings, and security options. Implement save functionality for each section that updates the appropriate records in Supabase. Add validation for settings fields where appropriate. Include a reset to defaults option for each section.",
            "status": "in-progress",
            "testStrategy": "Test settings persistence across page reloads. Verify validation for each settings field. Test the reset to defaults functionality. Ensure proper error handling and user feedback for settings updates."
          },
          {
            "id": 6,
            "title": "Implement User List Component with Filtering",
            "description": "Create a user list view with advanced filtering, search, and pagination capabilities.",
            "dependencies": [],
            "details": "Implement a user list component that displays users with relevant information (name, email, role, status). Add filtering capabilities for role, status, and other attributes. Implement a search function that filters by name or email. Add pagination controls with configurable page size. Include sorting functionality for relevant columns. Use the provided useUsers hook for data fetching and state management.",
            "status": "in-progress",
            "testStrategy": "Test rendering with various data sets. Verify filter combinations work correctly. Test search functionality with partial matches. Ensure pagination works with different filter combinations."
          },
          {
            "id": 7,
            "title": "Enhance User Data Fetching Hook",
            "description": "Extend the provided useUsers hook with additional functionality for filtering, pagination, and data management.",
            "dependencies": [],
            "details": "Enhance the provided useUsers hook to support pagination, filtering, and sorting parameters. Add functions for refreshing data, changing pagination, and applying filters. Implement proper TypeScript interfaces for user data structure. Add functionality for handling user status changes and role updates. Optimize the hook to minimize unnecessary re-fetches.",
            "status": "in-progress",
            "testStrategy": "Test hook behavior with different parameter combinations. Verify error handling for various error scenarios. Test pagination and filtering logic. Ensure proper state management during loading and after data is fetched."
          },
          {
            "id": 8,
            "title": "Create User Creation and Invitation Form",
            "description": "Implement a form for creating new users and sending invitations to join the platform.",
            "dependencies": [
              "5.7"
            ],
            "details": "Build a form component for adding new users with fields for name, email, role, and other relevant information. Implement an invitation flow that sends emails to new users. Add validation for email format and required fields. Create a preview of the invitation email. Implement submission handling that creates user records in Supabase and triggers invitation emails. Add success and error notifications for user feedback.",
            "status": "in-progress",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify email invitation flow with mock email service. Test error scenarios and ensure proper user feedback. Verify duplicate email handling."
          },
          {
            "id": 9,
            "title": "Implement User Role Assignment Interface",
            "description": "Create an interface for assigning and managing user roles with appropriate permissions.",
            "dependencies": [
              "5.7"
            ],
            "details": "Implement a role assignment interface that allows administrators to change user roles. Display available roles with descriptions of their permissions. Add confirmation dialogs for role changes that affect permissions. Implement the backend logic for updating user roles in Supabase. Include a visual indicator of the current user's role. Add validation to prevent removing all admin users.",
            "status": "in-progress",
            "testStrategy": "Test role assignment with different user types. Verify permission changes take effect immediately. Test validation logic for preventing removal of all admins. Ensure proper error handling and user feedback."
          },
          {
            "id": 10,
            "title": "Build User Profile Editing Component",
            "description": "Create a component for users to view and edit their profile information.",
            "dependencies": [
              "5.7"
            ],
            "details": "Implement a user profile component that displays user information and allows editing. Include fields for name, contact information, preferences, and profile picture. Add validation for required fields and data formats. Implement image upload functionality for profile pictures. Create save functionality that updates user records in Supabase. Add success and error notifications for user feedback.",
            "status": "in-progress",
            "testStrategy": "Test profile editing with valid and invalid inputs. Verify image upload functionality. Test error scenarios and ensure proper user feedback. Verify changes persist after page reload."
          },
          {
            "id": 11,
            "title": "Implement Form Validation Logic",
            "description": "Create reusable validation logic for company and user forms to ensure data integrity.",
            "dependencies": [],
            "details": "Implement a validation utility that can be used across company and user forms. Create validation rules for common fields like email, phone numbers, and required fields. Add custom validation for business-specific rules. Implement real-time validation feedback. Create helper functions for displaying validation errors in form components. Ensure validation logic is consistent across all forms.",
            "status": "in-progress",
            "testStrategy": "Test validation rules with various input combinations. Verify error messages are clear and helpful. Test validation timing (on blur, on submit, etc.). Ensure validation logic handles edge cases correctly."
          },
          {
            "id": 12,
            "title": "Develop Role-Based Access Control UI",
            "description": "Implement the user interface components for managing role-based access control across the application.",
            "dependencies": [
              "5.9"
            ],
            "details": "Create an interface for defining and managing roles and their permissions. Implement a matrix view showing roles and their associated permissions. Add functionality to create, edit, and delete custom roles. Implement permission inheritance and override capabilities. Create a preview mode to see the application from different role perspectives. Add validation to prevent creating roles with conflicting permissions.",
            "status": "in-progress",
            "testStrategy": "Test role creation and editing functionality. Verify permission changes are reflected in the UI. Test role deletion with users assigned to that role. Ensure proper error handling and validation for role management."
          },
          {
            "id": 13,
            "title": "Create Bulk User Import Functionality",
            "description": "Implement functionality for importing multiple users at once via CSV or Excel file upload.",
            "dependencies": [
              "5.8"
            ],
            "details": "Create a file upload component that accepts CSV or Excel files. Implement parsing logic for extracting user data from uploaded files. Add validation for file format and required user fields. Create a preview interface showing parsed data before import. Implement batch processing for creating multiple user records. Add error handling for partial successes. Create a downloadable template file for users to fill in.",
            "status": "in-progress",
            "testStrategy": "Test file upload with various file formats and sizes. Verify parsing logic handles different CSV formats correctly. Test validation of imported data. Ensure proper error handling for malformed files and invalid data."
          },
          {
            "id": 14,
            "title": "Implement Navigation and Layout for Management Interfaces",
            "description": "Create the navigation structure and page layouts for company and user management interfaces.",
            "dependencies": [],
            "details": "Implement a navigation sidebar or header for accessing company and user management pages. Create consistent page layouts with appropriate spacing and responsive design. Add breadcrumbs for navigation context. Implement tab navigation for multi-section pages. Ensure proper routing between management interfaces. Add loading states and error boundaries for each page.",
            "status": "in-progress",
            "testStrategy": "Test navigation flow between different management pages. Verify responsive behavior on different screen sizes. Test loading states and error boundaries. Ensure consistent styling across all management interfaces."
          },
          {
            "id": 15,
            "title": "Add Permission-Based UI Rendering",
            "description": "Implement logic to conditionally render UI elements based on user permissions and roles.",
            "dependencies": [
              "5.12"
            ],
            "details": "Create a permission checking utility that determines if a user can access specific features. Implement conditional rendering for UI elements based on user permissions. Add redirect logic for unauthorized access attempts. Create fallback UI for users with limited permissions. Implement permission-based navigation that only shows accessible options. Add tooltips explaining why certain features are unavailable.",
            "status": "in-progress",
            "testStrategy": "Test UI rendering with different user roles. Verify unauthorized access attempts are properly handled. Test navigation visibility with different permission sets. Ensure proper fallback UI for limited permissions."
          }
        ]
      },
      {
        "id": 6,
        "title": "Advocate Management System",
        "description": "Develop the advocate management system for creating, editing, and managing customer advocates, including availability settings and fatigue prevention.",
        "details": "1. Create advocate management interfaces:\n   - Advocate list view with filtering and search\n   - Advocate creation and editing forms\n   - Advocate profile view\n   - Availability management interface\n2. Implement advocate data models and services:\n```typescript\n// types/advocate.ts\nexport interface Advocate {\n  id: string\n  user_id: string\n  company_id: string\n  name: string\n  title: string\n  company_name: string\n  industry: string\n  company_size: string\n  use_cases: string[]\n  geographic_region: string\n  expertise_areas: string[]\n  availability_score: number\n  total_calls_completed: number\n  last_call_date: string | null\n  max_calls_per_month: number\n  status: 'active' | 'inactive' | 'pending'\n  created_at: string\n  updated_at: string\n}\n\n// services/advocateService.ts\nexport const createAdvocate = async (advocateData: Omit<Advocate, 'id' | 'created_at' | 'updated_at'>) => {\n  const { data, error } = await supabase\n    .from('advocates')\n    .insert(advocateData)\n    .select()\n  \n  if (error) throw error\n  return data[0]\n}\n```\n3. Implement fatigue prevention system:\n   - Track advocate participation frequency\n   - Calculate and update availability scores\n   - Implement cooling-off periods\n   - Create notification system for advocate status changes\n4. Build advocate invitation and onboarding flow\n5. Create advocate availability calendar management",
        "testStrategy": "Test CRUD operations for advocates. Verify fatigue prevention logic with simulated call history. Test availability calculation with various scenarios. Ensure advocate invitation flow works correctly. Verify calendar integration for availability management.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Advocate Data Models and Types",
            "description": "Define the TypeScript interfaces and types for the advocate management system, including the main Advocate interface and related types.",
            "dependencies": [],
            "details": "Create the necessary TypeScript interfaces in the types directory. Start with the Advocate interface as provided in the task description. Add additional types for advocate availability, status tracking, and filtering options. Ensure all properties have appropriate types and documentation.",
            "status": "in-progress",
            "testStrategy": "Verify type definitions with TypeScript compiler. Create sample objects to ensure they conform to the defined interfaces."
          },
          {
            "id": 2,
            "title": "Implement Advocate Service CRUD Operations",
            "description": "Create the advocate service with CRUD operations for managing advocate data in the Supabase database.",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement the advocate service with functions for creating, reading, updating, and deleting advocate records. Use the Supabase client for database operations. Include error handling and return appropriate responses. Implement the createAdvocate function as provided in the task description, and add getAdvocate, updateAdvocate, deleteAdvocate, and listAdvocates functions.",
            "status": "in-progress",
            "testStrategy": "Test each CRUD operation with mock data. Verify error handling for database failures. Test filtering and pagination for list operations."
          },
          {
            "id": 3,
            "title": "Build Advocate List View Component",
            "description": "Create the advocate list view component with filtering, sorting, and search functionality.",
            "dependencies": [
              "6.2"
            ],
            "details": "Implement a responsive list view component for advocates. Include search functionality that filters by name, company, and expertise areas. Add filtering options for status, industry, and availability. Implement sorting by various fields. Use pagination for efficient loading of large datasets. Include status indicators for advocate availability.",
            "status": "in-progress",
            "testStrategy": "Test search and filtering functionality with various inputs. Verify pagination works correctly. Test responsive layout on different screen sizes."
          },
          {
            "id": 4,
            "title": "Create Advocate Profile View Component",
            "description": "Implement the advocate profile view component that displays detailed information about an advocate.",
            "dependencies": [
              "6.2"
            ],
            "details": "Create a detailed profile view component that displays all advocate information. Include sections for personal details, company information, expertise areas, availability status, and call history. Add visual indicators for availability score and status. Implement navigation between the list view and profile view.",
            "status": "in-progress",
            "testStrategy": "Test profile view with various advocate data scenarios. Verify all information displays correctly. Test navigation between views."
          },
          {
            "id": 5,
            "title": "Implement Advocate Creation Form",
            "description": "Build the form component for creating new advocates in the system.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Create a multi-step form for advocate creation. Include fields for all required advocate properties. Implement form validation for required fields and data formats. Add support for selecting multiple expertise areas and use cases. Integrate with the advocate service to submit the form data. Provide appropriate feedback on success or failure.",
            "status": "in-progress",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify form submission works correctly. Test multi-step navigation. Ensure error messages are displayed appropriately."
          },
          {
            "id": 6,
            "title": "Implement Advocate Editing Form",
            "description": "Create the form component for editing existing advocate information.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.5"
            ],
            "details": "Adapt the advocate creation form for editing existing advocates. Pre-populate the form with current advocate data. Implement partial updates to avoid overwriting unchanged fields. Add confirmation for status changes. Include audit tracking for changes.",
            "status": "in-progress",
            "testStrategy": "Test form pre-population with existing data. Verify partial updates work correctly. Test confirmation dialogs for status changes."
          },
          {
            "id": 7,
            "title": "Develop Advocate Availability Management Interface",
            "description": "Create the interface for managing advocate availability settings, including calendar integration and time preferences.",
            "dependencies": [
              "6.2",
              "6.4"
            ],
            "details": "Implement an availability management interface that allows advocates to set their preferred call times. Include calendar integration for blocking out unavailable times. Add recurring availability patterns (e.g., available every Tuesday morning). Implement time zone handling for global availability. Create visual calendar view for availability settings.",
            "status": "in-progress",
            "testStrategy": "Test calendar integration with various availability patterns. Verify time zone handling works correctly. Test recurring availability settings."
          },
          {
            "id": 8,
            "title": "Implement Fatigue Prevention System Core Logic",
            "description": "Develop the core logic for the fatigue prevention system that tracks advocate participation and prevents overuse.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Create a service that tracks advocate participation frequency. Implement logic to calculate and update availability scores based on recent activity. Define cooling-off periods based on call frequency. Create functions to determine if an advocate is available for a new call based on their history and preferences.",
            "status": "in-progress",
            "testStrategy": "Test availability calculation with various call history scenarios. Verify cooling-off periods are enforced correctly. Test edge cases like advocates with no prior calls."
          },
          {
            "id": 9,
            "title": "Build Advocate Status Notification System",
            "description": "Implement the notification system for advocate status changes and availability updates.",
            "dependencies": [
              "6.8"
            ],
            "details": "Create a notification service that monitors advocate status changes. Implement email notifications for status changes (active, inactive, cooling-off). Add in-app notifications for upcoming calls and availability changes. Create notification preferences for advocates and administrators.",
            "status": "in-progress",
            "testStrategy": "Test notification generation for various status changes. Verify email delivery with mock email service. Test notification preferences and opt-out functionality."
          },
          {
            "id": 10,
            "title": "Develop Advocate Invitation and Onboarding Flow",
            "description": "Create the workflow for inviting new advocates to the platform and guiding them through the onboarding process.",
            "dependencies": [
              "6.2",
              "6.5"
            ],
            "details": "Implement an invitation system that sends email invitations to potential advocates. Create a secure registration flow for invited advocates. Build an onboarding wizard that guides new advocates through profile completion, availability settings, and system introduction. Add admin interfaces for tracking invitation status and onboarding progress.",
            "status": "in-progress",
            "testStrategy": "Test invitation sending and tracking. Verify secure registration links work correctly. Test the onboarding wizard with various completion scenarios."
          },
          {
            "id": 11,
            "title": "Implement Advocate Analytics Dashboard",
            "description": "Create an analytics dashboard for monitoring advocate performance, availability, and engagement metrics.",
            "dependencies": [
              "6.2",
              "6.8"
            ],
            "details": "Build an analytics dashboard that displays key metrics for advocates. Include visualizations for call frequency, feedback scores, and availability trends. Add filtering by time period, advocate attributes, and performance metrics. Implement export functionality for reports.",
            "status": "in-progress",
            "testStrategy": "Test dashboard with various data scenarios. Verify visualizations render correctly. Test filtering and export functionality."
          },
          {
            "id": 12,
            "title": "Integrate Advocate Management with User Authentication",
            "description": "Integrate the advocate management system with the authentication system to enforce proper access controls.",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Integrate the advocate management interfaces with the authentication system. Implement role-based access controls for different user types (admins, advocates, sales reps). Add company-based tenant isolation to ensure advocates are only visible to appropriate users. Modify service calls to include authentication tokens and permission checks.",
            "status": "in-progress",
            "testStrategy": "Test access controls with different user roles. Verify tenant isolation prevents cross-company data access. Test authentication token handling and expiration."
          }
        ]
      },
      {
        "id": 7,
        "title": "Opportunity Management and CRM Integration",
        "description": "Implement the opportunity management system and integrate with CRM systems (Salesforce and HubSpot) to sync opportunity data and activity logging.",
        "details": "1. Create opportunity data models and interfaces:\n   - Opportunity list view\n   - Opportunity details view\n   - Opportunity creation/edit forms\n2. Implement Salesforce integration:\n   - OAuth authentication flow\n   - Data synchronization for opportunities\n   - Activity logging\n   - Custom fields for reference tracking\n```typescript\n// services/salesforceService.ts\nexport const connectSalesforce = async (companyId: string, authCode: string) => {\n  // Exchange auth code for tokens\n  // Store connection details in database\n}\n\nexport const syncOpportunities = async (companyId: string) => {\n  // Fetch opportunities from Salesforce\n  // Sync with local database\n}\n\nexport const logReferenceActivity = async (opportunityId: string, callId: string, notes: string) => {\n  // Log reference call activity in Salesforce\n}\n```\n3. Implement HubSpot integration (similar pattern to Salesforce)\n4. Create bidirectional sync mechanism\n5. Implement webhook handlers for CRM updates\n6. Build embedded widget components for CRM systems\n7. Create reporting integration for CRM dashboards",
        "testStrategy": "Test CRM authentication flows with mock OAuth servers. Verify bidirectional sync with test CRM instances. Test activity logging with various call scenarios. Ensure error handling for API failures. Verify webhook handlers correctly process CRM updates.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create opportunity data models and database schema",
            "description": "Define and implement the database schema for opportunities, including relationships to companies, users, and advocates.",
            "dependencies": [],
            "details": "Create SQL migration for opportunities table with fields for name, stage, value, company_id, owner_id, etc. Implement TypeScript interfaces for opportunity data models. Set up Row Level Security policies to ensure proper data isolation between tenants. Include status tracking fields and timestamps for synchronization with CRM systems.",
            "status": "pending",
            "testStrategy": "Write SQL queries to test the schema integrity and relationships. Verify RLS policies by attempting cross-tenant data access."
          },
          {
            "id": 2,
            "title": "Implement opportunity list view component",
            "description": "Create a component to display a list of opportunities with filtering, sorting, and pagination capabilities.",
            "dependencies": [
              "7.1"
            ],
            "details": "Build a React component for displaying opportunities in a table/list format. Implement filters for opportunity stage, value range, and creation date. Add sorting functionality for columns. Implement pagination for large datasets. Include search functionality to filter by opportunity name or details.",
            "status": "pending",
            "testStrategy": "Test rendering with various data sets. Verify filtering and sorting functionality. Test pagination with large data sets. Ensure responsive design works on different screen sizes."
          },
          {
            "id": 3,
            "title": "Implement opportunity details view component",
            "description": "Create a component to display detailed information about a single opportunity, including related activities and reference calls.",
            "dependencies": [
              "7.1"
            ],
            "details": "Build a React component for displaying comprehensive opportunity details. Include sections for basic info, related contacts, activity history, and reference calls. Implement tabs for organizing different types of information. Add edit functionality with proper permission checks.",
            "status": "pending",
            "testStrategy": "Test rendering with various opportunity states. Verify all data is displayed correctly. Test tab navigation and content loading."
          },
          {
            "id": 4,
            "title": "Create opportunity creation and edit forms",
            "description": "Implement forms for creating new opportunities and editing existing ones with validation.",
            "dependencies": [
              "7.1"
            ],
            "details": "Build React form components using Formik or React Hook Form. Implement validation for required fields and data formats. Create form sections for different categories of information. Add functionality to save drafts before submission. Implement error handling and success notifications.",
            "status": "pending",
            "testStrategy": "Test form validation with valid and invalid inputs. Verify form submission and error handling. Test draft saving functionality."
          },
          {
            "id": 5,
            "title": "Implement Salesforce OAuth authentication flow",
            "description": "Create the authentication flow for connecting to Salesforce, including OAuth token exchange and storage.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the OAuth 2.0 flow for Salesforce authentication. Create API endpoints for initiating auth, handling callbacks, and token refresh. Store encrypted tokens securely in the database. Implement token refresh logic to handle expiring access tokens. Add UI components for connection status and reconnection.",
            "status": "pending",
            "testStrategy": "Test OAuth flow with mock Salesforce endpoints. Verify token storage and encryption. Test token refresh logic with expired tokens."
          },
          {
            "id": 6,
            "title": "Implement Salesforce data synchronization for opportunities",
            "description": "Create services to sync opportunity data between the application and Salesforce.",
            "dependencies": [
              "7.1",
              "7.5"
            ],
            "details": "Implement bidirectional sync between local database and Salesforce. Create mapping logic for field transformations between systems. Handle conflict resolution for simultaneous updates. Implement batch processing for large datasets. Add logging for sync operations and errors.",
            "status": "pending",
            "testStrategy": "Test sync with mock Salesforce API responses. Verify conflict resolution with simultaneous updates. Test error handling with API failures."
          },
          {
            "id": 7,
            "title": "Implement Salesforce activity logging",
            "description": "Create services to log reference call activities and other events to Salesforce.",
            "dependencies": [
              "7.5",
              "7.6"
            ],
            "details": "Implement activity logging for reference calls, including call outcomes, notes, and follow-ups. Create mapping between internal activity types and Salesforce activity types. Add support for custom fields in Salesforce activities. Implement queuing system for failed log attempts.",
            "status": "pending",
            "testStrategy": "Test activity logging with various call scenarios. Verify custom field mapping. Test retry logic for failed API calls."
          },
          {
            "id": 8,
            "title": "Implement HubSpot OAuth authentication flow",
            "description": "Create the authentication flow for connecting to HubSpot, including OAuth token exchange and storage.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement the OAuth 2.0 flow for HubSpot authentication. Create API endpoints for initiating auth, handling callbacks, and token refresh. Store encrypted tokens securely in the database. Implement token refresh logic to handle expiring access tokens. Add UI components for connection status and reconnection.",
            "status": "pending",
            "testStrategy": "Test OAuth flow with mock HubSpot endpoints. Verify token storage and encryption. Test token refresh logic with expired tokens."
          },
          {
            "id": 9,
            "title": "Implement HubSpot data synchronization for opportunities",
            "description": "Create services to sync opportunity data between the application and HubSpot.",
            "dependencies": [
              "7.1",
              "7.8"
            ],
            "details": "Implement bidirectional sync between local database and HubSpot. Create mapping logic for field transformations between systems. Handle conflict resolution for simultaneous updates. Implement batch processing for large datasets. Add logging for sync operations and errors.",
            "status": "pending",
            "testStrategy": "Test sync with mock HubSpot API responses. Verify conflict resolution with simultaneous updates. Test error handling with API failures."
          },
          {
            "id": 10,
            "title": "Implement HubSpot activity logging",
            "description": "Create services to log reference call activities and other events to HubSpot.",
            "dependencies": [
              "7.8",
              "7.9"
            ],
            "details": "Implement activity logging for reference calls, including call outcomes, notes, and follow-ups. Create mapping between internal activity types and HubSpot activity types. Add support for custom properties in HubSpot activities. Implement queuing system for failed log attempts.",
            "status": "pending",
            "testStrategy": "Test activity logging with various call scenarios. Verify custom property mapping. Test retry logic for failed API calls."
          },
          {
            "id": 11,
            "title": "Create CRM webhook handlers for real-time updates",
            "description": "Implement webhook handlers to receive and process real-time updates from Salesforce and HubSpot.",
            "dependencies": [
              "7.6",
              "7.9"
            ],
            "details": "Create API endpoints to receive webhook notifications from CRM systems. Implement signature verification for webhook security. Process incoming data and update local database accordingly. Handle different event types (create, update, delete). Add monitoring and alerting for webhook failures.",
            "status": "pending",
            "testStrategy": "Test webhook handlers with sample payloads from both CRMs. Verify signature validation logic. Test handling of different event types. Ensure proper error handling for malformed requests."
          },
          {
            "id": 12,
            "title": "Implement CRM connection management UI",
            "description": "Create user interface components for managing CRM connections, including setup, status, and troubleshooting.",
            "dependencies": [
              "7.5",
              "7.8"
            ],
            "details": "Build React components for CRM connection management. Implement connection status indicators. Create setup wizards for new connections. Add troubleshooting tools for connection issues. Implement permission controls for CRM management features.",
            "status": "pending",
            "testStrategy": "Test UI rendering in different connection states. Verify setup wizard flow. Test error handling and display of troubleshooting information."
          },
          {
            "id": 13,
            "title": "Build embedded widget components for CRM systems",
            "description": "Create embeddable widgets that can be integrated into Salesforce and HubSpot interfaces.",
            "dependencies": [
              "7.6",
              "7.9"
            ],
            "details": "Develop embeddable JavaScript widgets for CRM systems. Create authentication mechanism for embedded contexts. Implement UI components that match CRM visual styles. Add functionality to view and schedule reference calls directly from CRM. Create documentation for widget installation.",
            "status": "pending",
            "testStrategy": "Test widget loading in mock CRM environments. Verify authentication in embedded context. Test responsive design within CRM layouts."
          },
          {
            "id": 14,
            "title": "Implement reporting integration for CRM dashboards",
            "description": "Create integration points for exposing reference call metrics and data in CRM reporting dashboards.",
            "dependencies": [
              "7.6",
              "7.9",
              "7.7",
              "7.10"
            ],
            "details": "Implement data endpoints for CRM reporting tools. Create pre-built report templates for common metrics. Develop custom objects/entities in CRMs for advanced reporting. Add scheduled data exports for offline reporting. Implement proper access controls for sensitive metrics.",
            "status": "pending",
            "testStrategy": "Test data endpoint responses with various query parameters. Verify report template generation. Test scheduled export functionality."
          },
          {
            "id": 15,
            "title": "Create unified CRM service abstraction layer",
            "description": "Implement a unified service layer that abstracts away differences between CRM systems.",
            "dependencies": [
              "7.6",
              "7.7",
              "7.9",
              "7.10"
            ],
            "details": "Create a unified CRM service interface that works with multiple CRM providers. Implement provider-specific adapters for Salesforce and HubSpot. Add factory pattern for selecting the appropriate provider. Create comprehensive error handling and retry logic. Add support for future CRM integrations.",
            "status": "pending",
            "testStrategy": "Test service with both CRM providers. Verify adapter pattern correctly handles provider differences. Test factory selection logic with various company configurations."
          },
          {
            "id": 16,
            "title": "Implement CRM sync scheduling and monitoring",
            "description": "Create a system for scheduling regular CRM synchronization and monitoring sync health.",
            "dependencies": [
              "7.6",
              "7.9",
              "7.15"
            ],
            "details": "Implement scheduled jobs for regular CRM synchronization. Create admin dashboard for monitoring sync status and history. Add alerting for sync failures or discrepancies. Implement manual sync triggers for immediate synchronization. Add detailed logging for troubleshooting.",
            "status": "pending",
            "testStrategy": "Test scheduled job execution. Verify monitoring dashboard displays accurate information. Test alerting with simulated failures. Verify manual sync triggers work correctly."
          }
        ]
      },
      {
        "id": 8,
        "title": "AI-Powered Advocate Matching System",
        "description": "Develop the AI-powered advocate matching system that recommends the best advocates based on prospect profiles, advocate relevance, and availability.",
        "details": "1. Implement the matching algorithm infrastructure:\n   - Create data preparation utilities\n   - Build OpenAI integration for matching\n   - Implement fallback rule-based matching\n2. Create the matching service:\n```typescript\n// services/matchingService.ts\nexport const findMatchingAdvocates = async (opportunityId: string, filters?: MatchFilters) => {\n  // Fetch opportunity details\n  const opportunity = await getOpportunity(opportunityId)\n  \n  // Prepare context for AI matching\n  const matchingContext = {\n    industry: opportunity.prospect_industry,\n    companySize: opportunity.prospect_size,\n    useCase: opportunity.use_case,\n    // Other relevant factors\n  }\n  \n  // Call OpenAI for intelligent matching\n  const aiMatches = await getAIRecommendations(matchingContext)\n  \n  // Apply availability and fatigue filters\n  const availableMatches = await filterByAvailability(aiMatches)\n  \n  // Apply any additional filters\n  const finalMatches = filters ? applyCustomFilters(availableMatches, filters) : availableMatches\n  \n  return finalMatches\n}\n\nasync function getAIRecommendations(context) {\n  const { data } = await openai.createCompletion({\n    model: \"gpt-4\",\n    prompt: generateMatchingPrompt(context),\n    // Other OpenAI parameters\n  })\n  \n  // Process and structure the response\n  return processAIResponse(data)\n}\n```\n3. Implement confidence scoring system\n4. Create feedback loop for improving recommendations\n5. Build the matching UI components:\n   - Recommendation display with confidence scores\n   - Filtering interface\n   - Selection and booking flow\n6. Implement caching for performance optimization",
        "testStrategy": "Test matching algorithm with various opportunity profiles. Verify AI integration with mock responses. Test fallback mechanisms when AI is unavailable. Measure recommendation quality with historical data. Verify confidence scoring accuracy. Test the feedback loop for recommendation improvement.",
        "priority": "high",
        "dependencies": [
          2,
          6,
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Data Preparation Utilities",
            "description": "Develop utilities to prepare and structure data for the AI matching algorithm, including opportunity and advocate data normalization.",
            "dependencies": [],
            "details": "Create a set of utility functions in `utils/dataPreparation.ts` that transform raw opportunity and advocate data into a structured format suitable for the matching algorithm. Include functions for extracting relevant features, normalizing text fields, and creating embeddings for semantic matching. Implement methods to handle missing data and standardize industry terms and company sizes.",
            "status": "pending",
            "testStrategy": "Write unit tests for each utility function with various input scenarios including edge cases like missing data. Verify that the output format is consistent and properly structured for the matching algorithm."
          },
          {
            "id": 2,
            "title": "Implement OpenAI Integration for Matching",
            "description": "Build the integration with OpenAI API for intelligent advocate matching based on opportunity context.",
            "dependencies": [
              "8.1"
            ],
            "details": "Create a service in `services/aiService.ts` that handles communication with OpenAI. Implement functions to generate appropriate prompts based on opportunity context, send requests to OpenAI API, and parse responses. Include error handling, retry logic, and response validation. Configure the service to use the appropriate OpenAI model (GPT-4) and parameters for optimal matching results.",
            "status": "pending",
            "testStrategy": "Test the OpenAI integration with mock API responses. Verify prompt generation with different opportunity contexts. Test error handling and retry mechanisms by simulating API failures."
          },
          {
            "id": 3,
            "title": "Develop Rule-Based Fallback Matching System",
            "description": "Create a rule-based matching system that serves as a fallback when AI matching is unavailable or returns insufficient results.",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement a rule-based matching algorithm in `services/fallbackMatching.ts` that uses deterministic rules to match advocates to opportunities. Include logic for industry matching, company size compatibility, use case alignment, and geographic relevance. Design the system to be configurable with weighted scoring for different matching criteria. Ensure the output format matches the AI-based system for seamless integration.",
            "status": "pending",
            "testStrategy": "Test the rule-based matching with various opportunity profiles and advocate datasets. Verify that the scoring system correctly prioritizes the most relevant advocates. Compare results with expected outcomes for known test cases."
          },
          {
            "id": 4,
            "title": "Create Core Matching Service",
            "description": "Develop the main matching service that orchestrates the AI and rule-based matching systems and applies filters.",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Implement the `services/matchingService.ts` as outlined in the task description. Create the `findMatchingAdvocates` function that fetches opportunity details, prepares context for AI matching, calls the AI service, applies availability and fatigue filters, and handles custom filters. Add proper error handling and logging. Ensure the service gracefully falls back to rule-based matching when AI matching fails or returns insufficient results.",
            "status": "pending",
            "testStrategy": "Test the matching service with various opportunity profiles. Verify that it correctly integrates both AI and fallback matching systems. Test the filter application logic with different filter combinations. Simulate AI service failures to verify fallback behavior."
          },
          {
            "id": 5,
            "title": "Implement Availability and Fatigue Filtering",
            "description": "Create functions to filter advocate matches based on their availability and prevent advocate fatigue.",
            "dependencies": [
              "8.4"
            ],
            "details": "Develop the `filterByAvailability` function in `services/availabilityService.ts` that checks advocate calendars and availability settings. Implement fatigue prevention logic that considers recent and upcoming calls to avoid overusing the same advocates. Create a scoring system that factors in recency and frequency of previous engagements. Integrate with the advocate management system to access availability data.",
            "status": "pending",
            "testStrategy": "Test availability filtering with various calendar scenarios. Verify fatigue prevention with simulated call history data. Test edge cases like advocates with no availability or fully booked schedules."
          },
          {
            "id": 6,
            "title": "Implement Custom Filtering System",
            "description": "Create a flexible filtering system that allows users to apply additional criteria to advocate matches.",
            "dependencies": [
              "8.4"
            ],
            "details": "Implement the `applyCustomFilters` function in `services/filterService.ts` that processes user-defined filters. Support filtering by industry, company size, geographic region, use case, language, and other relevant attributes. Design the filter system to be extensible for future filter types. Ensure filters can be combined with logical AND/OR operations.",
            "status": "pending",
            "testStrategy": "Test the custom filtering system with various filter combinations. Verify that complex filter logic works correctly. Test performance with large datasets and multiple filters."
          },
          {
            "id": 7,
            "title": "Develop Confidence Scoring System",
            "description": "Implement a system to calculate and assign confidence scores to advocate matches based on relevance and fit.",
            "dependencies": [
              "8.4"
            ],
            "details": "Create a confidence scoring module in `services/confidenceScoring.ts` that evaluates the quality of each match. Develop algorithms to calculate scores based on industry match, use case relevance, company size similarity, and other factors. Normalize scores on a 0-100 scale. Include confidence metadata from AI responses when available. Ensure scores are consistent between AI and rule-based matching systems.",
            "status": "pending",
            "testStrategy": "Test confidence scoring with various match scenarios. Verify score normalization and consistency. Compare scores against expert-rated matches to validate the scoring algorithm."
          },
          {
            "id": 8,
            "title": "Create Feedback Collection System",
            "description": "Implement a system to collect feedback on advocate matches to improve future recommendations.",
            "dependencies": [
              "8.7"
            ],
            "details": "Develop a feedback collection service in `services/feedbackService.ts` that captures user ratings and comments on advocate matches. Create data structures to store feedback data in the database. Implement functions to associate feedback with specific matches and opportunities. Design the system to collect both explicit feedback (ratings) and implicit feedback (selections made).",
            "status": "pending",
            "testStrategy": "Test feedback collection with various user inputs. Verify that feedback is correctly associated with matches and stored in the database. Test the feedback API endpoints with different request scenarios."
          },
          {
            "id": 9,
            "title": "Implement Feedback-Based Learning System",
            "description": "Create a system that uses collected feedback to improve future advocate matching recommendations.",
            "dependencies": [
              "8.8"
            ],
            "details": "Develop a learning system in `services/matchLearning.ts` that analyzes feedback data to refine matching algorithms. Implement functions to adjust matching weights based on historical feedback. Create a periodic job to process feedback and update matching parameters. Design the system to identify patterns in successful matches and incorporate them into future recommendations.",
            "status": "pending",
            "testStrategy": "Test the learning system with historical feedback data. Verify that matching parameters are appropriately adjusted based on feedback. Measure recommendation quality improvement over time with simulated feedback cycles."
          },
          {
            "id": 10,
            "title": "Build Recommendation Display Component",
            "description": "Create the UI component for displaying advocate recommendations with confidence scores and relevant information.",
            "dependencies": [
              "8.7"
            ],
            "details": "Develop a React component in `components/AdvocateRecommendations.tsx` that displays advocate matches with their confidence scores, relevance factors, and availability. Implement sorting by confidence score and other attributes. Include advocate details like industry experience, company size, and use case expertise. Design the component to be responsive and accessible.",
            "status": "pending",
            "testStrategy": "Create unit tests for the component with various data scenarios. Test sorting and filtering functionality. Verify responsive behavior at different screen sizes. Test accessibility compliance."
          },
          {
            "id": 11,
            "title": "Create Filtering Interface Component",
            "description": "Build the UI component for applying custom filters to advocate recommendations.",
            "dependencies": [
              "8.6",
              "8.10"
            ],
            "details": "Implement a filtering interface component in `components/AdvocateFilters.tsx` that allows users to apply and manage custom filters. Include filter controls for industry, company size, geographic region, use case, and other attributes. Design the component with clear visual feedback for active filters. Implement filter combination logic with AND/OR operations.",
            "status": "pending",
            "testStrategy": "Test the filtering interface with various filter combinations. Verify that the UI correctly reflects active filters. Test filter application and removal. Verify that filter changes trigger appropriate data updates."
          },
          {
            "id": 12,
            "title": "Develop Advocate Selection and Booking Flow",
            "description": "Create the UI flow for selecting advocates from recommendations and booking them for reference calls.",
            "dependencies": [
              "8.10"
            ],
            "details": "Implement the selection and booking flow in `components/AdvocateBooking.tsx` that allows users to select advocates from recommendations and schedule calls. Include confirmation steps, calendar integration, and notification setup. Design the flow to handle multiple advocate selections. Implement validation to prevent double-booking and scheduling conflicts.",
            "status": "pending",
            "testStrategy": "Test the booking flow with various selection scenarios. Verify calendar integration and availability checking. Test validation logic for scheduling conflicts. Verify that notifications are correctly triggered."
          },
          {
            "id": 13,
            "title": "Implement Caching System for Performance Optimization",
            "description": "Develop a caching system to improve performance of advocate matching and reduce API calls.",
            "dependencies": [
              "8.4"
            ],
            "details": "Create a caching service in `services/cachingService.ts` that stores and retrieves matching results. Implement cache invalidation strategies based on data changes and time expiration. Use Redis or a similar in-memory store for high-performance caching. Design the system to cache at multiple levels: raw AI responses, processed matches, and filtered results.",
            "status": "pending",
            "testStrategy": "Test cache hit and miss scenarios. Verify cache invalidation when underlying data changes. Measure performance improvements with and without caching. Test cache behavior under concurrent access."
          },
          {
            "id": 14,
            "title": "Create Admin Interface for Matching Configuration",
            "description": "Build an admin interface for configuring and tuning the matching algorithm parameters.",
            "dependencies": [
              "8.7",
              "8.9"
            ],
            "details": "Develop an admin configuration interface in `components/admin/MatchingConfiguration.tsx` that allows administrators to view and adjust matching algorithm parameters. Include controls for confidence threshold, weighting factors, and fallback behavior. Implement validation for configuration changes. Design the interface with clear explanations of each parameter's impact.",
            "status": "pending",
            "testStrategy": "Test the admin interface with various configuration changes. Verify that changes are correctly saved and applied to the matching algorithm. Test validation logic for invalid configurations. Verify that configuration history is maintained."
          }
        ]
      },
      {
        "id": 9,
        "title": "Calendar Integration and Scheduling System",
        "description": "Implement the scheduling system with calendar integrations (Google Calendar, Outlook) for real-time availability display and automated meeting creation.",
        "details": "1. Implement OAuth flows for calendar providers:\n   - Google Calendar authentication\n   - Microsoft Graph (Outlook) authentication\n2. Create calendar service abstractions:\n```typescript\n// services/calendarService.ts\ninterface CalendarProvider {\n  getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]>\n  createMeeting(details: MeetingDetails): Promise<Meeting>\n  updateMeeting(meetingId: string, details: Partial<MeetingDetails>): Promise<Meeting>\n  deleteMeeting(meetingId: string): Promise<void>\n}\n\nclass GoogleCalendarProvider implements CalendarProvider {\n  // Implementation for Google Calendar\n}\n\nclass OutlookCalendarProvider implements CalendarProvider {\n  // Implementation for Outlook\n}\n\nexport const getCalendarProvider = (type: 'google' | 'outlook'): CalendarProvider => {\n  if (type === 'google') return new GoogleCalendarProvider()\n  return new OutlookCalendarProvider()\n}\n```\n3. Implement availability calculation and display:\n   - Fetch and merge calendar events\n   - Calculate available time slots\n   - Handle time zone differences\n4. Build meeting creation workflow:\n   - Create calendar events\n   - Generate video meeting links (Zoom/Teams)\n   - Send calendar invitations\n5. Implement notification system:\n   - Booking confirmations\n   - Reminder notifications\n   - Rescheduling/cancellation handling\n6. Create the scheduling UI components:\n   - Date/time picker\n   - Availability display\n   - Booking confirmation\n   - Rescheduling interface",
        "testStrategy": "Test OAuth flows with mock authentication servers. Verify availability calculation with various calendar scenarios. Test meeting creation across different calendar providers. Ensure proper time zone handling. Test notification delivery for various events. Verify rescheduling and cancellation workflows.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Google Calendar OAuth Flow",
            "description": "Set up OAuth authentication flow for Google Calendar integration, including authorization endpoints, token handling, and user consent screens.",
            "dependencies": [],
            "details": "1. Create OAuth configuration for Google Calendar API in Google Cloud Console\n2. Implement authorization URL generation with required scopes (calendar.readonly, calendar.events)\n3. Create callback handler to process OAuth code and exchange for tokens\n4. Implement token storage in database with encryption\n5. Add token refresh mechanism for expired tokens\n6. Create user interface for connecting Google Calendar\n\nExample code:\n```typescript\n// services/auth/googleAuth.ts\nimport { oauth2Client } from '../config/googleApi';\n\nexport const generateAuthUrl = (userId: string): string => {\n  return oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: ['https://www.googleapis.com/auth/calendar.readonly', 'https://www.googleapis.com/auth/calendar.events'],\n    state: userId, // Pass user ID to callback\n    prompt: 'consent'\n  });\n};\n\nexport const handleCallback = async (code: string): Promise<{\n  tokens: any;\n  userId: string;\n}> => {\n  const { tokens } = await oauth2Client.getToken(code);\n  // Store tokens in database\n  return { tokens, userId };\n};\n```",
            "status": "pending",
            "testStrategy": "1. Create mock OAuth endpoints for testing\n2. Verify correct scopes are requested\n3. Test token exchange with mock responses\n4. Verify token storage and encryption\n5. Test token refresh mechanism with expired tokens\n6. Verify error handling for failed authentication attempts"
          },
          {
            "id": 2,
            "title": "Implement Microsoft Outlook OAuth Flow",
            "description": "Set up OAuth authentication flow for Microsoft Outlook Calendar integration using Microsoft Graph API, including authorization endpoints, token handling, and user consent screens.",
            "dependencies": [],
            "details": "1. Register application in Azure AD portal\n2. Configure Microsoft Graph API permissions (Calendars.Read, Calendars.ReadWrite)\n3. Implement authorization URL generation with required scopes\n4. Create callback handler to process OAuth code and exchange for tokens\n5. Implement token storage in database with encryption\n6. Add token refresh mechanism for expired tokens\n7. Create user interface for connecting Outlook Calendar\n\nExample code:\n```typescript\n// services/auth/outlookAuth.ts\nimport { confidentialClientApplication } from '../config/microsoftGraph';\n\nexport const generateAuthUrl = (userId: string): string => {\n  const authCodeUrlParameters = {\n    scopes: ['Calendars.Read', 'Calendars.ReadWrite'],\n    redirectUri: process.env.OUTLOOK_REDIRECT_URI,\n    state: userId\n  };\n  \n  return confidentialClientApplication.getAuthCodeUrl(authCodeUrlParameters);\n};\n\nexport const handleCallback = async (code: string): Promise<{\n  tokens: any;\n  userId: string;\n}> => {\n  const tokenResponse = await confidentialClientApplication.acquireTokenByCode({\n    code,\n    redirectUri: process.env.OUTLOOK_REDIRECT_URI,\n    scopes: ['Calendars.Read', 'Calendars.ReadWrite']\n  });\n  \n  // Store tokens in database\n  return { tokens: tokenResponse, userId };\n};\n```",
            "status": "pending",
            "testStrategy": "1. Create mock OAuth endpoints for testing\n2. Verify correct scopes are requested\n3. Test token exchange with mock responses\n4. Verify token storage and encryption\n5. Test token refresh mechanism with expired tokens\n6. Verify error handling for failed authentication attempts"
          },
          {
            "id": 3,
            "title": "Implement Google Calendar Provider",
            "description": "Create the Google Calendar provider implementation that handles fetching availability, creating meetings, updating meetings, and deleting meetings using the Google Calendar API.",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Implement the CalendarProvider interface for Google Calendar\n2. Create methods to fetch calendar events within a date range\n3. Implement availability calculation based on existing events\n4. Add methods to create, update, and delete calendar events\n5. Handle time zone conversions for events\n6. Implement video conferencing link generation (Google Meet)\n\nExample code:\n```typescript\n// services/calendar/googleCalendarProvider.ts\nimport { google } from 'googleapis';\nimport { CalendarProvider, AvailabilitySlot, MeetingDetails, Meeting } from '../calendarService';\n\nexport class GoogleCalendarProvider implements CalendarProvider {\n  private getAuthClient(userId: string) {\n    // Fetch tokens from database and create authenticated client\n    // ...\n    return authClient;\n  }\n\n  async getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]> {\n    const auth = this.getAuthClient(userId);\n    const calendar = google.calendar({ version: 'v3', auth });\n    \n    const response = await calendar.events.list({\n      calendarId: 'primary',\n      timeMin: startDate.toISOString(),\n      timeMax: endDate.toISOString(),\n      singleEvents: true,\n      orderBy: 'startTime',\n    });\n    \n    // Process events and calculate availability slots\n    // ...\n    \n    return availabilitySlots;\n  }\n\n  async createMeeting(details: MeetingDetails): Promise<Meeting> {\n    const auth = this.getAuthClient(details.userId);\n    const calendar = google.calendar({ version: 'v3', auth });\n    \n    const event = {\n      summary: details.title,\n      description: details.description,\n      start: { dateTime: details.startTime.toISOString() },\n      end: { dateTime: details.endTime.toISOString() },\n      attendees: details.attendees.map(email => ({ email })),\n      conferenceData: {\n        createRequest: { requestId: uuid() }\n      }\n    };\n    \n    const response = await calendar.events.insert({\n      calendarId: 'primary',\n      conferenceDataVersion: 1,\n      requestBody: event\n    });\n    \n    return this.mapToMeeting(response.data);\n  }\n\n  // Implement updateMeeting and deleteMeeting methods\n  // ...\n}\n```",
            "status": "pending",
            "testStrategy": "1. Mock Google Calendar API responses for testing\n2. Test availability calculation with various calendar scenarios\n3. Verify meeting creation with correct parameters\n4. Test meeting updates and deletions\n5. Verify proper handling of time zones\n6. Test error handling for API failures"
          },
          {
            "id": 4,
            "title": "Implement Outlook Calendar Provider",
            "description": "Create the Outlook Calendar provider implementation that handles fetching availability, creating meetings, updating meetings, and deleting meetings using the Microsoft Graph API.",
            "dependencies": [
              "9.2"
            ],
            "details": "1. Implement the CalendarProvider interface for Outlook Calendar\n2. Create methods to fetch calendar events within a date range\n3. Implement availability calculation based on existing events\n4. Add methods to create, update, and delete calendar events\n5. Handle time zone conversions for events\n6. Implement video conferencing link generation (Microsoft Teams)\n\nExample code:\n```typescript\n// services/calendar/outlookCalendarProvider.ts\nimport { Client } from '@microsoft/microsoft-graph-client';\nimport { CalendarProvider, AvailabilitySlot, MeetingDetails, Meeting } from '../calendarService';\n\nexport class OutlookCalendarProvider implements CalendarProvider {\n  private getGraphClient(userId: string) {\n    // Fetch tokens from database and create authenticated client\n    // ...\n    return client;\n  }\n\n  async getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]> {\n    const client = this.getGraphClient(userId);\n    \n    const events = await client\n      .api(`/me/calendarView?startDateTime=${startDate.toISOString()}&endDateTime=${endDate.toISOString()}`)\n      .select('subject,start,end,isAllDay')\n      .orderby('start/dateTime')\n      .get();\n    \n    // Process events and calculate availability slots\n    // ...\n    \n    return availabilitySlots;\n  }\n\n  async createMeeting(details: MeetingDetails): Promise<Meeting> {\n    const client = this.getGraphClient(details.userId);\n    \n    const event = {\n      subject: details.title,\n      body: {\n        contentType: 'HTML',\n        content: details.description\n      },\n      start: {\n        dateTime: details.startTime.toISOString(),\n        timeZone: 'UTC'\n      },\n      end: {\n        dateTime: details.endTime.toISOString(),\n        timeZone: 'UTC'\n      },\n      attendees: details.attendees.map(email => ({\n        emailAddress: { address: email },\n        type: 'required'\n      })),\n      isOnlineMeeting: true,\n      onlineMeetingProvider: 'teamsForBusiness'\n    };\n    \n    const response = await client.api('/me/events').post(event);\n    \n    return this.mapToMeeting(response);\n  }\n\n  // Implement updateMeeting and deleteMeeting methods\n  // ...\n}\n```",
            "status": "pending",
            "testStrategy": "1. Mock Microsoft Graph API responses for testing\n2. Test availability calculation with various calendar scenarios\n3. Verify meeting creation with correct parameters\n4. Test meeting updates and deletions\n5. Verify proper handling of time zones\n6. Test error handling for API failures"
          },
          {
            "id": 5,
            "title": "Implement Calendar Service Factory and Abstractions",
            "description": "Create the calendar service factory and abstractions that provide a unified interface for working with different calendar providers.",
            "dependencies": [
              "9.3",
              "9.4"
            ],
            "details": "1. Implement the CalendarProvider interface\n2. Create factory method to get appropriate calendar provider\n3. Implement shared utility functions for availability calculations\n4. Add methods for working with multiple calendar providers simultaneously\n5. Create database models for storing calendar connections\n\nExample code:\n```typescript\n// services/calendarService.ts\nexport interface AvailabilitySlot {\n  start: Date;\n  end: Date;\n}\n\nexport interface MeetingDetails {\n  userId: string;\n  title: string;\n  description: string;\n  startTime: Date;\n  endTime: Date;\n  attendees: string[];\n  videoConferencing?: boolean;\n}\n\nexport interface Meeting {\n  id: string;\n  title: string;\n  description: string;\n  startTime: Date;\n  endTime: Date;\n  attendees: string[];\n  videoConferenceLink?: string;\n  calendarLink: string;\n}\n\nexport interface CalendarProvider {\n  getAvailability(userId: string, startDate: Date, endDate: Date): Promise<AvailabilitySlot[]>;\n  createMeeting(details: MeetingDetails): Promise<Meeting>;\n  updateMeeting(meetingId: string, details: Partial<MeetingDetails>): Promise<Meeting>;\n  deleteMeeting(meetingId: string): Promise<void>;\n}\n\nimport { GoogleCalendarProvider } from './calendar/googleCalendarProvider';\nimport { OutlookCalendarProvider } from './calendar/outlookCalendarProvider';\n\nexport const getCalendarProvider = (type: 'google' | 'outlook'): CalendarProvider => {\n  if (type === 'google') return new GoogleCalendarProvider();\n  return new OutlookCalendarProvider();\n};\n\n// Get user's connected calendar providers\nexport const getUserCalendarProviders = async (userId: string): Promise<Array<{\n  type: 'google' | 'outlook';\n  provider: CalendarProvider;\n}>> => {\n  // Fetch user's connected calendars from database\n  // Return initialized providers\n};\n\n// Get availability across all connected calendars\nexport const getUserAvailability = async (\n  userId: string,\n  startDate: Date,\n  endDate: Date\n): Promise<AvailabilitySlot[]> => {\n  const providers = await getUserCalendarProviders(userId);\n  \n  // Fetch availability from all providers\n  const availabilityPromises = providers.map(({ provider }) => \n    provider.getAvailability(userId, startDate, endDate)\n  );\n  \n  const availabilities = await Promise.all(availabilityPromises);\n  \n  // Merge availabilities and resolve conflicts\n  return mergeAvailabilities(availabilities);\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test factory method returns correct provider instances\n2. Verify availability merging with multiple calendars\n3. Test handling of conflicting events across calendars\n4. Verify proper database operations for calendar connections\n5. Test error handling when a provider fails"
          },
          {
            "id": 6,
            "title": "Implement Availability Calculation Algorithm",
            "description": "Create an algorithm to calculate available time slots based on calendar events, working hours, and buffer times.",
            "dependencies": [
              "9.5"
            ],
            "details": "1. Implement function to merge events from multiple calendars\n2. Create algorithm to find free slots between events\n3. Add support for working hours constraints\n4. Implement buffer time before/after meetings\n5. Handle time zone differences in availability calculation\n6. Add support for minimum meeting duration filtering\n\nExample code:\n```typescript\n// services/availability/availabilityCalculator.ts\nimport { AvailabilitySlot } from '../calendarService';\n\ninterface CalendarEvent {\n  start: Date;\n  end: Date;\n}\n\ninterface WorkingHours {\n  daysOfWeek: number[]; // 0 = Sunday, 6 = Saturday\n  startTime: string; // Format: \"HH:MM\"\n  endTime: string; // Format: \"HH:MM\"\n  timeZone: string;\n}\n\nexport const mergeEvents = (eventSets: CalendarEvent[][]): CalendarEvent[] => {\n  // Flatten and sort all events\n  const allEvents = eventSets.flat().sort((a, b) => a.start.getTime() - b.start.getTime());\n  \n  // Merge overlapping events\n  const mergedEvents: CalendarEvent[] = [];\n  \n  for (const event of allEvents) {\n    const lastEvent = mergedEvents[mergedEvents.length - 1];\n    \n    if (!lastEvent || event.start > lastEvent.end) {\n      mergedEvents.push(event);\n    } else if (event.end > lastEvent.end) {\n      lastEvent.end = event.end;\n    }\n  }\n  \n  return mergedEvents;\n};\n\nexport const calculateAvailability = (\n  startDate: Date,\n  endDate: Date,\n  events: CalendarEvent[],\n  workingHours: WorkingHours,\n  bufferMinutes: number = 0,\n  minimumDurationMinutes: number = 15\n): AvailabilitySlot[] => {\n  const availableSlots: AvailabilitySlot[] = [];\n  const mergedEvents = [...events];\n  \n  // Add working hours constraints as events\n  // ...\n  \n  // Sort events chronologically\n  mergedEvents.sort((a, b) => a.start.getTime() - b.start.getTime());\n  \n  // Find gaps between events\n  let currentTime = new Date(startDate);\n  \n  for (const event of mergedEvents) {\n    // Add buffer to current time\n    const bufferTime = new Date(currentTime);\n    bufferTime.setMinutes(bufferTime.getMinutes() + bufferMinutes);\n    \n    // If there's a gap between current time (with buffer) and next event\n    if (bufferTime < event.start) {\n      // Check if gap meets minimum duration\n      const gapDuration = event.start.getTime() - bufferTime.getTime();\n      if (gapDuration >= minimumDurationMinutes * 60 * 1000) {\n        availableSlots.push({\n          start: new Date(bufferTime),\n          end: new Date(event.start)\n        });\n      }\n    }\n    \n    // Move current time to end of event plus buffer\n    currentTime = new Date(event.end);\n    currentTime.setMinutes(currentTime.getMinutes() + bufferMinutes);\n  }\n  \n  // Check for availability after last event\n  if (currentTime < endDate) {\n    availableSlots.push({\n      start: new Date(currentTime),\n      end: new Date(endDate)\n    });\n  }\n  \n  return availableSlots;\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test with various calendar event scenarios\n2. Verify working hours constraints are properly applied\n3. Test buffer time calculations\n4. Verify time zone handling with events in different time zones\n5. Test minimum duration filtering\n6. Verify merging of events from multiple calendars"
          },
          {
            "id": 7,
            "title": "Implement Meeting Creation Workflow",
            "description": "Create the workflow for scheduling meetings, including calendar event creation, video conferencing links, and sending invitations.",
            "dependencies": [
              "9.5"
            ],
            "details": "1. Implement meeting creation service\n2. Add support for generating video conferencing links (Zoom/Teams/Meet)\n3. Create email invitation templates\n4. Implement meeting confirmation workflow\n5. Add support for adding meeting details to both host and attendee calendars\n\nExample code:\n```typescript\n// services/meeting/meetingService.ts\nimport { MeetingDetails, Meeting, getCalendarProvider } from '../calendarService';\nimport { sendMeetingInvitation } from '../notifications/emailService';\nimport { generateZoomMeetingLink } from '../integrations/zoomService';\n\nexport interface ScheduleMeetingRequest {\n  hostUserId: string;\n  hostCalendarType: 'google' | 'outlook';\n  title: string;\n  description: string;\n  startTime: Date;\n  endTime: Date;\n  attendees: string[];\n  useVideoConferencing: boolean;\n  videoProvider?: 'zoom' | 'teams' | 'meet';\n}\n\nexport const scheduleMeeting = async (request: ScheduleMeetingRequest): Promise<Meeting> => {\n  // Get the appropriate calendar provider\n  const calendarProvider = getCalendarProvider(request.hostCalendarType);\n  \n  // Generate video conferencing link if requested\n  let videoConferenceLink: string | undefined;\n  \n  if (request.useVideoConferencing) {\n    if (request.videoProvider === 'zoom') {\n      videoConferenceLink = await generateZoomMeetingLink({\n        topic: request.title,\n        startTime: request.startTime,\n        duration: Math.ceil((request.endTime.getTime() - request.startTime.getTime()) / (60 * 1000))\n      });\n    }\n    // Handle other providers or use native calendar video conferencing\n  }\n  \n  // Create meeting details\n  const meetingDetails: MeetingDetails = {\n    userId: request.hostUserId,\n    title: request.title,\n    description: request.description + (videoConferenceLink ? `\\n\\nJoin meeting: ${videoConferenceLink}` : ''),\n    startTime: request.startTime,\n    endTime: request.endTime,\n    attendees: request.attendees,\n    videoConferencing: request.useVideoConferencing\n  };\n  \n  // Create the meeting in the calendar\n  const meeting = await calendarProvider.createMeeting(meetingDetails);\n  \n  // Send email invitations\n  await Promise.all(request.attendees.map(attendee => \n    sendMeetingInvitation({\n      to: attendee,\n      meeting,\n      hostName: 'Host Name', // Get from user profile\n      hostEmail: 'host@example.com' // Get from user profile\n    })\n  ));\n  \n  return meeting;\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test meeting creation with different calendar providers\n2. Verify video conferencing link generation\n3. Test email invitation sending\n4. Verify proper error handling for failed meeting creation\n5. Test with various time zones and date formats"
          },
          {
            "id": 8,
            "title": "Implement Notification System for Calendar Events",
            "description": "Create a notification system for calendar events, including booking confirmations, reminders, and rescheduling/cancellation notifications.",
            "dependencies": [
              "9.7"
            ],
            "details": "1. Create notification templates for different event types\n2. Implement email notification service\n3. Add support for SMS notifications (optional)\n4. Create in-app notification system\n5. Implement reminder scheduling based on event times\n6. Add notification preferences for users\n\nExample code:\n```typescript\n// services/notifications/calendarNotifications.ts\nimport { Meeting } from '../calendarService';\nimport { sendEmail } from './emailService';\nimport { sendSms } from './smsService';\nimport { createInAppNotification } from './inAppNotificationService';\n\nexport enum NotificationType {\n  BOOKING_CONFIRMATION = 'booking_confirmation',\n  MEETING_REMINDER = 'meeting_reminder',\n  MEETING_RESCHEDULED = 'meeting_rescheduled',\n  MEETING_CANCELLED = 'meeting_cancelled'\n}\n\nexport interface NotificationPreferences {\n  email: boolean;\n  sms: boolean;\n  inApp: boolean;\n  reminderTimes: number[]; // Minutes before meeting\n}\n\nexport const sendMeetingNotification = async (\n  type: NotificationType,\n  meeting: Meeting,\n  recipients: Array<{\n    email: string;\n    phone?: string;\n    userId?: string;\n    preferences: NotificationPreferences;\n  }>\n): Promise<void> => {\n  const notifications = [];\n  \n  for (const recipient of recipients) {\n    // Send email notification\n    if (recipient.preferences.email) {\n      notifications.push(sendEmail({\n        to: recipient.email,\n        templateId: getEmailTemplateForType(type),\n        data: {\n          meeting,\n          recipientEmail: recipient.email\n        }\n      }));\n    }\n    \n    // Send SMS notification\n    if (recipient.preferences.sms && recipient.phone) {\n      notifications.push(sendSms({\n        to: recipient.phone,\n        templateId: getSmsTemplateForType(type),\n        data: {\n          meeting\n        }\n      }));\n    }\n    \n    // Create in-app notification\n    if (recipient.preferences.inApp && recipient.userId) {\n      notifications.push(createInAppNotification({\n        userId: recipient.userId,\n        type,\n        data: {\n          meeting\n        }\n      }));\n    }\n  }\n  \n  await Promise.all(notifications);\n};\n\nexport const scheduleMeetingReminders = async (\n  meeting: Meeting,\n  recipients: Array<{\n    email: string;\n    phone?: string;\n    userId?: string;\n    preferences: NotificationPreferences;\n  }>\n): Promise<void> => {\n  for (const recipient of recipients) {\n    for (const reminderTime of recipient.preferences.reminderTimes) {\n      const reminderDate = new Date(meeting.startTime);\n      reminderDate.setMinutes(reminderDate.getMinutes() - reminderTime);\n      \n      // Schedule reminder\n      await scheduleNotification({\n        type: NotificationType.MEETING_REMINDER,\n        meeting,\n        recipient,\n        scheduledTime: reminderDate\n      });\n    }\n  }\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test notification sending for different event types\n2. Verify reminder scheduling with various time offsets\n3. Test notification preferences are respected\n4. Verify proper handling of failed notifications\n5. Test notification content for different templates"
          },
          {
            "id": 9,
            "title": "Implement Date/Time Picker Component",
            "description": "Create a reusable date/time picker component for selecting meeting times, with support for time zone selection and duration options.",
            "dependencies": [],
            "details": "1. Create a date picker component with calendar view\n2. Implement time selection with appropriate time increments\n3. Add time zone selector with automatic detection\n4. Create duration selector for common meeting lengths\n5. Implement responsive design for mobile and desktop\n6. Add accessibility features (keyboard navigation, screen reader support)\n\nExample code:\n```typescript\n// components/DateTimePicker.tsx\nimport React, { useState } from 'react';\nimport { format, addMinutes } from 'date-fns';\nimport { Calendar } from './Calendar';\nimport { TimeSelector } from './TimeSelector';\nimport { TimeZoneSelector } from './TimeZoneSelector';\nimport { DurationSelector } from './DurationSelector';\n\ninterface DateTimePickerProps {\n  initialDate?: Date;\n  minDate?: Date;\n  maxDate?: Date;\n  timeZone?: string;\n  availableTimeSlots?: Array<{\n    start: Date;\n    end: Date;\n  }>;\n  onChange: (selection: {\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  }) => void;\n}\n\nexport const DateTimePicker: React.FC<DateTimePickerProps> = ({\n  initialDate = new Date(),\n  minDate,\n  maxDate,\n  timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone,\n  availableTimeSlots = [],\n  onChange\n}) => {\n  const [selectedDate, setSelectedDate] = useState<Date>(initialDate);\n  const [selectedTime, setSelectedTime] = useState<string>(format(initialDate, 'HH:mm'));\n  const [selectedTimeZone, setSelectedTimeZone] = useState<string>(timeZone);\n  const [duration, setDuration] = useState<number>(30); // minutes\n  \n  // Get available time slots for the selected date\n  const availableTimesForDate = availableTimeSlots.filter(slot => {\n    const slotDate = new Date(slot.start);\n    return (\n      slotDate.getFullYear() === selectedDate.getFullYear() &&\n      slotDate.getMonth() === selectedDate.getMonth() &&\n      slotDate.getDate() === selectedDate.getDate()\n    );\n  });\n  \n  // Handle date change\n  const handleDateChange = (date: Date) => {\n    setSelectedDate(date);\n    \n    // If there are available slots for this date, select the first one\n    if (availableTimesForDate.length > 0) {\n      setSelectedTime(format(availableTimesForDate[0].start, 'HH:mm'));\n    }\n  };\n  \n  // Handle time change\n  const handleTimeChange = (time: string) => {\n    setSelectedTime(time);\n    updateSelectedDateTime(selectedDate, time, selectedTimeZone, duration);\n  };\n  \n  // Handle time zone change\n  const handleTimeZoneChange = (tz: string) => {\n    setSelectedTimeZone(tz);\n    updateSelectedDateTime(selectedDate, selectedTime, tz, duration);\n  };\n  \n  // Handle duration change\n  const handleDurationChange = (mins: number) => {\n    setDuration(mins);\n    updateSelectedDateTime(selectedDate, selectedTime, selectedTimeZone, mins);\n  };\n  \n  // Update the selected date/time and call onChange\n  const updateSelectedDateTime = (date: Date, time: string, tz: string, durationMins: number) => {\n    const [hours, minutes] = time.split(':').map(Number);\n    \n    const startTime = new Date(date);\n    startTime.setHours(hours, minutes, 0, 0);\n    \n    const endTime = addMinutes(startTime, durationMins);\n    \n    onChange({\n      startTime,\n      endTime,\n      timeZone: tz\n    });\n  };\n  \n  return (\n    <div className=\"date-time-picker\">\n      <Calendar\n        selectedDate={selectedDate}\n        minDate={minDate}\n        maxDate={maxDate}\n        availableDates={availableTimeSlots.map(slot => new Date(slot.start))}\n        onChange={handleDateChange}\n      />\n      \n      <TimeSelector\n        selectedTime={selectedTime}\n        availableSlots={availableTimesForDate}\n        onChange={handleTimeChange}\n      />\n      \n      <DurationSelector\n        duration={duration}\n        onChange={handleDurationChange}\n        options={[15, 30, 45, 60, 90]}\n      />\n      \n      <TimeZoneSelector\n        selectedTimeZone={selectedTimeZone}\n        onChange={handleTimeZoneChange}\n      />\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test date selection with various date ranges\n2. Verify time selection respects available time slots\n3. Test time zone conversion functionality\n4. Verify duration selection updates end time correctly\n5. Test accessibility with keyboard navigation\n6. Verify component works on different screen sizes"
          },
          {
            "id": 10,
            "title": "Implement Availability Display Component",
            "description": "Create a component to display user availability, showing available and busy time slots with appropriate visual indicators.",
            "dependencies": [
              "9.6",
              "9.9"
            ],
            "details": "1. Create a component to display daily/weekly availability\n2. Implement visual indicators for available and busy times\n3. Add time slot selection functionality\n4. Create responsive grid layout for different time formats\n5. Implement loading states for availability data fetching\n6. Add refresh functionality to update availability\n\nExample code:\n```typescript\n// components/AvailabilityDisplay.tsx\nimport React, { useState, useEffect } from 'react';\nimport { format, addDays, isSameDay } from 'date-fns';\nimport { AvailabilitySlot } from '../services/calendarService';\n\ninterface AvailabilityDisplayProps {\n  userId: string;\n  startDate: Date;\n  numberOfDays: number;\n  onSlotSelect: (slot: {\n    start: Date;\n    end: Date;\n  }) => void;\n  slotDuration: number; // minutes\n  workingHours: {\n    start: string; // Format: \"HH:MM\"\n    end: string; // Format: \"HH:MM\"\n  };\n}\n\nexport const AvailabilityDisplay: React.FC<AvailabilityDisplayProps> = ({\n  userId,\n  startDate,\n  numberOfDays,\n  onSlotSelect,\n  slotDuration,\n  workingHours\n}) => {\n  const [availabilitySlots, setAvailabilitySlots] = useState<AvailabilitySlot[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Calculate end date\n  const endDate = addDays(startDate, numberOfDays);\n  \n  // Fetch availability data\n  const fetchAvailability = async () => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(`/api/availability?userId=${userId}&startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`);\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch availability');\n      }\n      \n      const data = await response.json();\n      setAvailabilitySlots(data.availabilitySlots.map((slot: any) => ({\n        start: new Date(slot.start),\n        end: new Date(slot.end)\n      })));\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  useEffect(() => {\n    fetchAvailability();\n  }, [userId, startDate, numberOfDays]);\n  \n  // Generate time slots for display\n  const generateTimeSlots = () => {\n    const days = [];\n    \n    for (let i = 0; i < numberOfDays; i++) {\n      const currentDate = addDays(startDate, i);\n      const daySlots = [];\n      \n      // Parse working hours\n      const [startHour, startMinute] = workingHours.start.split(':').map(Number);\n      const [endHour, endMinute] = workingHours.end.split(':').map(Number);\n      \n      // Create slots within working hours\n      const slotStartTime = new Date(currentDate);\n      slotStartTime.setHours(startHour, startMinute, 0, 0);\n      \n      const dayEndTime = new Date(currentDate);\n      dayEndTime.setHours(endHour, endMinute, 0, 0);\n      \n      while (slotStartTime < dayEndTime) {\n        const slotEndTime = new Date(slotStartTime);\n        slotEndTime.setMinutes(slotEndTime.getMinutes() + slotDuration);\n        \n        if (slotEndTime > dayEndTime) {\n          break;\n        }\n        \n        // Check if slot is available\n        const isAvailable = availabilitySlots.some(availableSlot => {\n          return (\n            slotStartTime >= availableSlot.start &&\n            slotEndTime <= availableSlot.end\n          );\n        });\n        \n        daySlots.push({\n          start: new Date(slotStartTime),\n          end: new Date(slotEndTime),\n          isAvailable\n        });\n        \n        // Move to next slot\n        slotStartTime.setMinutes(slotStartTime.getMinutes() + slotDuration);\n      }\n      \n      days.push({\n        date: currentDate,\n        slots: daySlots\n      });\n    }\n    \n    return days;\n  };\n  \n  const timeSlots = generateTimeSlots();\n  \n  // Handle slot selection\n  const handleSlotClick = (slot: {\n    start: Date;\n    end: Date;\n    isAvailable: boolean;\n  }) => {\n    if (slot.isAvailable) {\n      onSlotSelect({\n        start: slot.start,\n        end: slot.end\n      });\n    }\n  };\n  \n  if (isLoading) {\n    return <div className=\"loading\">Loading availability...</div>;\n  }\n  \n  if (error) {\n    return (\n      <div className=\"error\">\n        <p>{error}</p>\n        <button onClick={fetchAvailability}>Retry</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"availability-display\">\n      <div className=\"days-container\">\n        {timeSlots.map((day, dayIndex) => (\n          <div key={dayIndex} className=\"day-column\">\n            <div className=\"day-header\">\n              {format(day.date, 'EEE, MMM d')}\n            </div>\n            <div className=\"slots-container\">\n              {day.slots.map((slot, slotIndex) => (\n                <div\n                  key={slotIndex}\n                  className={`time-slot ${slot.isAvailable ? 'available' : 'busy'}`}\n                  onClick={() => handleSlotClick(slot)}\n                >\n                  {format(slot.start, 'h:mm a')}\n                </div>\n              ))}\n            </div>\n          </div>\n        ))}\n      </div>\n      <button className=\"refresh-button\" onClick={fetchAvailability}>\n        Refresh Availability\n      </button>\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test rendering with various availability patterns\n2. Verify slot selection functionality\n3. Test loading and error states\n4. Verify refresh functionality updates the display\n5. Test with different time zones and working hours\n6. Verify responsive layout on different screen sizes"
          },
          {
            "id": 11,
            "title": "Implement Booking Confirmation Component",
            "description": "Create a component for displaying booking confirmation details, including meeting information, calendar links, and options to add to calendar.",
            "dependencies": [
              "9.7"
            ],
            "details": "1. Create a booking confirmation component\n2. Display meeting details (title, time, attendees)\n3. Show video conferencing link\n4. Add calendar links for different providers (Google, Outlook, iCal)\n5. Implement copy-to-clipboard functionality\n6. Add options to reschedule or cancel\n\nExample code:\n```typescript\n// components/BookingConfirmation.tsx\nimport React from 'react';\nimport { format } from 'date-fns';\nimport { Meeting } from '../services/calendarService';\n\ninterface BookingConfirmationProps {\n  meeting: Meeting;\n  onReschedule?: () => void;\n  onCancel?: () => void;\n  showAddToCalendarOptions?: boolean;\n}\n\nexport const BookingConfirmation: React.FC<BookingConfirmationProps> = ({\n  meeting,\n  onReschedule,\n  onCancel,\n  showAddToCalendarOptions = true\n}) => {\n  // Generate calendar links\n  const generateGoogleCalendarLink = () => {\n    const startTime = meeting.startTime.toISOString().replace(/-|:|\\./g, '');\n    const endTime = meeting.endTime.toISOString().replace(/-|:|\\./g, '');\n    \n    return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(meeting.title)}&dates=${startTime}/${endTime}&details=${encodeURIComponent(meeting.description)}`;\n  };\n  \n  const generateOutlookCalendarLink = () => {\n    return `https://outlook.live.com/calendar/0/deeplink/compose?subject=${encodeURIComponent(meeting.title)}&startdt=${meeting.startTime.toISOString()}&enddt=${meeting.endTime.toISOString()}&body=${encodeURIComponent(meeting.description)}`;\n  };\n  \n  const generateICalLink = () => {\n    // In a real implementation, this would generate an .ics file\n    return `/api/calendar/ical?meetingId=${meeting.id}`;\n  };\n  \n  // Copy meeting link to clipboard\n  const copyMeetingLink = () => {\n    navigator.clipboard.writeText(meeting.videoConferenceLink || '');\n  };\n  \n  return (\n    <div className=\"booking-confirmation\">\n      <div className=\"confirmation-header\">\n        <h2>Meeting Confirmed!</h2>\n      </div>\n      \n      <div className=\"meeting-details\">\n        <h3>{meeting.title}</h3>\n        \n        <div className=\"meeting-time\">\n          <div className=\"date\">{format(meeting.startTime, 'EEEE, MMMM d, yyyy')}</div>\n          <div className=\"time\">\n            {format(meeting.startTime, 'h:mm a')} - {format(meeting.endTime, 'h:mm a')}\n          </div>\n        </div>\n        \n        {meeting.videoConferenceLink && (\n          <div className=\"video-link\">\n            <h4>Video Conference Link:</h4>\n            <div className=\"link-container\">\n              <a href={meeting.videoConferenceLink} target=\"_blank\" rel=\"noopener noreferrer\">\n                {meeting.videoConferenceLink}\n              </a>\n              <button className=\"copy-button\" onClick={copyMeetingLink}>\n                Copy\n              </button>\n            </div>\n          </div>\n        )}\n        \n        <div className=\"attendees\">\n          <h4>Attendees:</h4>\n          <ul>\n            {meeting.attendees.map((attendee, index) => (\n              <li key={index}>{attendee}</li>\n            ))}\n          </ul>\n        </div>\n        \n        {meeting.description && (\n          <div className=\"description\">\n            <h4>Description:</h4>\n            <p>{meeting.description}</p>\n          </div>\n        )}\n      </div>\n      \n      {showAddToCalendarOptions && (\n        <div className=\"calendar-options\">\n          <h4>Add to Calendar:</h4>\n          <div className=\"calendar-buttons\">\n            <a\n              href={generateGoogleCalendarLink()}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"calendar-button google\"\n            >\n              Google Calendar\n            </a>\n            <a\n              href={generateOutlookCalendarLink()}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"calendar-button outlook\"\n            >\n              Outlook\n            </a>\n            <a\n              href={generateICalLink()}\n              download=\"meeting.ics\"\n              className=\"calendar-button ical\"\n            >\n              iCal File\n            </a>\n          </div>\n        </div>\n      )}\n      \n      <div className=\"action-buttons\">\n        {onReschedule && (\n          <button className=\"reschedule-button\" onClick={onReschedule}>\n            Reschedule\n          </button>\n        )}\n        {onCancel && (\n          <button className=\"cancel-button\" onClick={onCancel}>\n            Cancel Meeting\n          </button>\n        )}\n      </div>\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test rendering with different meeting details\n2. Verify calendar link generation\n3. Test copy-to-clipboard functionality\n4. Verify reschedule and cancel button actions\n5. Test with and without video conferencing links\n6. Verify responsive layout on different screen sizes"
          },
          {
            "id": 12,
            "title": "Implement Rescheduling Interface",
            "description": "Create an interface for rescheduling existing meetings, including cancellation of the original meeting and creation of a new one.",
            "dependencies": [
              "9.7",
              "9.10",
              "9.11"
            ],
            "details": "1. Create a rescheduling workflow component\n2. Implement meeting lookup by ID\n3. Display current meeting details\n4. Add availability selection for new time\n5. Implement rescheduling confirmation\n6. Create notification system for rescheduled meetings\n\nExample code:\n```typescript\n// components/RescheduleMeeting.tsx\nimport React, { useState, useEffect } from 'react';\nimport { Meeting } from '../services/calendarService';\nimport { DateTimePicker } from './DateTimePicker';\nimport { AvailabilityDisplay } from './AvailabilityDisplay';\nimport { BookingConfirmation } from './BookingConfirmation';\n\nenum RescheduleStep {\n  LOADING,\n  CURRENT_DETAILS,\n  SELECT_NEW_TIME,\n  CONFIRMATION\n}\n\ninterface RescheduleMeetingProps {\n  meetingId: string;\n  userId: string;\n  onComplete: () => void;\n  onCancel: () => void;\n}\n\nexport const RescheduleMeeting: React.FC<RescheduleMeetingProps> = ({\n  meetingId,\n  userId,\n  onComplete,\n  onCancel\n}) => {\n  const [currentStep, setCurrentStep] = useState<RescheduleStep>(RescheduleStep.LOADING);\n  const [currentMeeting, setCurrentMeeting] = useState<Meeting | null>(null);\n  const [newMeeting, setNewMeeting] = useState<Meeting | null>(null);\n  const [selectedTimeSlot, setSelectedTimeSlot] = useState<{\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  } | null>(null);\n  const [availabilitySlots, setAvailabilitySlots] = useState<Array<{\n    start: Date;\n    end: Date;\n  }>>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Fetch current meeting details\n  useEffect(() => {\n    const fetchMeeting = async () => {\n      try {\n        const response = await fetch(`/api/meetings/${meetingId}`);\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch meeting details');\n        }\n        \n        const data = await response.json();\n        setCurrentMeeting({\n          ...data,\n          startTime: new Date(data.startTime),\n          endTime: new Date(data.endTime)\n        });\n        \n        setCurrentStep(RescheduleStep.CURRENT_DETAILS);\n      } catch (err) {\n        setError(err.message);\n      }\n    };\n    \n    fetchMeeting();\n  }, [meetingId]);\n  \n  // Fetch availability for new time selection\n  const fetchAvailability = async (startDate: Date, days: number) => {\n    setIsLoading(true);\n    \n    try {\n      const endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + days);\n      \n      const response = await fetch(`/api/availability?userId=${userId}&startDate=${startDate.toISOString()}&endDate=${endDate.toISOString()}`);\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch availability');\n      }\n      \n      const data = await response.json();\n      setAvailabilitySlots(data.availabilitySlots.map((slot: any) => ({\n        start: new Date(slot.start),\n        end: new Date(slot.end)\n      })));\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Handle time slot selection\n  const handleTimeSlotSelect = (slot: {\n    start: Date;\n    end: Date;\n  }) => {\n    setSelectedTimeSlot({\n      startTime: slot.start,\n      endTime: slot.end,\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    });\n  };\n  \n  // Handle date/time selection from picker\n  const handleDateTimeChange = (selection: {\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  }) => {\n    setSelectedTimeSlot(selection);\n  };\n  \n  // Proceed to new time selection\n  const proceedToTimeSelection = () => {\n    setCurrentStep(RescheduleStep.SELECT_NEW_TIME);\n    \n    // Start with current date for availability\n    const startDate = new Date();\n    fetchAvailability(startDate, 14); // Fetch 2 weeks of availability\n  };\n  \n  // Reschedule the meeting\n  const handleReschedule = async () => {\n    if (!currentMeeting || !selectedTimeSlot) return;\n    \n    setIsLoading(true);\n    \n    try {\n      // Call API to reschedule meeting\n      const response = await fetch(`/api/meetings/${meetingId}/reschedule`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          startTime: selectedTimeSlot.startTime.toISOString(),\n          endTime: selectedTimeSlot.endTime.toISOString(),\n          timeZone: selectedTimeSlot.timeZone\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to reschedule meeting');\n      }\n      \n      const data = await response.json();\n      setNewMeeting({\n        ...data,\n        startTime: new Date(data.startTime),\n        endTime: new Date(data.endTime)\n      });\n      \n      setCurrentStep(RescheduleStep.CONFIRMATION);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Render based on current step\n  const renderContent = () => {\n    switch (currentStep) {\n      case RescheduleStep.LOADING:\n        return <div className=\"loading\">Loading meeting details...</div>;\n        \n      case RescheduleStep.CURRENT_DETAILS:\n        if (!currentMeeting) return null;\n        \n        return (\n          <div className=\"current-meeting\">\n            <h2>Current Meeting Details</h2>\n            <BookingConfirmation\n              meeting={currentMeeting}\n              showAddToCalendarOptions={false}\n            />\n            <div className=\"action-buttons\">\n              <button\n                className=\"primary-button\"\n                onClick={proceedToTimeSelection}\n              >\n                Select New Time\n              </button>\n              <button\n                className=\"secondary-button\"\n                onClick={onCancel}\n              >\n                Cancel\n              </button>\n            </div>\n          </div>\n        );\n        \n      case RescheduleStep.SELECT_NEW_TIME:\n        return (\n          <div className=\"select-new-time\">\n            <h2>Select New Meeting Time</h2>\n            <div className=\"time-selection-container\">\n              <div className=\"availability-section\">\n                <h3>Available Time Slots</h3>\n                <AvailabilityDisplay\n                  userId={userId}\n                  startDate={new Date()}\n                  numberOfDays={7}\n                  onSlotSelect={handleTimeSlotSelect}\n                  slotDuration={30}\n                  workingHours={{ start: '09:00', end: '17:00' }}\n                />\n              </div>\n              <div className=\"date-time-picker-section\">\n                <h3>Custom Date/Time</h3>\n                <DateTimePicker\n                  initialDate={new Date()}\n                  minDate={new Date()}\n                  availableTimeSlots={availabilitySlots}\n                  onChange={handleDateTimeChange}\n                />\n              </div>\n            </div>\n            \n            <div className=\"selected-time\">\n              {selectedTimeSlot && (\n                <div>\n                  <h3>Selected Time:</h3>\n                  <p>\n                    {selectedTimeSlot.startTime.toLocaleString()} - {selectedTimeSlot.endTime.toLocaleString()}\n                  </p>\n                </div>\n              )}\n            </div>\n            \n            <div className=\"action-buttons\">\n              <button\n                className=\"primary-button\"\n                onClick={handleReschedule}\n                disabled={!selectedTimeSlot || isLoading}\n              >\n                {isLoading ? 'Rescheduling...' : 'Confirm Reschedule'}\n              </button>\n              <button\n                className=\"secondary-button\"\n                onClick={() => setCurrentStep(RescheduleStep.CURRENT_DETAILS)}\n                disabled={isLoading}\n              >\n                Back\n              </button>\n            </div>\n          </div>\n        );\n        \n      case RescheduleStep.CONFIRMATION:\n        if (!newMeeting) return null;\n        \n        return (\n          <div className=\"reschedule-confirmation\">\n            <h2>Meeting Rescheduled</h2>\n            <p>Your meeting has been successfully rescheduled.</p>\n            <BookingConfirmation meeting={newMeeting} />\n            <button\n              className=\"primary-button\"\n              onClick={onComplete}\n            >\n              Done\n            </button>\n          </div>\n        );\n    }\n  };\n  \n  if (error) {\n    return (\n      <div className=\"error-container\">\n        <h2>Error</h2>\n        <p>{error}</p>\n        <button onClick={onCancel}>Back</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"reschedule-meeting-container\">\n      {renderContent()}\n    </div>\n  );\n};\n```",
            "status": "pending",
            "testStrategy": "1. Test the complete rescheduling workflow\n2. Verify meeting details are correctly displayed\n3. Test availability fetching and display\n4. Verify time slot selection functionality\n5. Test rescheduling API integration\n6. Verify confirmation display with new meeting details"
          },
          {
            "id": 13,
            "title": "Integrate Calendar System with User Interface",
            "description": "Integrate all calendar components into a cohesive user interface, including scheduling pages, availability settings, and meeting management.",
            "dependencies": [
              "9.5",
              "9.9",
              "9.10",
              "9.11",
              "9.12"
            ],
            "details": "1. Create main scheduling page layout\n2. Implement user calendar settings page\n3. Create meeting management interface\n4. Add navigation between calendar components\n5. Implement responsive design for all screens\n6. Add loading states and error handling\n\nExample code:\n```typescript\n// pages/schedule/index.tsx\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/router';\nimport { DateTimePicker } from '../../components/DateTimePicker';\nimport { AvailabilityDisplay } from '../../components/AvailabilityDisplay';\nimport { BookingConfirmation } from '../../components/BookingConfirmation';\nimport { RescheduleMeeting } from '../../components/RescheduleMeeting';\nimport { getUserCalendarProviders } from '../../services/calendarService';\n\nenum ScheduleStep {\n  SELECT_DATE,\n  ENTER_DETAILS,\n  CONFIRMATION\n}\n\nconst SchedulePage: React.FC = () => {\n  const router = useRouter();\n  const { userId, rescheduleId } = router.query;\n  \n  const [currentStep, setCurrentStep] = useState<ScheduleStep>(ScheduleStep.SELECT_DATE);\n  const [selectedTimeSlot, setSelectedTimeSlot] = useState<{\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  } | null>(null);\n  const [meetingDetails, setMeetingDetails] = useState<{\n    title: string;\n    name: string;\n    email: string;\n    notes: string;\n  }>({ title: '', name: '', email: '', notes: '' });\n  const [createdMeeting, setCreatedMeeting] = useState<any>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [connectedCalendars, setConnectedCalendars] = useState<Array<{\n    type: 'google' | 'outlook';\n    email: string;\n  }>>([]);\n  \n  // Check if this is a reschedule\n  useEffect(() => {\n    if (rescheduleId) {\n      // Handle reschedule flow\n    }\n  }, [rescheduleId]);\n  \n  // Fetch connected calendars\n  useEffect(() => {\n    if (!userId) return;\n    \n    const fetchCalendars = async () => {\n      try {\n        const response = await fetch(`/api/users/${userId}/calendars`);\n        \n        if (!response.ok) {\n          throw new Error('Failed to fetch connected calendars');\n        }\n        \n        const data = await response.json();\n        setConnectedCalendars(data.calendars);\n      } catch (err) {\n        setError('Failed to load calendar connections');\n      }\n    };\n    \n    fetchCalendars();\n  }, [userId]);\n  \n  // Handle time slot selection\n  const handleTimeSlotSelect = (slot: {\n    start: Date;\n    end: Date;\n  }) => {\n    setSelectedTimeSlot({\n      startTime: slot.start,\n      endTime: slot.end,\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    });\n    setCurrentStep(ScheduleStep.ENTER_DETAILS);\n  };\n  \n  // Handle date/time selection from picker\n  const handleDateTimeChange = (selection: {\n    startTime: Date;\n    endTime: Date;\n    timeZone: string;\n  }) => {\n    setSelectedTimeSlot(selection);\n    setCurrentStep(ScheduleStep.ENTER_DETAILS);\n  };\n  \n  // Handle meeting details form submission\n  const handleDetailsSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!selectedTimeSlot || !userId) return;\n    \n    setIsLoading(true);\n    \n    try {\n      const response = await fetch('/api/meetings', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          hostUserId: userId,\n          title: meetingDetails.title,\n          startTime: selectedTimeSlot.startTime.toISOString(),\n          endTime: selectedTimeSlot.endTime.toISOString(),\n          timeZone: selectedTimeSlot.timeZone,\n          attendees: [meetingDetails.email],\n          notes: meetingDetails.notes,\n          guestName: meetingDetails.name\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to create meeting');\n      }\n      \n      const data = await response.json();\n      setCreatedMeeting({\n        ...data,\n        startTime: new Date(data.startTime),\n        endTime: new Date(data.endTime)\n      });\n      \n      setCurrentStep(ScheduleStep.CONFIRMATION);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Handle input changes\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    const { name, value } = e.target;\n    setMeetingDetails(prev => ({ ...prev, [name]: value }));\n  };\n  \n  // Render based on current step\n  const renderContent = () => {\n    switch (currentStep) {\n      case ScheduleStep.SELECT_DATE:\n        return (\n          <div className=\"select-date-container\">\n            <h1>Schedule a Meeting</h1>\n            \n            {connectedCalendars.length === 0 ? (\n              <div className=\"no-calendars\">\n                <p>No calendars connected. Please connect a calendar to continue.</p>\n                <button onClick={() => router.push(`/settings/calendars?userId=${userId}`)}>\n                  Connect Calendar\n                </button>\n              </div>\n            ) : (\n              <>\n                <div className=\"availability-section\">\n                  <h2>Select a Time Slot</h2>\n                  <AvailabilityDisplay\n                    userId={userId as string}\n                    startDate={new Date()}\n                    numberOfDays={7}\n                    onSlotSelect={handleTimeSlotSelect}\n                    slotDuration={30}\n                    workingHours={{ start: '09:00', end: '17:00' }}\n                  />\n                </div>\n                \n                <div className=\"date-time-picker-section\">\n                  <h2>Or Choose a Custom Time</h2>\n                  <DateTimePicker\n                    initialDate={new Date()}\n                    minDate={new Date()}\n                    onChange={handleDateTimeChange}\n                  />\n                </div>\n              </>\n            )}\n          </div>\n        );\n        \n      case ScheduleStep.ENTER_DETAILS:\n        if (!selectedTimeSlot) return null;\n        \n        return (\n          <div className=\"enter-details-container\">\n            <h1>Meeting Details</h1>\n            \n            <div className=\"selected-time-info\">\n              <h3>Selected Time:</h3>\n              <p>\n                {selectedTimeSlot.startTime.toLocaleString(undefined, {\n                  weekday: 'long',\n                  year: 'numeric',\n                  month: 'long',\n                  day: 'numeric',\n                  hour: 'numeric',\n                  minute: '2-digit'\n                })}\n                {' - '}\n                {selectedTimeSlot.endTime.toLocaleString(undefined, {\n                  hour: 'numeric',\n                  minute: '2-digit'\n                })}\n              </p>\n            </div>\n            \n            <form onSubmit={handleDetailsSubmit} className=\"meeting-details-form\">\n              <div className=\"form-group\">\n                <label htmlFor=\"title\">Meeting Title</label>\n                <input\n                  type=\"text\"\n                  id=\"title\"\n                  name=\"title\"\n                  value={meetingDetails.title}\n                  onChange={handleInputChange}\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"name\">Your Name</label>\n                <input\n                  type=\"text\"\n                  id=\"name\"\n                  name=\"name\"\n                  value={meetingDetails.name}\n                  onChange={handleInputChange}\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"email\">Your Email</label>\n                <input\n                  type=\"email\"\n                  id=\"email\"\n                  name=\"email\"\n                  value={meetingDetails.email}\n                  onChange={handleInputChange}\n                  required\n                />\n              </div>\n              \n              <div className=\"form-group\">\n                <label htmlFor=\"notes\">Additional Notes</label>\n                <textarea\n                  id=\"notes\"\n                  name=\"notes\"\n                  value={meetingDetails.notes}\n                  onChange={handleInputChange}\n                  rows={4}\n                />\n              </div>\n              \n              <div className=\"form-actions\">\n                <button\n                  type=\"button\"\n                  className=\"back-button\"\n                  onClick={() => setCurrentStep(ScheduleStep.SELECT_DATE)}\n                >\n                  Back\n                </button>\n                <button\n                  type=\"submit\"\n                  className=\"schedule-button\"\n                  disabled={isLoading}\n                >\n                  {isLoading ? 'Scheduling...' : 'Schedule Meeting'}\n                </button>\n              </div>\n            </form>\n          </div>\n        );\n        \n      case ScheduleStep.CONFIRMATION:\n        if (!createdMeeting) return null;\n        \n        return (\n          <div className=\"confirmation-container\">\n            <BookingConfirmation meeting={createdMeeting} />\n          </div>\n        );\n    }\n  };\n  \n  // Handle reschedule mode\n  if (rescheduleId) {\n    return (\n      <div className=\"schedule-page reschedule-mode\">\n        <RescheduleMeeting\n          meetingId={rescheduleId as string}\n          userId={userId as string}\n          onComplete={() => router.push('/meetings')}\n          onCancel={() => router.push('/meetings')}\n        />\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div className=\"error-container\">\n        <h2>Error</h2>\n        <p>{error}</p>\n        <button onClick={() => setError(null)}>Try Again</button>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"schedule-page\">\n      {renderContent()}\n    </div>\n  );\n};\n\nexport default SchedulePage;\n```",
            "status": "pending",
            "testStrategy": "1. Test the complete scheduling workflow\n2. Verify calendar connection handling\n3. Test availability display and time slot selection\n4. Verify meeting details form submission\n5. Test confirmation display\n6. Verify rescheduling integration\n7. Test responsive layout on different screen sizes"
          }
        ]
      },
      {
        "id": 10,
        "title": "Prospect Booking Experience",
        "description": "Create the prospect-facing booking experience with magic links, advocate profiles, and one-click scheduling.",
        "details": "1. Implement magic link generation and validation:\n```typescript\n// services/bookingLinkService.ts\nexport const generateMagicLink = async (opportunityId: string, advocateId: string) => {\n  // Generate unique token\n  const token = generateUniqueToken()\n  \n  // Store token with expiration\n  await storeMagicLinkToken(token, { opportunityId, advocateId })\n  \n  // Generate full URL\n  return `${process.env.NEXT_PUBLIC_APP_URL}/booking/${token}`\n}\n\nexport const validateMagicLink = async (token: string) => {\n  // Retrieve and validate token\n  const linkData = await getMagicLinkData(token)\n  \n  if (!linkData || isExpired(linkData.expiresAt)) {\n    throw new Error('Invalid or expired booking link')\n  }\n  \n  return linkData\n}\n```\n2. Create public-facing booking pages:\n   - Advocate profile display\n   - Availability calendar\n   - Booking confirmation\n3. Implement prospect data collection:\n   - Basic contact information\n   - Meeting preferences\n4. Build the booking confirmation flow:\n   - Email confirmation\n   - Calendar invitation\n   - Preparation materials\n5. Create meeting reminder system\n6. Implement analytics tracking for booking conversion",
        "testStrategy": "Test magic link generation and validation with various scenarios. Verify the booking flow from prospect perspective. Test email deliverability for confirmations. Ensure calendar invitations are correctly formatted. Test with different browsers and devices to verify responsive design.",
        "priority": "high",
        "dependencies": [
          6,
          9
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Magic Link Generation and Validation",
            "description": "Create the service for generating secure magic links for prospects and validating them when accessed.",
            "dependencies": [],
            "details": "1. Implement the `generateUniqueToken()` function\n2. Create the `storeMagicLinkToken()` function to store tokens in the database\n3. Build the `getMagicLinkData()` function to retrieve token data\n4. Implement the `isExpired()` utility to check token validity\n5. Complete the `generateMagicLink()` and `validateMagicLink()` functions\n6. Add unit tests for all functions",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop Advocate Profile Display Page",
            "description": "Create the public-facing page that displays the advocate's profile information when a prospect accesses the booking link.",
            "dependencies": [
              "10.1"
            ],
            "details": "1. Create the `/booking/[token]` route in Next.js\n2. Implement token validation on page load\n3. Design and build the advocate profile component\n4. Display advocate information (name, title, company, bio)\n5. Add advocate photo/avatar display\n6. Implement responsive design for mobile and desktop views",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build Availability Calendar Component",
            "description": "Create the interactive calendar component that displays advocate availability and allows prospects to select meeting times.",
            "dependencies": [
              "10.1",
              "10.2"
            ],
            "details": "1. Create a calendar UI component that shows available time slots\n2. Implement time zone detection and conversion\n3. Add time slot selection functionality\n4. Connect to the backend to fetch real-time availability data\n5. Handle edge cases like no available slots\n6. Add loading states and error handling",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Prospect Data Collection Form",
            "description": "Create the form for collecting prospect information needed for the booking process.",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "1. Design and implement the prospect information form\n2. Add form validation for required fields\n3. Create form submission handler\n4. Implement error handling and feedback\n5. Store prospect data securely in the database\n6. Add privacy policy consent checkbox",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Develop Booking Confirmation Flow",
            "description": "Create the confirmation process after a prospect books a meeting, including email notifications and calendar invitations.",
            "dependencies": [
              "10.3",
              "10.4"
            ],
            "details": "1. Create booking confirmation page with meeting details\n2. Implement email confirmation sending functionality\n3. Generate and send calendar invitations (ICS files)\n4. Create templates for confirmation emails\n5. Add preparation materials delivery\n6. Implement booking status tracking in the database",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Build Analytics Tracking for Booking Conversion",
            "description": "Implement analytics to track the booking funnel and conversion rates from magic link access to completed bookings.",
            "dependencies": [
              "10.1",
              "10.5"
            ],
            "details": "1. Add tracking for magic link opens\n2. Implement tracking for each step of the booking process\n3. Create conversion rate calculations\n4. Build dashboard components to display booking metrics\n5. Implement export functionality for booking analytics\n6. Add real-time tracking for active booking sessions",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Reference Call Management System",
        "description": "Implement the reference call management system for tracking, recording, and analyzing customer reference calls.",
        "details": "1. Create reference call data models and interfaces:\n   - Call list view with filtering and search\n   - Call details view\n   - Call scheduling and management\n2. Implement call recording integration:\n   - Zoom API integration\n   - Microsoft Teams integration\n   - Recording storage and access control\n3. Build pre-call preparation workflow:\n   - Context sharing for advocates\n   - Talking points generation\n   - Prospect information sharing\n4. Create post-call feedback collection:\n```typescript\n// components/PostCallFeedback.tsx\nconst PostCallFeedback = ({ callId }: { callId: string }) => {\n  const [feedback, setFeedback] = useState({\n    effectiveness: 0,\n    topics: [],\n    notes: '',\n  })\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault()\n    await submitCallFeedback(callId, feedback)\n    // Show success message\n  }\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Feedback form fields */}\n    </form>\n  )\n}\n```\n5. Implement call status tracking and reporting\n6. Create notification system for call events",
        "testStrategy": "Test call creation and management workflows. Verify recording integration with mock API responses. Test feedback collection and storage. Ensure proper access controls for call recordings. Verify notification delivery for call events.",
        "priority": "medium",
        "dependencies": [
          6,
          9,
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create reference call data models and interfaces",
            "description": "Define the data models and TypeScript interfaces for reference calls, including all necessary properties for tracking, scheduling, and managing calls.",
            "dependencies": [],
            "details": "Create a new file `types/referenceCall.ts` with interfaces for ReferenceCall, CallParticipant, CallStatus, and related types. Include properties for call ID, title, description, scheduled date/time, duration, status, participants (advocates, prospects), recording URLs, and associated metadata. Ensure models support the requirements for filtering, searching, and reporting.",
            "status": "done",
            "testStrategy": "Create unit tests to validate type definitions and ensure they meet all requirements for the call management system."
          },
          {
            "id": 2,
            "title": "Implement reference call API services",
            "description": "Create service functions for CRUD operations on reference calls, including creating, retrieving, updating, and deleting calls.",
            "dependencies": [
              "11.1"
            ],
            "details": "Create `services/referenceCallService.ts` with functions for createCall, getCall, updateCall, deleteCall, listCalls, and searchCalls. Implement proper error handling and response typing. Ensure the service functions handle pagination for list operations and support filtering by various call properties.",
            "status": "done",
            "testStrategy": "Write unit tests with mock API responses to verify each service function correctly handles success and error cases."
          },
          {
            "id": 3,
            "title": "Build call list view component with filtering and search",
            "description": "Create a component to display a list of reference calls with filtering, sorting, and search capabilities.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `components/calls/CallListView.tsx` that displays reference calls in a table or card format. Implement filters for call status, date range, advocate, and other relevant properties. Add search functionality that filters across call titles, descriptions, and participant information. Include pagination for large result sets and sorting options for columns.",
            "status": "done",
            "testStrategy": "Test component rendering with various data sets. Verify filter and search functionality works correctly. Test pagination and sorting behavior."
          },
          {
            "id": 4,
            "title": "Implement call details view component",
            "description": "Create a component to display detailed information about a specific reference call, including participants, status, and related actions.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `components/calls/CallDetailsView.tsx` that shows comprehensive information about a call, including scheduling details, participants, status, and any recordings. Include action buttons for editing, canceling, or rescheduling calls. Display call preparation materials and post-call feedback if available.",
            "status": "done",
            "testStrategy": "Test component rendering with various call states (scheduled, completed, canceled). Verify all actions function correctly and appropriate information is displayed based on call status."
          },
          {
            "id": 5,
            "title": "Develop call scheduling and management interface",
            "description": "Create the interface for scheduling new calls and managing existing ones, including date/time selection and participant assignment.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "Create `components/calls/CallSchedulingForm.tsx` with form fields for call title, description, date/time selection, duration, and participant selection. Integrate with the calendar system (Task 9) to show available time slots. Include functionality to send invitations to participants and update calendar events when call details change.",
            "status": "done",
            "testStrategy": "Test form validation and submission. Verify integration with calendar system works correctly. Test participant selection and invitation process."
          },
          {
            "id": 6,
            "title": "Implement Zoom API integration for call recording",
            "description": "Integrate with Zoom API to create meetings, generate join links, and capture recordings for reference calls.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `services/integrations/zoomService.ts` with functions to create Zoom meetings, generate participant links, start/stop recordings, and retrieve recording URLs. Implement OAuth flow for Zoom authentication if needed. Ensure proper error handling for API failures.",
            "status": "done",
            "testStrategy": "Test Zoom API integration with mock responses. Verify meeting creation, link generation, and recording retrieval work correctly. Test error handling for various failure scenarios."
          },
          {
            "id": 7,
            "title": "Implement Microsoft Teams integration for call recording",
            "description": "Integrate with Microsoft Teams API to create meetings, generate join links, and capture recordings for reference calls.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `services/integrations/teamsService.ts` with functions to create Teams meetings, generate participant links, manage recordings, and retrieve recording URLs. Implement Microsoft Graph API authentication. Handle Teams-specific meeting properties and recording formats.",
            "status": "done",
            "testStrategy": "Test Teams API integration with mock responses. Verify meeting creation, link generation, and recording retrieval work correctly. Test authentication flow and error handling."
          },
          {
            "id": 8,
            "title": "Develop recording storage and access control system",
            "description": "Implement secure storage for call recordings with appropriate access controls and retention policies.",
            "dependencies": [
              "11.6",
              "11.7"
            ],
            "details": "Create `services/recordingService.ts` to handle storage of recording metadata and secure access to recording files. Implement access control based on user roles and permissions. Set up secure URLs with expiration for accessing recordings. Define retention policies for recordings based on company settings.",
            "status": "done",
            "testStrategy": "Test recording storage and retrieval with various file types. Verify access controls prevent unauthorized access. Test URL generation and expiration functionality."
          },
          {
            "id": 9,
            "title": "Build pre-call preparation workflow for advocates",
            "description": "Create the workflow for advocates to prepare for reference calls, including context sharing and talking points.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.4"
            ],
            "details": "Create `components/calls/PreCallPreparation.tsx` with sections for call context, prospect information, and talking points. Implement functionality for advocates to review and add preparation materials. Include a checklist of preparation tasks and status tracking.",
            "status": "done",
            "testStrategy": "Test preparation workflow with various call scenarios. Verify information is correctly displayed and saved. Test checklist functionality and status updates."
          },
          {
            "id": 10,
            "title": "Implement talking points generation system",
            "description": "Create a system for generating and managing talking points for reference calls based on advocate experience and prospect interests.",
            "dependencies": [
              "11.9"
            ],
            "details": "Create `services/talkingPointsService.ts` to generate suggested talking points based on advocate profile, prospect information, and historical call data. Implement functionality for manual addition, editing, and organization of talking points. Include categorization and prioritization of talking points.",
            "status": "done",
            "testStrategy": "Test talking points generation with various advocate and prospect profiles. Verify manual editing and organization functions work correctly."
          },
          {
            "id": 11,
            "title": "Develop prospect information sharing component",
            "description": "Create a component for sharing relevant prospect information with advocates before calls.",
            "dependencies": [
              "11.9"
            ],
            "details": "Create `components/calls/ProspectInformation.tsx` to display key information about prospects, including company details, use case interests, and specific questions or concerns. Implement controls for what information is shared with advocates based on privacy settings.",
            "status": "done",
            "testStrategy": "Test component with various prospect profiles. Verify privacy controls work correctly. Test information display and formatting."
          },
          {
            "id": 12,
            "title": "Complete post-call feedback collection component",
            "description": "Finish implementing the post-call feedback collection component for gathering insights after calls.",
            "dependencies": [
              "11.1",
              "11.2",
              "11.4"
            ],
            "details": "Complete the `components/PostCallFeedback.tsx` component started in the task description. Add form fields for effectiveness rating, topics discussed, and notes. Implement validation and submission logic. Add success/error messaging and state management.",
            "status": "done",
            "testStrategy": "Test form validation and submission. Verify feedback is correctly stored and associated with the call. Test error handling and success messaging."
          },
          {
            "id": 13,
            "title": "Implement call status tracking system",
            "description": "Create a system for tracking and updating the status of reference calls throughout their lifecycle.",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Create `services/callStatusService.ts` with functions to update and track call status (scheduled, in-progress, completed, canceled, etc.). Implement automatic status updates based on time and manual updates based on user actions. Include status history tracking for audit purposes.",
            "status": "done",
            "testStrategy": "Test status transitions with various scenarios. Verify automatic and manual status updates work correctly. Test status history tracking and reporting."
          },
          {
            "id": 14,
            "title": "Build call reporting and analytics dashboard",
            "description": "Create a dashboard for reporting and analyzing reference call data, including metrics and trends.",
            "dependencies": [
              "11.13",
              "11.12"
            ],
            "details": "Create `components/calls/CallAnalyticsDashboard.tsx` with visualizations for call volume, effectiveness ratings, common topics, and other relevant metrics. Implement filters for date ranges, advocates, and call types. Include export functionality for reports.",
            "status": "done",
            "testStrategy": "Test dashboard rendering with various data sets. Verify filters and calculations work correctly. Test export functionality and data formatting."
          },
          {
            "id": 15,
            "title": "Implement notification system for call events",
            "description": "Create a notification system for call-related events such as scheduling, reminders, and status changes.",
            "dependencies": [
              "11.13"
            ],
            "details": "Create `services/callNotificationService.ts` to generate and send notifications for call events. Implement different notification types (email, in-app, calendar) based on event type and user preferences. Set up scheduling for reminder notifications before calls.",
            "status": "done",
            "testStrategy": "Test notification generation and delivery for various event types. Verify reminders are sent at the correct times. Test user preference handling for notification types."
          },
          {
            "id": 16,
            "title": "Integrate call system with calendar services",
            "description": "Integrate the reference call system with the calendar integration from Task 9 for scheduling and availability management.",
            "dependencies": [
              "11.5",
              "11.15"
            ],
            "details": "Modify the call scheduling components and services to use the calendar integration from Task 9. Implement availability checking before scheduling calls. Ensure calendar events are created, updated, and deleted in sync with call management actions.",
            "status": "done",
            "testStrategy": "Test integration with calendar services for scheduling, rescheduling, and cancellation. Verify availability checking prevents scheduling conflicts."
          }
        ]
      },
      {
        "id": 12,
        "title": "Call Intelligence Engine",
        "description": "Develop the AI-powered call intelligence engine that analyzes reference call recordings and extracts key insights.",
        "details": "1. Implement call recording processing pipeline:\n   - Audio extraction from video recordings\n   - Transcription service integration\n   - Text preprocessing for analysis\n2. Create OpenAI integration for analysis:\n```typescript\n// services/callIntelligenceService.ts\nexport const analyzeCallTranscript = async (callId: string, transcript: string) => {\n  // Prepare analysis prompt\n  const prompt = generateAnalysisPrompt(transcript)\n  \n  // Call OpenAI for analysis\n  const { data } = await openai.createCompletion({\n    model: \"gpt-4\",\n    prompt,\n    // Other parameters\n  })\n  \n  // Process and structure the insights\n  const insights = processAnalysisResponse(data)\n  \n  // Store insights in database\n  await storeCallInsights(callId, insights)\n  \n  return insights\n}\n\nfunction processAnalysisResponse(response) {\n  return {\n    competitive_intel: extractCompetitiveIntel(response),\n    objections: extractObjections(response),\n    success_factors: extractSuccessFactors(response),\n    prospect_sentiment: extractSentiment(response),\n    next_steps: extractNextSteps(response)\n  }\n}\n```\n3. Implement insight extraction for key categories:\n   - Competitive mentions\n   - Objections raised\n   - Success factors highlighted\n   - Next steps identified\n4. Create CRM integration for insight sharing\n5. Build insights visualization dashboard\n6. Implement trend analysis across multiple calls",
        "testStrategy": "Test transcription accuracy with sample recordings. Verify insight extraction with various conversation scenarios. Test CRM integration for insight sharing. Measure analysis quality with human-validated results. Verify trend analysis with historical data.",
        "priority": "medium",
        "dependencies": [
          7,
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Audio Extraction from Video Recordings",
            "description": "Create a service to extract audio from video call recordings for further processing",
            "dependencies": [],
            "details": "Create a utility service that uses ffmpeg or a similar library to extract audio tracks from video recordings. The service should accept video file paths or URLs and output audio files in a format suitable for transcription (e.g., MP3 or WAV). Include error handling for corrupted files and logging for processing status.",
            "status": "pending",
            "testStrategy": "Test with various video formats (MP4, WebM, etc.) and verify audio extraction quality. Ensure proper error handling for corrupted files."
          },
          {
            "id": 2,
            "title": "Integrate Transcription Service",
            "description": "Implement integration with a speech-to-text service to transcribe call recordings",
            "dependencies": [
              "12.1"
            ],
            "details": "Integrate with a transcription service (e.g., AWS Transcribe, Google Speech-to-Text) to convert audio to text. Create a service that accepts audio files, sends them to the transcription API, and retrieves the text results. Include speaker diarization if supported by the chosen service to distinguish between different speakers in the conversation.",
            "status": "pending",
            "testStrategy": "Test with sample audio files of varying quality and accents. Verify transcription accuracy and proper speaker identification."
          },
          {
            "id": 3,
            "title": "Implement Text Preprocessing Pipeline",
            "description": "Create a preprocessing pipeline to clean and structure transcription text for analysis",
            "dependencies": [
              "12.2"
            ],
            "details": "Develop a text preprocessing service that cleans and structures the raw transcription text. This should include removing filler words, normalizing text, segmenting by speaker, and formatting the text for optimal analysis by the AI model. The output should be structured in a way that preserves conversation flow and speaker identification.",
            "status": "pending",
            "testStrategy": "Test with various transcription outputs to ensure proper cleaning and structuring. Verify that important context is preserved."
          },
          {
            "id": 4,
            "title": "Create Analysis Prompt Generator",
            "description": "Implement a function to generate effective prompts for OpenAI based on call transcripts",
            "dependencies": [
              "12.3"
            ],
            "details": "Implement the `generateAnalysisPrompt` function that creates structured prompts for OpenAI. The prompt should guide the model to extract specific insights like competitive intelligence, objections, success factors, sentiment, and next steps. Include clear instructions and examples in the prompt to improve analysis quality.",
            "status": "pending",
            "testStrategy": "Test with different transcript samples to ensure prompts effectively guide the AI to extract relevant insights."
          },
          {
            "id": 5,
            "title": "Implement OpenAI Integration Service",
            "description": "Create a service to handle communication with OpenAI API for transcript analysis",
            "dependencies": [
              "12.4"
            ],
            "details": "Implement the core OpenAI integration service that sends prompts to the API and receives responses. This should include proper error handling, retry logic, and response validation. Configure appropriate model parameters (temperature, max tokens, etc.) for optimal analysis results.",
            "status": "pending",
            "testStrategy": "Test API integration with various transcript lengths. Verify error handling and retry logic. Measure response times and optimize as needed."
          },
          {
            "id": 6,
            "title": "Develop Competitive Intelligence Extraction",
            "description": "Create a function to extract competitive intelligence mentions from AI responses",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractCompetitiveIntel` function to parse OpenAI responses and identify mentions of competitors, competitive features, and market positioning. The function should structure this information in a consistent format for storage and display.",
            "status": "pending",
            "testStrategy": "Test with responses containing various competitor mentions. Verify accurate extraction and proper formatting of competitive intelligence."
          },
          {
            "id": 7,
            "title": "Implement Objections Extraction",
            "description": "Create a function to identify and categorize objections raised during calls",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractObjections` function to identify customer objections, concerns, and hesitations from the AI analysis. The function should categorize objections (e.g., price, features, implementation) and include context around how they were addressed.",
            "status": "pending",
            "testStrategy": "Test with transcripts containing various types of objections. Verify proper categorization and context preservation."
          },
          {
            "id": 8,
            "title": "Develop Success Factors Extraction",
            "description": "Create a function to identify key success factors and positive signals from calls",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractSuccessFactors` function to identify positive signals, features that resonated with prospects, and other success indicators from the AI analysis. The function should structure these insights for easy consumption by sales teams.",
            "status": "pending",
            "testStrategy": "Test with transcripts containing various positive signals. Verify accurate identification of success factors."
          },
          {
            "id": 9,
            "title": "Implement Sentiment Analysis Extraction",
            "description": "Create a function to extract and quantify prospect sentiment from AI responses",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractSentiment` function to analyze the overall sentiment of the prospect throughout the call. This should include sentiment trends (how sentiment changed during the call) and key moments that influenced sentiment shifts.",
            "status": "pending",
            "testStrategy": "Test with transcripts showing various sentiment patterns. Verify accurate sentiment assessment and identification of sentiment shifts."
          },
          {
            "id": 10,
            "title": "Develop Next Steps Extraction",
            "description": "Create a function to identify and structure next steps mentioned in calls",
            "dependencies": [
              "12.5"
            ],
            "details": "Implement the `extractNextSteps` function to identify action items, follow-ups, and commitments made during the call. The function should structure these as actionable items with relevant context and potential due dates if mentioned.",
            "status": "pending",
            "testStrategy": "Test with transcripts containing various types of next steps and commitments. Verify accurate extraction and proper formatting."
          },
          {
            "id": 11,
            "title": "Implement Database Storage for Call Insights",
            "description": "Create a service to store and retrieve call analysis insights in the database",
            "dependencies": [
              "12.6",
              "12.7",
              "12.8",
              "12.9",
              "12.10"
            ],
            "details": "Implement the `storeCallInsights` function to save structured insights to the database. Design appropriate database schema to store different types of insights with relationships to calls, opportunities, and advocates. Include indexing for efficient querying of insights.",
            "status": "pending",
            "testStrategy": "Test storage and retrieval of various insight types. Verify proper relationships and query performance."
          },
          {
            "id": 12,
            "title": "Create CRM Integration for Insight Sharing",
            "description": "Implement integration with CRM systems to share call insights with sales teams",
            "dependencies": [
              "12.11"
            ],
            "details": "Develop a service to push relevant call insights to CRM systems (e.g., Salesforce, HubSpot). This should include mapping insights to appropriate CRM fields, creating activities or notes, and ensuring proper attribution. Implement authentication and API integration with major CRM providers.",
            "status": "pending",
            "testStrategy": "Test integration with different CRM systems. Verify proper data mapping and synchronization. Test error handling for API failures."
          },
          {
            "id": 13,
            "title": "Build Insights Visualization Dashboard",
            "description": "Create a dashboard to visualize call insights in an actionable format",
            "dependencies": [
              "12.11"
            ],
            "details": "Develop a frontend dashboard to display call insights in a visual, actionable format. Include charts for sentiment analysis, tables for competitive mentions and objections, and summaries of key insights. Implement filtering and sorting capabilities to help users find relevant insights.",
            "status": "pending",
            "testStrategy": "Test dashboard with various insight datasets. Verify proper visualization and interactive features. Test responsiveness on different devices."
          },
          {
            "id": 14,
            "title": "Implement Multi-Call Trend Analysis",
            "description": "Create functionality to analyze trends across multiple calls for the same opportunity or advocate",
            "dependencies": [
              "12.11"
            ],
            "details": "Develop a service to analyze trends across multiple calls, identifying patterns in objections, competitive mentions, and sentiment over time. Create aggregation functions to summarize insights across calls and visualize changes over time.",
            "status": "pending",
            "testStrategy": "Test with datasets containing multiple related calls. Verify accurate trend identification and meaningful aggregation of insights."
          }
        ]
      },
      {
        "id": 13,
        "title": "Rewards Engine",
        "description": "Implement the compliance-first rewards engine for advocate recognition, including charitable donations, professional development funds, and direct stipends.",
        "details": "1. Create reward data models and interfaces:\n   - Reward options management\n   - Reward history tracking\n   - Reward fulfillment status\n2. Implement reward types:\n   - Charitable donations integration\n   - Professional development fund management\n   - Direct stipend processing\n   - Company credits/team rewards\n3. Build reward selection and fulfillment flow:\n```typescript\n// services/rewardsService.ts\nexport const getAvailableRewards = async (companyId: string) => {\n  const { data, error } = await supabase\n    .from('reward_options')\n    .select('*')\n    .eq('company_id', companyId)\n    .eq('active', true)\n  \n  if (error) throw error\n  return data\n}\n\nexport const processReward = async (advocateId: string, callId: string, rewardOption: RewardOption) => {\n  // Create reward record\n  const reward = await createRewardRecord(advocateId, callId, rewardOption)\n  \n  // Process based on reward type\n  switch (rewardOption.type) {\n    case 'charity':\n      return processCharitableDonation(reward)\n    case 'development_fund':\n      return processDevelopmentFund(reward)\n    case 'stipend':\n      return processStipend(reward)\n    // Other reward types\n  }\n}\n```\n4. Implement tax documentation generation (1099 forms)\n5. Create reward tracking and reporting\n6. Build advocate reward history view\n7. Implement compliance checks and approvals workflow",
        "testStrategy": "Test reward selection and processing for different reward types. Verify tax documentation generation. Test compliance checks with various scenarios. Ensure proper tracking and reporting of rewards. Verify advocate reward history display.",
        "priority": "medium",
        "dependencies": [
          3,
          6,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Analytics Dashboard",
        "description": "Develop the program analytics dashboard for tracking reference program performance, including revenue influence, conversion rates, and advocate satisfaction.",
        "details": "1. Implement data collection and aggregation:\n   - Reference call metrics\n   - Opportunity conversion tracking\n   - Advocate participation metrics\n   - Program ROI calculations\n2. Create dashboard components:\n```typescript\n// components/dashboard/RevenueInfluenceChart.tsx\nconst RevenueInfluenceChart = ({ companyId, dateRange }: Props) => {\n  const [data, setData] = useState<ChartData>()\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      const revenueData = await getRevenueInfluenceData(companyId, dateRange)\n      setData(formatChartData(revenueData))\n    }\n    \n    fetchData()\n  }, [companyId, dateRange])\n  \n  return (\n    <div className=\"chart-container\">\n      <h3>Revenue Influence</h3>\n      {data ? <LineChart data={data} /> : <LoadingSpinner />}\n    </div>\n  )\n}\n```\n3. Build executive reporting templates:\n   - Program summary reports\n   - ROI analysis\n   - Advocate engagement metrics\n4. Implement data export functionality\n5. Create custom report builder\n6. Implement real-time dashboard updates",
        "testStrategy": "Test data collection and aggregation with sample datasets. Verify chart rendering with various data scenarios. Test report generation and export functionality. Ensure dashboard performance with large datasets. Verify real-time updates.",
        "priority": "medium",
        "dependencies": [
          7,
          11,
          12
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Multi-Tenant Architecture Implementation",
        "description": "Enhance the application with robust multi-tenant architecture for enterprise security, including tenant isolation, role-based access control, and white-label options.",
        "details": "1. Implement tenant isolation:\n   - Database row-level security policies\n   - API request tenant validation\n   - Storage isolation\n2. Create tenant middleware:\n```typescript\n// middleware/tenantMiddleware.ts\nexport function withTenant(handler) {\n  return async (req, res) => {\n    // Extract tenant ID from request\n    const tenantId = extractTenantId(req)\n    \n    if (!tenantId) {\n      return res.status(401).json({ error: 'Tenant ID not provided' })\n    }\n    \n    // Validate tenant access\n    const hasAccess = await validateTenantAccess(req.user, tenantId)\n    \n    if (!hasAccess) {\n      return res.status(403).json({ error: 'Access denied to this tenant' })\n    }\n    \n    // Add tenant context to request\n    req.tenantId = tenantId\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n3. Implement role-based access control:\n   - Permission definitions\n   - Role assignments\n   - Access control checks\n4. Build white-label customization:\n   - Theme customization\n   - Logo and branding settings\n   - Custom domain support\n5. Implement tenant-specific settings\n6. Create tenant provisioning and management tools",
        "testStrategy": "Test tenant isolation with cross-tenant access attempts. Verify role-based access control with various permission scenarios. Test white-label customization with different branding settings. Ensure proper tenant provisioning and management.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          5
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "API Development for Custom Integrations",
        "description": "Develop a comprehensive API for custom integrations, including authentication, rate limiting, and documentation.",
        "details": "1. Design RESTful API endpoints:\n   - Advocates management\n   - Opportunities management\n   - Reference calls management\n   - Analytics data access\n2. Implement API authentication:\n   - API key generation and validation\n   - OAuth 2.0 flow for third-party apps\n3. Create API middleware:\n```typescript\n// middleware/apiMiddleware.ts\nexport function withApiAuth(handler) {\n  return async (req, res) => {\n    // Extract API key from request\n    const apiKey = req.headers['x-api-key']\n    \n    if (!apiKey) {\n      return res.status(401).json({ error: 'API key required' })\n    }\n    \n    // Validate API key\n    const apiKeyData = await validateApiKey(apiKey)\n    \n    if (!apiKeyData) {\n      return res.status(403).json({ error: 'Invalid API key' })\n    }\n    \n    // Add API context to request\n    req.apiClient = apiKeyData.client\n    req.tenantId = apiKeyData.tenantId\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n4. Implement rate limiting and quota management\n5. Create API documentation using OpenAPI/Swagger\n6. Build API usage dashboard\n7. Implement webhook delivery for event notifications",
        "testStrategy": "Test API endpoints with various request scenarios. Verify authentication and authorization mechanisms. Test rate limiting with high-frequency requests. Ensure proper documentation generation. Verify webhook delivery for different events.",
        "priority": "low",
        "dependencies": [
          2,
          3,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Mobile Responsive Implementation",
        "description": "Ensure the application is fully responsive on mobile devices, implementing a Progressive Web App (PWA) for improved mobile experience.",
        "details": "1. Implement responsive design for all components:\n   - Flexible layouts with CSS Grid and Flexbox\n   - Mobile-first media queries\n   - Touch-friendly UI elements\n2. Create mobile-specific components when needed:\n   - Mobile navigation\n   - Touch-optimized forms\n   - Mobile calendar view\n3. Implement PWA features:\n```typescript\n// next.config.js\nconst withPWA = require('next-pwa');\n\nmodule.exports = withPWA({\n  pwa: {\n    dest: 'public',\n    register: true,\n    skipWaiting: true,\n  },\n  // other Next.js config\n});\n```\n4. Create service worker for offline functionality\n5. Implement app manifest for home screen installation\n6. Optimize performance for mobile devices:\n   - Image optimization\n   - Code splitting\n   - Lazy loading",
        "testStrategy": "Test responsive design across various device sizes and orientations. Verify PWA functionality including offline access and installation. Test touch interactions on mobile devices. Measure performance metrics on mobile devices.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Email Notification System",
        "description": "Implement a comprehensive email notification system for various events, including booking confirmations, reminders, and system notifications.",
        "details": "1. Set up SendGrid integration:\n   - API configuration\n   - Email templates\n   - Tracking and analytics\n2. Create email service:\n```typescript\n// services/emailService.ts\nexport const sendEmail = async (options: EmailOptions) => {\n  const { to, templateId, dynamicData } = options\n  \n  const msg = {\n    to,\n    from: process.env.SENDGRID_FROM_EMAIL,\n    templateId,\n    dynamicTemplateData: dynamicData,\n  }\n  \n  try {\n    await sendgrid.send(msg)\n    await logEmailSent(options)\n    return true\n  } catch (error) {\n    console.error('Email sending failed:', error)\n    await logEmailError(options, error)\n    return false\n  }\n}\n\nexport const sendBookingConfirmation = async (booking) => {\n  return sendEmail({\n    to: booking.prospect_email,\n    templateId: 'd-booking-confirmation-template-id',\n    dynamicData: {\n      advocate_name: booking.advocate.name,\n      meeting_time: formatDateTime(booking.scheduled_at),\n      meeting_link: booking.meeting_link,\n      // Other dynamic data\n    }\n  })\n}\n```\n3. Implement email templates for various events:\n   - Welcome emails\n   - Booking confirmations\n   - Meeting reminders\n   - Call follow-ups\n   - System notifications\n4. Create email preference management\n5. Implement email delivery tracking and reporting\n6. Build email template management interface",
        "testStrategy": "Test email sending with various templates and dynamic data. Verify email delivery tracking. Test email preference management. Ensure proper error handling for failed deliveries. Verify template rendering across email clients.",
        "priority": "high",
        "dependencies": [
          3,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Security Implementation and Compliance",
        "description": "Implement comprehensive security measures and compliance features, including SOC 2 compliance, GDPR/CCPA compliance, and data encryption.",
        "details": "1. Implement security best practices:\n   - HTTPS enforcement\n   - Content Security Policy\n   - CSRF protection\n   - XSS prevention\n2. Set up data encryption:\n   - Encryption at rest\n   - Encryption in transit\n   - Sensitive data handling\n3. Implement compliance features:\n   - Data retention policies\n   - Data export functionality\n   - Consent management\n   - Privacy policy implementation\n4. Create security monitoring and logging:\n```typescript\n// middleware/securityMiddleware.ts\nexport function withSecurityHeaders(handler) {\n  return (req, res) => {\n    // Set security headers\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n    res.setHeader('X-Frame-Options', 'DENY')\n    res.setHeader('X-XSS-Protection', '1; mode=block')\n    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin')\n    res.setHeader('Content-Security-Policy', \"default-src 'self'; script-src 'self' 'unsafe-inline';\")\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n\nexport function withAuditLogging(handler) {\n  return async (req, res) => {\n    // Log request details\n    const requestId = generateRequestId()\n    const startTime = Date.now()\n    \n    // Create response wrapper to capture status\n    const originalEnd = res.end\n    res.end = function(...args) {\n      const duration = Date.now() - startTime\n      logAuditEvent({\n        requestId,\n        userId: req.user?.id,\n        tenantId: req.tenantId,\n        method: req.method,\n        path: req.url,\n        statusCode: res.statusCode,\n        duration,\n        userAgent: req.headers['user-agent']\n      })\n      originalEnd.apply(res, args)\n    }\n    \n    // Continue to handler\n    return handler(req, res)\n  }\n}\n```\n5. Implement authentication security:\n   - Multi-factor authentication\n   - Password policies\n   - Session management\n6. Create security documentation and compliance reports",
        "testStrategy": "Conduct security testing including penetration testing and vulnerability scanning. Verify compliance features with regulatory requirements. Test data encryption and access controls. Ensure proper audit logging and monitoring. Verify authentication security measures.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Performance Optimization and Scalability",
        "description": "Optimize application performance and implement scalability measures to handle growing user base and data volume.",
        "details": "1. Implement frontend performance optimizations:\n   - Code splitting and lazy loading\n   - Image optimization\n   - Bundle size reduction\n   - Caching strategies\n2. Optimize database performance:\n   - Index optimization\n   - Query optimization\n   - Connection pooling\n   - Read/write separation for scaling\n3. Implement API performance enhancements:\n```typescript\n// middleware/cacheMiddleware.ts\nexport function withCaching(ttlSeconds = 60) {\n  return (handler) => {\n    return async (req, res) => {\n      // Only cache GET requests\n      if (req.method !== 'GET') {\n        return handler(req, res)\n      }\n      \n      // Generate cache key\n      const cacheKey = generateCacheKey(req)\n      \n      // Try to get from cache\n      const cachedResponse = await getFromCache(cacheKey)\n      \n      if (cachedResponse) {\n        return res.status(200).json(cachedResponse)\n      }\n      \n      // Create response wrapper to capture data\n      const originalJson = res.json\n      res.json = function(data) {\n        // Only cache successful responses\n        if (res.statusCode === 200) {\n          setInCache(cacheKey, data, ttlSeconds)\n        }\n        return originalJson.call(res, data)\n      }\n      \n      // Continue to handler\n      return handler(req, res)\n    }\n  }\n}\n```\n4. Set up CDN for static assets\n5. Implement horizontal scaling:\n   - Stateless application design\n   - Distributed caching\n   - Load balancing configuration\n6. Create performance monitoring and alerting\n7. Implement database sharding strategy for future growth",
        "testStrategy": "Conduct load testing to verify performance under high load. Measure and optimize page load times. Test database performance with large datasets. Verify caching effectiveness. Ensure horizontal scaling works correctly.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-09T14:08:57.331Z",
      "updated": "2025-09-10T14:03:45.147Z",
      "description": "Tasks for master context"
    }
  }
}