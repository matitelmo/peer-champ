{
  "master": {
    "tasks": [
      {
        "id": 22,
        "title": "Complete Opportunity List View with Filtering and Sorting",
        "description": "Implement the opportunity list view with comprehensive filtering and sorting capabilities to allow users to efficiently manage their sales opportunities.",
        "details": "Build a responsive list view component using React and Tailwind CSS that displays opportunities from the Supabase database. Implement client-side filtering with server-side pagination for optimal performance. Use React Query v5 for data fetching with proper caching strategies. Include filters for status, date range, value, and other key attributes. Implement sorting by clicking column headers. Add a search bar with debounced input for real-time filtering. Ensure mobile responsiveness with a simplified view on smaller screens. Follow the established design system for UI components. Include loading states, empty states, and error handling. Implement virtual scrolling for large datasets using react-window or similar library to maintain performance.",
        "testStrategy": "Write unit tests with Jest and React Testing Library to verify component rendering, filtering logic, and sorting functionality. Create integration tests with Cypress to validate the end-to-end user flow, including pagination, filtering, and sorting. Test edge cases like empty result sets and error states. Verify performance with large datasets. Test accessibility compliance using axe-core or similar tools.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Opportunity Details View with CRUD Operations",
        "description": "Create a comprehensive opportunity details view that allows users to view, create, update, and delete opportunity information with proper validation.",
        "details": "Develop a detailed view component using Next.js and React that displays all opportunity information. Implement form components using React Hook Form v7 with Zod for validation. Create a tabbed interface to organize different sections of opportunity data. Include fields for opportunity name, value, stage, contacts, notes, and timeline. Add edit mode toggle with inline editing capabilities. Implement optimistic UI updates for better user experience. Use Supabase client for CRUD operations with proper error handling. Add confirmation dialogs for destructive actions. Implement form validation with clear error messages. Include activity history and audit logs. Ensure all changes are reflected in real-time using Supabase subscriptions where appropriate.",
        "testStrategy": "Create unit tests for form validation logic and component rendering. Write integration tests for the complete CRUD workflow. Test validation error handling and edge cases. Verify that database operations correctly update the UI. Test optimistic updates and error recovery. Ensure accessibility compliance for all interactive elements.",
        "priority": "high",
        "dependencies": [
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Develop Opportunity Creation and Edit Forms with Validation",
        "description": "Build comprehensive forms for creating and editing opportunities with robust validation, field dependencies, and intuitive user experience.",
        "details": "Create reusable form components using React Hook Form v7 with Zod schema validation. Implement multi-step form wizard for opportunity creation with progress indicator. Add conditional form fields based on opportunity type and stage. Include dynamic field validation with immediate feedback. Implement auto-save functionality for draft opportunities. Add rich text editor for notes and descriptions using TipTap or Slate.js. Create custom form controls for specialized inputs like currency, percentages, and date ranges. Implement file upload for opportunity attachments using Supabase Storage. Add form submission handling with loading states and success/error feedback. Ensure all forms follow the established design system and maintain consistency across the application.",
        "testStrategy": "Write unit tests for form validation logic, conditional rendering, and submission handling. Create integration tests for the complete form submission flow. Test validation error scenarios and field dependencies. Verify file upload functionality and storage integration. Test form accessibility using screen readers and keyboard navigation. Conduct usability testing with representative users to validate the form flow.",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement CRM Integration for Opportunities (Salesforce & HubSpot)",
        "description": "Develop bidirectional integration with Salesforce and HubSpot CRMs to sync opportunity data, enabling seamless workflow between PeerChamp and existing CRM systems.",
        "details": "Create a CRM integration service using Next.js API routes. Implement OAuth 2.0 authentication flow for both Salesforce and HubSpot. Use Salesforce REST API and metadata API for data synchronization. Implement HubSpot API v3 integration for deals and contacts. Create a mapping configuration UI to allow customers to map PeerChamp fields to their CRM fields. Develop a background job system using Bull or similar for asynchronous syncing. Implement webhook handlers for real-time updates from CRMs. Add conflict resolution strategy for bidirectional sync. Create detailed logging for sync operations. Implement retry logic for failed API calls. Store OAuth tokens securely in Supabase with proper encryption. Add admin dashboard for monitoring sync status and resolving conflicts.",
        "testStrategy": "Create mock CRM APIs for testing integration flows. Write unit tests for mapping logic and data transformation. Develop integration tests for authentication flows and data synchronization. Test error handling and retry mechanisms. Verify webhook processing and real-time updates. Test with actual Salesforce and HubSpot sandbox environments. Create end-to-end tests for the complete sync workflow.",
        "priority": "medium",
        "dependencies": [
          23,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Build Opportunity Status Tracking and Pipeline Management",
        "description": "Implement a visual pipeline management system that allows users to track opportunity status, move opportunities through stages, and visualize the sales pipeline.",
        "details": "Create a Kanban-style board view using react-beautiful-dnd or similar library. Implement drag-and-drop functionality for moving opportunities between stages. Add column configuration options for customizing pipeline stages. Create summary statistics for each pipeline stage (count, value, etc.). Implement filters for the pipeline view by owner, date range, and value. Add quick-edit functionality for updating opportunity details from the board view. Implement pipeline analytics with conversion rates between stages. Create visual indicators for opportunity age and priority. Add board view preferences that persist per user. Ensure real-time updates using Supabase subscriptions. Optimize performance for boards with many opportunities using virtualization.",
        "testStrategy": "Write unit tests for board component rendering and state management. Create integration tests for drag-and-drop functionality and status updates. Test filter and search functionality. Verify that analytics calculations are accurate. Test performance with large datasets. Ensure accessibility compliance for the board view. Test real-time updates and concurrent editing scenarios.",
        "priority": "medium",
        "dependencies": [
          22,
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Develop Advocate Profile Management System",
        "description": "Create a comprehensive advocate profile management system that allows for detailed advocate information, expertise tracking, and performance metrics.",
        "details": "Build advocate profile components with React and Tailwind CSS. Implement profile creation and editing forms with React Hook Form and Zod validation. Create fields for personal information, expertise areas, industry experience, and preferences. Add profile completeness indicator to encourage full profiles. Implement profile photo upload using Supabase Storage. Create tagging system for skills and expertise areas. Add performance metrics dashboard showing advocate activity and success rates. Implement profile visibility settings and privacy controls. Create admin view for managing advocate profiles. Add notes and internal rating system for advocate quality. Implement advocate search with filtering by expertise, availability, and performance metrics. Ensure all profile data is properly secured with Supabase RLS policies.",
        "testStrategy": "Write unit tests for profile component rendering and form validation. Create integration tests for the complete profile creation and editing flow. Test file upload functionality for profile photos. Verify search and filtering capabilities. Test privacy controls and permission settings. Ensure accessibility compliance for all profile components. Test performance metrics calculations for accuracy.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement Advocate Availability Scheduling with Calendar Integration",
        "description": "Build a scheduling system that allows advocates to set their availability and integrates with their calendars (Google Calendar, Outlook) for automatic availability updates.",
        "details": "Create a calendar view component using react-big-calendar or similar library. Implement Google Calendar API integration using OAuth 2.0. Add Microsoft Outlook Calendar integration via Microsoft Graph API. Create a recurring availability setting interface (e.g., available every Tuesday 2-4pm). Implement time zone handling using date-fns-tz or similar. Add buffer time settings between calls. Create availability exceptions for holidays and time off. Implement real-time availability checking when scheduling calls. Add calendar sync settings to control which events affect availability. Create webhook handlers for calendar update notifications. Implement caching strategy for calendar data to minimize API calls. Add manual override options for availability. Ensure proper error handling for API failures.",
        "testStrategy": "Write unit tests for availability calculation logic and calendar rendering. Create integration tests for OAuth flows and calendar synchronization. Test time zone handling with various user locations. Verify recurring availability patterns and exceptions. Test calendar webhook processing. Create end-to-end tests for the complete availability management flow. Test with actual Google Calendar and Outlook sandbox environments.",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Create Advocate Directory with Search and Filtering",
        "description": "Develop a searchable advocate directory that allows sales teams to find appropriate advocates based on various criteria such as industry, expertise, and availability.",
        "details": "Build a responsive directory view with card-based advocate listings. Implement advanced search functionality with Postgres full-text search via Supabase. Create filter controls for industry, expertise, seniority, location, and availability. Add sorting options by relevance, activity level, and success rate. Implement pagination with infinite scroll for better UX. Create detailed advocate cards showing key information and availability status. Add quick-action buttons for initiating reference requests. Implement saved searches and favorite advocates features. Create list and grid view options. Add keyboard navigation for accessibility. Optimize query performance with proper indexing in Supabase. Implement debounced search input for real-time results. Add empty state and no-results handling with suggestions.",
        "testStrategy": "Write unit tests for search component rendering and filter logic. Create integration tests for search functionality and result rendering. Test pagination and infinite scroll behavior. Verify filter combinations and edge cases. Test search performance with large datasets. Ensure accessibility compliance for directory navigation. Test saved searches and favorites functionality.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement Advocate Onboarding and Verification Process",
        "description": "Create a structured onboarding flow for new advocates that includes verification steps, training materials, and compliance checks.",
        "details": "Build a multi-step onboarding wizard using React and a state management library like Zustand. Create verification steps including email verification, profile completion, and compliance agreement. Implement document upload for verification materials using Supabase Storage. Add interactive training modules with completion tracking. Create knowledge check quizzes to ensure understanding of advocate responsibilities. Implement approval workflow for admin verification of new advocates. Add email notification system using SendGrid for onboarding communications. Create onboarding progress dashboard for advocates and admins. Implement reminder system for incomplete onboarding steps. Add compliance tracking for terms acceptance and training completion. Create reusable onboarding components that can be updated as requirements change.",
        "testStrategy": "Write unit tests for onboarding component rendering and state management. Create integration tests for the complete onboarding flow. Test file upload functionality for verification documents. Verify email notification sending and template rendering. Test admin approval workflow and status updates. Ensure accessibility compliance for all onboarding steps. Test with various user personas to validate the onboarding experience.",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Develop Call Scheduling System with Calendar Integration",
        "description": "Build a reference call scheduling system that integrates with calendars, checks availability, and automates the scheduling process between sales teams, advocates, and prospects.",
        "details": "Create a scheduling interface using React with date-fns for date manipulation. Implement three-way availability checking between sales rep, advocate, and prospect. Create calendar integration with Google Calendar and Outlook using their respective APIs. Implement time slot suggestion algorithm based on availability data. Add scheduling preferences for call duration and buffer times. Create email notifications for scheduled calls using SendGrid. Implement calendar invite generation and distribution. Add rescheduling and cancellation workflows with appropriate notifications. Create scheduling links that can be shared with prospects. Implement timezone detection and conversion for all participants. Add reminder system for upcoming calls. Create conflict detection and resolution for scheduling changes. Implement webhook handlers for external calendar updates.",
        "testStrategy": "Write unit tests for availability checking logic and time slot generation. Create integration tests for the scheduling workflow and calendar integration. Test email notification sending and template rendering. Verify timezone handling with participants in different regions. Test rescheduling and cancellation flows. Create end-to-end tests for the complete scheduling process. Test with actual calendar services in sandbox environments.",
        "priority": "high",
        "dependencies": [
          28
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Meeting Link Generation with Video Conferencing Integration",
        "description": "Create a system that automatically generates meeting links for scheduled reference calls by integrating with video conferencing platforms like Zoom and Microsoft Teams.",
        "details": "Implement Zoom API integration for meeting creation and management. Add Microsoft Teams meeting generation via Microsoft Graph API. Create a service to automatically generate meeting links when calls are scheduled. Implement OAuth flows for connecting user accounts to video platforms. Add meeting preference settings for hosts (waiting rooms, recording, etc.). Create fallback options if primary video platform is unavailable. Implement meeting link distribution via calendar invites and emails. Add meeting update and cancellation handling. Create admin settings for organization-wide video platform preferences. Implement secure storage of API credentials in Supabase. Add detailed logging for meeting creation and updates. Create webhook handlers for meeting status updates from video platforms.",
        "testStrategy": "Write unit tests for meeting generation logic and API integration. Create integration tests for OAuth flows and meeting creation. Test meeting update and cancellation scenarios. Verify email and calendar distribution of meeting links. Test with actual Zoom and Teams sandbox environments. Create end-to-end tests for the complete meeting lifecycle. Test error handling and fallback mechanisms.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Google Meet Integration for Basic Meeting Link Generation",
            "description": "Create a service that integrates with Google Meet API to generate meeting links for scheduled reference calls as the initial MVP approach.",
            "dependencies": [],
            "details": "Set up Google Meet API client with proper authentication. Create a service function that generates a new Google Meet link when a call is scheduled. Implement secure storage of Google API credentials in Supabase. Add error handling and logging for the meeting creation process. Ensure the generated meeting links are properly formatted and stored with the call data.\n<info added on 2025-09-16T22:03:11.774Z>\nImplementation of Google Meet integration for basic meeting link generation is now complete. The solution includes a comprehensive meeting service in `src/lib/services/meetingService.ts` with functions for generating Google Meet links, managing meeting preferences, and handling validation. The service integrates with the reference call system through an extended `createReferenceCallWithMeeting()` function in `src/lib/services/referenceCallService.ts`. A React hook `useMeetings` provides state management and meeting operations, while UI components for meeting preferences and link generation have been created. The implementation uses a simple Google Meet link format for the MVP, integrates with existing database tables without requiring migrations, includes error handling, and supports multiple meeting platforms. The system is ready for the next phase of implementing the meeting preferences UI.\n</info added on 2025-09-16T22:03:11.774Z>",
            "status": "done",
            "testStrategy": "Write unit tests for the Google Meet integration service. Test successful meeting link generation with mock API responses. Verify error handling when API calls fail. Test credential storage and retrieval from Supabase. Create integration tests with Google Meet sandbox environment."
          },
          {
            "id": 2,
            "title": "Create Meeting Preference Settings for Hosts",
            "description": "Implement a user interface and backend storage for meeting hosts to set their preferences for video calls, such as waiting rooms and recording options.",
            "dependencies": [
              "32.1"
            ],
            "details": "Design and implement a settings UI component for meeting preferences. Create database schema for storing user meeting preferences. Implement API endpoints to save and retrieve meeting preferences. Apply these preferences when generating meeting links. Include options for waiting rooms, recording settings, and default meeting duration.\n<info added on 2025-09-16T22:05:28.730Z>\nâœ… COMPLETED: Meeting Preference Settings for Hosts\n\n**What was implemented:**\n1. **Database Schema** (`supabase/migrations/20240101000008_create_user_settings_table.sql`):\n   - Created user_settings table with meeting_preferences JSONB field\n   - Includes notification_preferences and ui_preferences for future expansion\n   - Proper RLS policies for user data isolation\n   - Automatic updated_at timestamp triggers\n\n2. **Meeting Preferences Component** (`src/components/meetings/MeetingPreferences.tsx`):\n   - Complete UI for managing meeting preferences\n   - Settings for waiting room, recording, duration, auto-mute, screen sharing\n   - Real-time save/reset functionality with change detection\n   - Error handling and loading states\n   - Responsive design with proper accessibility\n\n3. **Settings Page** (`src/app/settings/page.tsx`):\n   - Dedicated settings page with meeting preferences section\n   - Extensible structure for future preference categories\n   - Clean, organized layout following design system\n\n4. **Navigation Integration**:\n   - Added \"Meetings\" link to dashboard navigation with VideoCameraIcon\n   - Settings link already existed in user menu\n   - Proper navigation structure for accessing meeting features\n\n5. **Icon Support**:\n   - Added LinkIcon to icons library for meeting link generation\n   - All required icons are now available\n\n**Technical Details:**\n- Uses existing user_settings table pattern with JSONB for flexibility\n- Integrates with useMeetings hook for state management\n- Follows established component patterns and design system\n- Includes proper TypeScript types and error handling\n- Responsive design works on mobile and desktop\n\n**Database Integration:**\n- New user_settings table with proper RLS policies\n- Meeting preferences stored as JSONB for flexibility\n- Automatic timestamp management with triggers\n- User data isolation through company-based RLS\n\n**UI/UX Features:**\n- Intuitive settings interface with clear labels and descriptions\n- Real-time feedback for changes and saves\n- Error handling with dismissible alerts\n- Loading states for better user experience\n- Consistent with existing design system\n\n**Next Steps:**\n- Ready for meeting link distribution implementation (subtask 32.3)\n- Settings are now accessible via /settings route\n- Meeting preferences will be applied when generating meeting links\n</info added on 2025-09-16T22:05:28.730Z>",
            "status": "done",
            "testStrategy": "Write unit tests for the preferences component rendering. Test API endpoints for saving and retrieving preferences. Verify that preferences are correctly applied when generating meeting links. Test the UI for usability and accessibility compliance."
          },
          {
            "id": 3,
            "title": "Implement Meeting Link Distribution via Calendar Invites and Emails",
            "description": "Create a system to automatically distribute generated meeting links to participants through calendar invites and email notifications.",
            "dependencies": [
              "32.1"
            ],
            "details": "Implement calendar invite generation using iCalendar format. Create email templates for meeting notifications using a templating engine. Integrate with SendGrid or similar email service for sending notifications. Add functionality to include meeting links and details in both calendar invites and emails. Implement scheduling logic to send reminders before meetings.\n<info added on 2025-09-16T22:10:25.452Z>\n## Implementation Details\n\nThe Meeting Link Distribution system has been successfully implemented with the following components:\n\n1. **Email Service** (`src/lib/services/emailService.ts`):\n   - Comprehensive email service with meeting notification templates\n   - Support for different recipient types (prospect, advocate, sales_rep)\n   - iCalendar invite generation for calendar integration\n   - Mock email sending for MVP (ready for SendGrid/AWS SES integration)\n   - Template system with HTML and text versions\n\n2. **Meeting Notifications Hook** (`src/hooks/useMeetingNotifications.tsx`):\n   - React hook for managing meeting notifications and calendar invites\n   - State management for sending status and error handling\n   - Support for both email notifications and calendar invites\n   - Result tracking for each recipient\n\n3. **Meeting Notifications Component** (`src/components/meetings/MeetingNotifications.tsx`):\n   - Complete UI for sending meeting notifications\n   - Meeting details summary with participant information\n   - Separate actions for email notifications and calendar invites\n   - Real-time status feedback and error handling\n   - Results display showing success/failure for each recipient\n\n4. **Enhanced Meeting Link Generator** (`src/components/meetings/MeetingLinkGenerator.tsx`):\n   - Added tabbed interface with \"Generate Meeting\" and \"Notifications\" tabs\n   - Integrated meeting notifications functionality\n   - Seamless workflow from meeting generation to notification sending\n\n5. **Tabs Component** (`src/components/ui/TabsNew.tsx`):\n   - New tabbed interface component for organizing content\n   - Proper context-based state management\n   - Accessible design with keyboard navigation support\n\nEmail templates include meeting details, participant info, and meeting links with different tones for each recipient type. The iCalendar format ensures cross-platform calendar compatibility with proper timezone handling and meeting reminders. The user experience features a tabbed interface with real-time feedback on notification status.\n</info added on 2025-09-16T22:10:25.452Z>",
            "status": "done",
            "testStrategy": "Test calendar invite generation with various meeting parameters. Verify email template rendering with different meeting details. Create integration tests for the email sending service. Test the complete flow from meeting creation to notification delivery. Verify that meeting links are correctly included in all communications."
          },
          {
            "id": 4,
            "title": "Implement Manual Fallback Options for Meeting Creation",
            "description": "Create a system that allows for manual meeting link entry when automatic generation fails or when users prefer to use their own meeting links.",
            "dependencies": [
              "32.1",
              "32.2"
            ],
            "details": "Design and implement a UI for manual meeting link entry. Create validation logic for entered meeting URLs. Implement a fallback mechanism that prompts for manual entry when automatic generation fails. Add an option in user preferences to always use manual links. Create a database schema to track whether a meeting link was auto-generated or manually entered.",
            "status": "done",
            "testStrategy": "Test the manual entry UI for usability and validation. Verify the fallback mechanism triggers appropriately when automatic generation fails. Test that manually entered links are properly stored and distributed. Create integration tests for the complete fallback workflow."
          },
          {
            "id": 5,
            "title": "Add Meeting Update and Cancellation Handling",
            "description": "Implement functionality to handle updates to meeting times or cancellations, ensuring all participants are notified and calendar events are updated.",
            "dependencies": [
              "32.3"
            ],
            "details": "Create API endpoints for updating and cancelling meetings. Implement logic to regenerate or update meeting links when meeting details change. Create notification system for meeting updates and cancellations. Update calendar invites with new information or cancellation status. Implement database transactions to ensure data consistency during updates. Add logging for all meeting changes for audit purposes.",
            "status": "done",
            "testStrategy": "Write unit tests for meeting update and cancellation logic. Test notification generation for various update scenarios. Verify calendar invite updates are correctly formatted. Create integration tests for the complete update and cancellation workflows. Test edge cases like multiple updates to the same meeting."
          }
        ]
      },
      {
        "id": 33,
        "title": "Build Call Intelligence and Feedback Collection System",
        "description": "Develop a system to collect, analyze, and present feedback and intelligence from reference calls, including sentiment analysis and key talking points.",
        "details": "Create post-call feedback forms using React Hook Form with different versions for sales reps, advocates, and prospects. Implement sentiment analysis using OpenAI GPT-4 API to extract key insights from feedback. Build a call intelligence dashboard showing trends and patterns across calls. Add call recording integration with transcription capabilities (optional based on compliance). Implement key talking point extraction and categorization. Create success metrics tracking based on call outcomes. Add competitive intelligence tagging and organization. Implement feedback reminder system using SendGrid for email notifications. Create historical view of feedback trends over time. Add natural language processing for theme extraction from feedback. Implement data visualization for call intelligence using Chart.js or similar. Ensure all data collection complies with privacy regulations.",
        "testStrategy": "Write unit tests for feedback form validation and submission. Create integration tests for the complete feedback collection flow. Test sentiment analysis and insight extraction with various feedback samples. Verify email notification sending for feedback reminders. Test dashboard rendering and data visualization. Ensure accessibility compliance for all feedback forms. Test privacy controls and data handling compliance.",
        "priority": "medium",
        "dependencies": [
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implement AI-Powered Advocate Matching Algorithm",
        "description": "Develop an intelligent matching system that uses AI to pair the most appropriate advocates with specific sales opportunities based on various factors.",
        "details": "Create a matching service using OpenAI GPT-4 API for intelligent pairing. Implement a scoring algorithm that considers advocate expertise, industry experience, communication style, and availability. Build a recommendation engine that suggests optimal advocates for each opportunity. Create a matching configuration interface for admins to adjust matching parameters. Implement feedback loop that improves matches based on outcomes. Add manual override options for sales teams. Create detailed match explanation to show why advocates were recommended. Implement batch matching for multiple opportunities. Add urgency-based prioritization for time-sensitive opportunities. Create caching strategy to optimize API usage and performance. Implement A/B testing framework to compare matching algorithms. Add match quality metrics and reporting. Ensure algorithm considers compliance requirements and advocate workload balance.",
        "testStrategy": "Write unit tests for matching algorithm logic and scoring calculations. Create integration tests with the OpenAI API using mock responses. Test various matching scenarios with different opportunity and advocate profiles. Verify that feedback improves future matching quality. Test performance with large datasets of advocates and opportunities. Create end-to-end tests for the complete matching workflow. Test edge cases like limited advocate availability or highly specialized requirements.",
        "priority": "high",
        "dependencies": [
          27,
          29,
          33
        ],
        "status": "deferred",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Develop Rewards and Compliance System",
        "description": "Create a comprehensive system for managing advocate rewards, including selection interfaces, payment processing, charitable donations, and compliance documentation.",
        "details": "Build a rewards catalog interface with various reward options. Implement Stripe API integration for direct payments to advocates. Create charitable donation processing using relevant donation APIs. Implement reward point system with accrual based on advocate activities. Add reward selection and redemption workflow. Create tax documentation generation for 1099 forms using appropriate tax APIs. Implement compliance checks and approval workflows for rewards. Add reward history and tracking for advocates and admins. Create reward budget management for organizations. Implement automatic reward triggers based on advocate activity. Add email notifications for reward status updates using SendGrid. Create audit trails for all reward transactions. Implement reporting for reward program effectiveness. Ensure all payment processing complies with financial regulations.",
        "testStrategy": "Write unit tests for reward calculation logic and point accrual. Create integration tests for Stripe payment processing and donation handling. Test tax documentation generation with various scenarios. Verify email notification sending for reward updates. Test approval workflows and compliance checks. Create end-to-end tests for the complete reward redemption process. Test with Stripe test environment for payment processing. Ensure security compliance for financial data handling.",
        "priority": "low",
        "dependencies": [
          27,
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Implement Post-Call Analytics and Reporting",
        "description": "Develop comprehensive analytics and reporting features for reference calls, including success metrics, advocate performance, and business impact analysis.",
        "details": "Create a reporting dashboard using Chart.js or similar visualization library. Implement key metrics calculation including call completion rate, advocate satisfaction, and sales impact. Build custom report generation with exportable formats (CSV, PDF). Add filtering and date range selection for reports. Implement scheduled report delivery via email using SendGrid. Create advocate performance scorecards showing individual metrics. Add opportunity influence tracking to measure reference call impact on deals. Implement trend analysis for call effectiveness over time. Create comparison reports between teams, advocates, or time periods. Add drill-down capabilities for detailed analysis. Implement custom metric definition for organizations with specific needs. Create data aggregation services for efficient reporting. Ensure all reports are accessible and printable.",
        "testStrategy": "Write unit tests for metric calculation logic and report generation. Create integration tests for dashboard rendering and data visualization. Test export functionality for various formats. Verify email delivery of scheduled reports. Test performance with large datasets. Ensure accessibility compliance for all reporting interfaces. Test filtering and date range functionality for accuracy.",
        "priority": "medium",
        "dependencies": [
          33
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Fix Vercel Deployment Build Errors",
        "description": "Resolve various build errors occurring during Vercel deployment including component imports, API updates, TypeScript errors, and package dependencies to ensure successful production builds.",
        "details": "1. Fix missing Progress component:\n   - Identify where the Progress component is being imported\n   - Either implement the missing component or install the appropriate package\n   - Update imports to use the correct path\n\n2. Resolve icon import issues:\n   - Check all icon imports and ensure they follow the correct pattern\n   - Update any deprecated icon import syntax\n   - Verify icon packages are properly listed in package.json\n\n3. Update date-fns-tz API usage:\n   - Review all instances of date-fns-tz usage\n   - Update to the latest API patterns according to documentation\n   - Test date/timezone functionality after updates\n\n4. Fix TypeScript errors in AvailabilityManager:\n   - Address type definitions and interfaces in AvailabilityManager component\n   - Resolve any null/undefined handling issues\n   - Ensure proper typing for all props and state variables\n\n5. Correct Badge component variants:\n   - Update Badge component to support all required variants\n   - Fix any type errors related to variant props\n   - Ensure consistent styling across all variants\n\n6. Add missing react-beautiful-dnd package:\n   - Install react-beautiful-dnd: `npm install react-beautiful-dnd`\n   - Add types: `npm install @types/react-beautiful-dnd --save-dev`\n   - Update package.json and lock files\n\n7. Fix hook method naming issues:\n   - Rename hook methods to follow React conventions (use* prefix)\n   - Update all references to these hooks throughout the codebase\n   - Ensure hooks follow React rules (only called at top level, etc.)\n\n8. Resolve stage mapping issues:\n   - Identify and fix incorrect stage mappings in the application\n   - Ensure consistent stage values between frontend and backend\n   - Add validation for stage values\n\n9. Fix industry property references:\n   - Update components that reference industry properties\n   - Ensure consistent property naming across the application\n   - Add fallbacks for missing industry data\n\n10. Resolve export conflicts:\n    - Identify files with conflicting exports\n    - Refactor to use named exports where appropriate\n    - Ensure consistent export patterns across the codebase\n\n11. Create a comprehensive build verification process:\n    - Add pre-build checks for common errors\n    - Document common build issues and their solutions\n    - Set up local environment that mirrors Vercel for testing",
        "testStrategy": "1. Set up a local build environment that mirrors Vercel configuration:\n   - Use `vercel build` command locally to test builds\n   - Create a CI/CD pipeline that matches Vercel's build process\n\n2. Create a systematic testing approach for each error type:\n   - Test Progress component rendering in all relevant views\n   - Verify all icons display correctly across the application\n   - Test date/time functionality with various timezones\n   - Run TypeScript compiler with strict mode to catch type errors\n   - Test Badge component with all possible variant values\n   - Verify drag-and-drop functionality using react-beautiful-dnd\n   - Test all custom hooks in isolation with React Testing Library\n   - Verify stage mapping with test data covering all possible stages\n   - Test industry property references with mock data\n   - Check for export conflicts using ESLint rules\n\n3. Implement automated build verification:\n   - Add TypeScript compilation check to pre-commit hooks\n   - Set up ESLint rules to catch import/export issues\n   - Create a build log analyzer to identify recurring issues\n\n4. Perform cross-browser testing after fixes:\n   - Test in Chrome, Firefox, Safari, and Edge\n   - Verify mobile responsiveness after build fixes\n\n5. Create deployment test environments:\n   - Set up staging environment on Vercel\n   - Implement progressive deployment to catch issues early\n\n6. Document verification process:\n   - Create checklist for manual verification steps\n   - Document common build errors and solutions for the team\n   - Update README with build troubleshooting information",
        "status": "done",
        "dependencies": [
          33,
          34,
          36
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-09T14:08:57.331Z",
      "updated": "2025-09-16T22:25:09.423Z",
      "description": "Tasks for master context"
    }
  }
}